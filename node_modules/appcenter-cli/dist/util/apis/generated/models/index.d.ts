/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */

import * as moment from "moment";

export interface GetInAppUpdateTokenResponse {
  /**
   * The api token generated will not be accessible again
  */
  token: string;
}

export interface ApiTokensCreateResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The api token generated will not be accessible again
  */
  apiToken: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface ApiTokensCreateRequest {
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
}

export interface ApiTokensGetResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface Status {
  status: string;
}

export interface Failure {
  message: string;
}

export interface ErrorResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorResponse {
  error: ErrorResponseError;
}

export interface ErrorDetails {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SuccessResponse {
  message: string;
}

export interface AADTenantAddRequest {
  /**
   * The user wanting to add this tenant to the organization, must be an admin of the organization
  */
  userId: string;
  /**
   * The AAD tenant id
  */
  aadTenantId: string;
  /**
   * The name of the AAD Tenant
  */
  displayName: string;
}

export interface AADTenantResponse {
  /**
   * The AAD tenant id
  */
  aadTenantId: string;
  /**
   * The name of the AAD Tenant
  */
  displayName: string;
}

export interface AddAppTesterRequest {
  /**
   * The user ID of the tester that needs to be added
  */
  userId: string;
  /**
   * The ID of the release the user was added to
  */
  releaseId: number;
}

export interface AddAppTesterResponse {
  /**
   * The user ID of the tester that needs to be added
  */
  userId: string;
  /**
   * The ID of the release the user was added to
  */
  releaseId: number;
}

export interface ApiTokensPostRequest {
  /**
   * The description of the token
  */
  description?: string;
  /**
   * An encrypted value of the token.
  */
  encryptedToken?: string;
  /**
   * The scope for this token. An array of supported roles.
  */
  scope?: string[];
  /**
   * The hashed value of api token
  */
  tokenHash?: string;
  /**
   * The token's type. public:managed by the user; in_app_update:special token for in-app update
   * scenario; buid:dedicated for CI usage for now; session:for CLI session management; tester_app:
   * used for tester mobile app; default is "public".'. Possible values include: 'public',
   * 'in_app_update', 'build', 'session', 'tester_app'
  */
  tokenType?: string;
}

export interface AppPatchRequest {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName?: string;
  /**
   * A one-word descriptive release type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The uuid for the icon's asset id from ACFUS
  */
  iconAssetId?: string;
}

export interface AppRepoPatchRequest {
  /**
   * The absolute URL of the repository
  */
  repoUrl?: string;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The external user id from the provider
  */
  externalUserId?: string;
  /**
   * The id of the service connection stored in customer credential store
  */
  serviceConnectionId?: string;
}

export interface AppRepoPostRequest {
  /**
   * The absolute URL of the repository
  */
  repoUrl: string;
  /**
   * The provider of the repository. Possible values include: 'github', 'bitbucket', 'vsts',
   * 'gitlab'
  */
  repoProvider?: string;
  /**
   * The unique id (UUID) of the user who configured the repository
  */
  userId: string;
  /**
   * Installation id from the provider
  */
  installationId?: string;
  /**
   * Repository id from the provider
  */
  repoId?: string;
  /**
   * The external user id from the provider
  */
  externalUserId?: string;
  /**
   * The id of the service connection stored in customer credential store
  */
  serviceConnectionId?: string;
}

export interface AppRequest {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The descriptive name of the app. This can contain any characters
  */
  displayName: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Xamarin', 'Unity', 'Electron', 'WPF', 'WinForms', 'Custom'
  */
  platform: string;
}

export interface AppAddRequest {
  /**
   * The name of the app to be added to the distribution group
  */
  name: string;
}

export interface AppDeleteRequest {
  /**
   * The name of the app to be deleted from the distribution group
  */
  name: string;
}

export interface AzureSubscriptionAddRequest {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
}

export interface AzureSubscriptionUpdateBillableRequest {
  /**
   * Billable status of the subscription
  */
  isBillable: boolean;
}

export interface AzureSubscriptionPatchRequest {
  /**
   * If the subscription is used for billing
  */
  isBilling: boolean;
}

export interface AzureSubscriptionAddToAppRequest {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
}

export interface DistributionGroupPatchRequest {
  /**
   * The name of the distribution group
  */
  name?: string;
  /**
   * Whether the distribution group is public
  */
  isPublic?: boolean;
}

export interface DistributionGroupRequest {
  /**
   * The name of the distribution group
  */
  name: string;
  /**
   * The display name of the distribution group. If not specified, the name will be used.
  */
  displayName?: string;
}

export interface AppDistributionGroupUsersRequest {
  memberIds?: string[];
}

export interface DistributionGroupUserRequest {
  /**
   * The list of emails of the users
  */
  userEmails?: string[];
}

export interface DistributionGroupAppAddRequestAppsItem {
  /**
   * The name of the app to be added to the distribution group
  */
  name: string;
}

export interface DistributionGroupAppAddRequest {
  /**
   * The list of apps to add to distribution group
  */
  apps?: DistributionGroupAppAddRequestAppsItem[];
}

export interface DistributionGroupAppsDeleteRequestAppsItem {
  /**
   * The name of the app to be deleted from the distribution group
  */
  name: string;
}

export interface DistributionGroupAppsDeleteRequest {
  /**
   * The list of apps to delete from the distribution group
  */
  apps?: DistributionGroupAppsDeleteRequestAppsItem[];
}

export interface DistributionGroupAADGroupsDeleteRequest {
  /**
   * The list of aad group ids
  */
  aadGroupIds?: string[];
}

export interface DataDeletionRequest {
  /**
   * Type of data to delete
  */
  dataDeletionType?: string;
}

export interface DistributionGroupAADGroupRequestAadGroupsItem {
  /**
   * The id of the aad group
  */
  aadGroupId?: string;
  /**
   * The display name of the aad group
  */
  displayName?: string;
}

export interface DistributionGroupAADGroupRequest {
  /**
   * The list of aad group ids and names to add
  */
  aadGroups?: DistributionGroupAADGroupRequestAadGroupsItem[];
}

export interface DistributionGroupAADGroupBase {
  /**
   * The id of the aad group
  */
  aadGroupId?: string;
  /**
   * The display name of the aad group
  */
  displayName?: string;
}

export interface DistributionGroupsUserVerifyRequestDistributionGroupIdsItem {
  /**
   * The id of the distribution group
  */
  id: string;
}

export interface DistributionGroupsUserVerifyRequest {
  /**
   * An array of distribution group ids
  */
  distributionGroupIds: DistributionGroupsUserVerifyRequestDistributionGroupIdsItem[];
}

export interface DistributionGroupIdRequest {
  /**
   * The id of the distribution group
  */
  id: string;
}

export interface EmailVerificationRequest {
  /**
   * The verification token that was sent to the user
  */
  token: string;
}

export interface ExternalUserRequest {
  /**
   * The token of the app invitation which lead to signup
  */
  appInvitation?: string;
  /**
   * The token of the test invitation which lead to signup
  */
  testerInvitation?: string;
  /**
   * The token of the organization invitation which lead to signup
  */
  organizationInvitation?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user. If no explicit value is given, a default
   * will be auto-generated from the `display_name` value
  */
  name?: string;
}

export interface ExternalAppId {
  /**
   * The identifier for external apps that map to an App Center app
  */
  externalId?: string;
}

export interface FeaturePatchRequest {
  /**
   * The friendly name of the feature
  */
  description?: string;
  /**
   * The full (friendly) name of the feature.
  */
  displayName?: string;
  /**
   * The state of the feature
  */
  state?: number;
}

export interface FeatureCreateRequest {
  /**
   * The unique name of the feature
  */
  name: string;
  /**
   * The full (friendly) name of the feature.
  */
  displayName: string;
  /**
   * The state of the feature
  */
  state?: number;
  /**
   * The friendly name of the feature
  */
  description?: string;
}

export interface GrantAdminRoleRequest {
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole: string;
}

export interface InternalBulkAppResponse {
  /**
   * The name of the app
  */
  appName?: string;
  /**
   * The display name of the owner
  */
  ownerDisplayName?: string;
}

export interface InternalUserRequest {
  /**
   * The token of the app invitation which lead to signup
  */
  appInvitation?: string;
  /**
   * The token of the test invitation which lead to signup
  */
  testerInvitation?: string;
  /**
   * The token of the organization invitation which lead to signup
  */
  organizationInvitation?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The password of the user. Needs to be at least 8 characters long and contain at least one
   * lower- and one uppercase letter.
  */
  password: string;
  /**
   * The sub-domain of the portal from which this request was made. Will be used to build the
   * invitation link. Possible values include: 'install.'
  */
  portalSubdomain?: string;
}

export interface OrganizationPatchRequest {
  /**
   * The full (friendly) name of the organization.
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface OrganizationRequest {
  /**
   * The display name of the organization
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface OrganizationUserPatchRequest {
  /**
   * The user's role in the organizatiion. Possible values include: 'admin', 'collaborator',
   * 'member'
  */
  role?: string;
}

export interface AddOrganizationAdminRequest {
  /**
   * The internal unique id (UUID) of the account.
  */
  userId: string;
}

export interface TransferAppAdminRequest {
  /**
   * The internal unique id (UUID) of the user/org.
  */
  newOwnerId: string;
}

export interface PasswordUpdateRequest {
  /**
   * The new password that will be set for the user. Needs to be at least 8 characters long and
   * contain at least one lower- and one uppercase letter.
  */
  newPassword: string;
  /**
   * The old password, if needed.
  */
  oldPassword?: string;
}

export interface PostRepositoryProviderMappingRequest {
  /**
   * Id of user in the external provider service
  */
  externalAccountId: string;
  /**
   * App Center account id to link to this provider and external id
  */
  accountId: string;
}

export interface GetOrCreateRepositoryProviderMappingRequest {
  /**
   * The account name given by the external provider. If provided, create an organization and the
   * mapping. If not, create mapping with user.
  */
  externalAccountName?: string;
}

export interface ResendVerificationRequest {
  /**
   * The email or name of the user to resend verification
  */
  name: string;
}

export interface ResetPasswordUsingTokenRequest {
  /**
   * The new password. Needs to be at least 8 characters long and contain at least one lower- and
   * one uppercase letter.
  */
  newPassword: string;
  /**
   * The reset password token that was sent to the user
  */
  token: string;
}

export interface UserAppPermissionsUpdateRequest {
  /**
   * The permissions the user has for the app
  */
  permissions: string[];
}

export interface UserInvitationPermissionsUpdateRequest {
  /**
   * The permissions the user has for the app in the invitation
  */
  permissions: string[];
}

export interface UserEmailOrgRoleRequest {
  /**
   * The user's email address
  */
  userEmail: string;
  /**
   * The user's role. Possible values include: 'admin', 'collaborator', 'member'
  */
  role?: string;
}

export interface UserEmailRequest {
  /**
   * The user's email address
  */
  userEmail: string;
}

export interface UserNameUpdateRequest {
  /**
   * The new, unique name that is used to identify.
  */
  name?: string;
}

export interface UserUpdateRequest {
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface UserUpdateRequestInternal {
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The new, unique name that is used to identify.
  */
  name?: string;
  /**
   * The date in the future when the user should be checked again for NPS eligibility
  */
  nextNpsSurveyDate?: string;
  /**
   * The email address for this user
  */
  email?: string;
}

export interface UserSettingRequest {
  /**
   * The setting value
  */
  value: string;
}

export interface AccountResponse {
  /**
   * The internal unique id (UUID) of the account.
  */
  id: string;
  /**
   * The display name of the account
  */
  displayName: string;
  /**
   * The slug name of the account
  */
  name: string;
  /**
   * The account's email. For org that value might be empty.
  */
  email?: string;
  /**
   * The creation origin of this account. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The type of this account. Possible values include: 'user', 'org'
  */
  type: string;
}

export interface ApiTokenDeleteResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The hashed value of api token
  */
  tokenHash: string;
}

export interface ApiTokenGetUserResponse {
  /**
   * The token's unique id (UUID)
  */
  tokenId: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  tokenScope: string[];
  /**
   * The user email
  */
  userEmail: string;
  /**
   * The unique id (UUID) of the user
  */
  userId: string;
  /**
   * The creation origin of the user who created this api token. Possible values include:
   * 'appcenter', 'hockeyapp', 'codepush'
  */
  userOrigin: string;
}

export interface ValidatedApiTokenResponseClaimsItem {
  /**
   * Possible values include: 'user_email', 'user_origin', 'app_owner_name', 'app_name',
   * 'app_origin', 'app_os', 'app_platform', 'app_secret'
  */
  claimType?: string;
  claimValue?: string;
}

export interface ValidatedApiTokenResponse {
  /**
   * The token's unique id (UUID)
  */
  tokenId: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  tokenScope: string[];
  /**
   * The ID of the owner of the API Token (user_id or app_id)
  */
  principalId: string;
  /**
   * Indicates the type of the principal (app or user). Possible values include: 'app', 'user'
  */
  principalType: string;
  /**
   * Collection of attributes that describe the principal of the specified API Token
  */
  claims: ValidatedApiTokenResponseClaimsItem[];
}

export interface ApiTokenClaim {
  /**
   * Possible values include: 'user_email', 'user_origin', 'app_owner_name', 'app_name',
   * 'app_origin', 'app_os', 'app_platform', 'app_secret'
  */
  claimType?: string;
  claimValue?: string;
}

export interface ApiTokenResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The creation time
  */
  createdAt: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  scope?: string[];
  /**
   * The encrypted value of a token. This value will only be returned for token of type
   * in_app_update.
  */
  encryptedToken?: string;
  /**
   * The description of the token
  */
  description?: string;
}

export interface AppGroupResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The unique ID (UUID) of the group that the app belongs to
  */
  groupId: string;
  /**
   * The display name of the app
  */
  displayName?: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
}

/**
 * The information about the app's owner
*/
export interface AppInvitationDetailResponseAppOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AppInvitationDetailResponseAppAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface AppInvitationDetailResponseApp {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: AppInvitationDetailResponseAppOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AppInvitationDetailResponseAppAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface AppInvitationDetailResponseInvitedBy {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

/**
 * The information about the app's owner
*/
export interface AppInvitationDetailResponseDistributionGroupOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

/**
 * The organization that owns the distribution group, if it exists
*/
export interface AppInvitationDetailResponseDistributionGroup {
  /**
   * The information about the app's owner
  */
  owner?: AppInvitationDetailResponseDistributionGroupOwner;
}

export interface AppInvitationDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  app: AppInvitationDetailResponseApp;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The invitation type. Possible values include: 'developer', 'tester'
  */
  inviteType: string;
  invitedBy: AppInvitationDetailResponseInvitedBy;
  /**
   * Indicates whether the invited user already exists
  */
  isExistingUser: boolean;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The number of apps in the group
  */
  appCount?: number;
  /**
   * The organization that owns the distribution group, if it exists
  */
  distributionGroup?: AppInvitationDetailResponseDistributionGroup;
}

export interface AppRepoResponse {
  /**
   * The unique id (UUID) of the repository integration
  */
  id: string;
  /**
   * The unique id (UUID) of the app that this repository integration belongs to
  */
  appId: string;
  /**
   * The absolute URL of the repository
  */
  repoUrl: string;
  /**
   * The provider of the repository. Possible values include: 'github', 'bitbucket', 'vsts',
   * 'gitlab'
  */
  repoProvider?: string;
  /**
   * The unique id (UUID) of the user who configured the repository
  */
  userId: string;
  /**
   * Installation id from the provider
  */
  installationId?: string;
  /**
   * Repository id from the provider
  */
  repoId?: string;
  /**
   * User id from the provider
  */
  externalUserId?: string;
  /**
   * The id of the service connection stored in customer credential store
  */
  serviceConnectionId?: string;
}

/**
 * The information about the app's owner
*/
export interface BasicAppResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface BasicAppResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: BasicAppResponseOwner;
}

/**
 * The information about the app's owner
*/
export interface AppResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AppResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface AppResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: AppResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AppResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface TesterAppResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface TesterAppResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: TesterAppResponseOwner;
  /**
   * it indicates if the app is microsoft internal
  */
  microsoftInternal?: boolean;
  /**
   * The permissions associated with the app
  */
  permissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface OrgDistributionGroupAppResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface OrgDistributionGroupAppResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: OrgDistributionGroupAppResponseOwner;
  /**
   * The platform of the app
  */
  platform?: string;
  /**
   * The creation origin of this app
  */
  origin?: string;
}

/**
 * The information about the app's owner
*/
export interface AppResponseInternalOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AppResponseInternalAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface AppResponseInternalRepositoriesItem {
  repoProvider?: string;
  repoUrl?: string;
}

/**
 * the permissions for the specified app user
*/
export interface AppResponseInternalUserPermissions {
  permissions?: string[];
  userId?: string;
}

export interface AppResponseInternal {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: AppResponseInternalOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AppResponseInternalAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
  /**
   * The feature flags that are enabled for this app
  */
  featureFlags?: string[];
  /**
   * The repositories associated with this app
  */
  repositories?: AppResponseInternalRepositoriesItem[];
  /**
   * the permissions for the specified app user
  */
  userPermissions?: AppResponseInternalUserPermissions;
  /**
   * The cutover date of this app
  */
  cutoverFromHockeyappAt?: string;
}

export interface AppUserPermissionResponse {
  /**
   * The unique id (UUID) of the app
  */
  appId: string;
  /**
   * The permissions the user has for the app
  */
  permissions: string[];
  /**
   * The email of the user
  */
  userEmail: string;
  /**
   * The unique id (UUID) of the user
  */
  userId: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'codepush'
  */
  appOrigin: string;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
}

/**
 * The information about the app's owner
*/
export interface AppWithTeamPermissionsResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AppWithTeamPermissionsResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface AppWithTeamPermissionsResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: AppWithTeamPermissionsResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AppWithTeamPermissionsResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
  /**
   * The permissions the team has for the app
  */
  teamPermissions?: string[];
}

export interface OrgUserPermissionResponse {
  /**
   * The unique id (UUID) of the org
  */
  orgId: string;
  /**
   * The user role for the org. Possible values include: 'admin', 'collaborator'
  */
  userRole: string;
}

export interface AzureSubscriptionResponse {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface DistributionGroupResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface DistributionGroupPrivateResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
  /**
   * Type of group. Possible values include: 'Default', 'HockeyAppDefault', 'MicrosoftDogfooding'
  */
  groupType?: string;
}

export interface DistributionGroupDetailsResponseUsersItem {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface DistributionGroupDetailsResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
  /**
   * Whether the distribution group is shared group or not
  */
  isShared: boolean;
  /**
   * The count of apps associated with this distribution group
  */
  totalAppsCount: number;
  /**
   * The count of users in the distribution group
  */
  totalUserCount: number;
  /**
   * The count of non-pending users in the distribution group who will be notified by new releases
  */
  notifiedUserCount: number;
  /**
   * Type of group (Default, HockeyAppDefault or MicrosoftDogfooding). Possible values include:
   * 'Default', 'HockeyAppDefault', 'MicrosoftDogfooding'
  */
  groupType?: string;
  /**
   * The distribution group users
  */
  users: DistributionGroupDetailsResponseUsersItem[];
}

/**
 * The information about the app's owner
*/
export interface OrgDistributionGroupDetailsResponseAppsItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface OrgDistributionGroupDetailsResponseAppsItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface OrgDistributionGroupDetailsResponseAppsItem {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: OrgDistributionGroupDetailsResponseAppsItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: OrgDistributionGroupDetailsResponseAppsItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface OrgDistributionGroupDetailsResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
  /**
   * The count of apps associated with this distribution group
  */
  totalAppsCount: number;
  /**
   * The count of users in the distribution group
  */
  totalUsersCount: number;
  /**
   * The apps associated with the distribution group
  */
  apps: OrgDistributionGroupDetailsResponseAppsItem[];
}

export interface GeneralDistributionGroupDetailsResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
  /**
   * Whether the distribution group is shared group or not
  */
  isShared: boolean;
  /**
   * If distribution group is owned by an app, this is the unique app ID
  */
  ownerAppId?: string;
  /**
   * If distribution group is owned by an org, this is the unique org ID
  */
  ownerOrgId?: string;
}

export interface DistributionGroupUserDeleteResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface CloseAccountOrganizationResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
  /**
   * The number of collaborators from the organization
  */
  collaboratorsCount: number;
}

export interface DistributionGroupUserGetResponse {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface DistributionGroupUserPostResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The message of the result
  */
  message?: string;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface DistributionGroupTesterGetResponse {
  /**
   * The full name of the tester. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The unique name that is used to identify the tester.
  */
  name: string;
  /**
   * The email address of the tester
  */
  email: string;
}

export interface DistributionGroupAADGroupPostResponse {
  /**
   * The internal unique id (UUID) of the AAD group.
  */
  id?: string;
  /**
   * The AAD unique id (UUID) of the AAD group.
  */
  aadGroupId?: string;
  /**
   * The display name of the AAD group
  */
  displayName?: string;
}

export interface DistributionGroupAADGroupResponse {
  /**
   * The internal unique id (UUID) of the AAD group.
  */
  id?: string;
  /**
   * The AAD unique id (UUID) of the AAD group.
  */
  aadGroupId?: string;
  /**
   * The display name of the AAD group
  */
  displayName?: string;
  isAadGroup?: boolean;
  /**
   * The distribution group of the AAD group
  */
  distributionGroupName?: string;
}

export interface DistributionGroupAadGroupsDeleteResponse {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The aad id of the group
  */
  aadGroupId?: string;
}

export interface DistributionGroupWithUsersResponseUsersItem {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface DistributionGroupWithUsersResponseAadGroupsItem {
  /**
   * The internal unique id (UUID) of the AAD group.
  */
  id?: string;
  /**
   * The AAD unique id (UUID) of the AAD group.
  */
  aadGroupId?: string;
  /**
   * The display name of the AAD group
  */
  displayName?: string;
}

export interface DistributionGroupWithUsersResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The count of users in the distribution group
  */
  totalUserCount: number;
  /**
   * The count of aad groups in the distribution group
  */
  totalGroupsCount?: number;
  /**
   * The count of non-pending users in the distribution group who will be notified by new releases
  */
  notifiedUserCount: number;
  /**
   * Whether the distribution group is public
  */
  isPublic?: boolean;
  /**
   * The distribution group users
  */
  users: DistributionGroupWithUsersResponseUsersItem[];
  /**
   * The distribution group aad groups
  */
  aadGroups?: DistributionGroupWithUsersResponseAadGroupsItem[];
}

export interface FeatureFlagsResponse {
  featureFlags: string[];
}

export interface FeatureResponse {
  /**
   * The description of the feature
  */
  description?: string;
  /**
   * The friendly name of the feature
  */
  displayName: string;
  /**
   * The unique name of the feature
  */
  name: string;
  /**
   * The state (unset, enabled, disabled) of the feature
  */
  state: number;
  /**
   * The creation date of the feature
  */
  createdAt?: string;
  /**
   * The date the feature was last updated at
  */
  updatedAt?: string;
}

export interface GlobalFeatureFlagsResponse {
  /**
   * The dictionary of global state values indexed by feature flag names
  */
  value: { [propertyName: string]: string };
}

export interface InternalUserSignupResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The name of the external auth provider
  */
  externalProvider?: string;
  /**
   * The user ID given by the external provider
  */
  externalUserId?: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The current status of the user record after signup. Possible values include: 'Complete',
   * 'NeedsVerification'
  */
  status?: string;
}

export interface InvitationDetailResponseInvitedBy {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface InvitationDetailResponseOrganization {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

/**
 * The information about the app's owner
*/
export interface InvitationDetailResponseAppOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface InvitationDetailResponseAppAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface InvitationDetailResponseApp {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: InvitationDetailResponseAppOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: InvitationDetailResponseAppAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface InvitationDetailResponse {
  /**
   * The id of the invitation
  */
  invitationId: string;
  invitedBy: InvitationDetailResponseInvitedBy;
  organization?: InvitationDetailResponseOrganization;
  app?: InvitationDetailResponseApp;
}

export interface GDPRInvitationDetailResponseOrganization {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

/**
 * The information about the app's owner
*/
export interface GDPRInvitationDetailResponseAppOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface GDPRInvitationDetailResponseAppAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface GDPRInvitationDetailResponseApp {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: GDPRInvitationDetailResponseAppOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: GDPRInvitationDetailResponseAppAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface GDPRInvitationDetailResponse {
  /**
   * The id of the invitation
  */
  invitationId: string;
  organization?: GDPRInvitationDetailResponseOrganization;
  app?: GDPRInvitationDetailResponseApp;
}

export interface OrgNameAvailabilityResponse {
  /**
   * The availability status of the requested org name
  */
  available: boolean;
  /**
   * The generated org name
  */
  name: string;
}

export interface OrganizationInvitationDetailResponseOrganization {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface OrganizationInvitationDetailResponseInvitedBy {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface OrganizationInvitationDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  organization: OrganizationInvitationDetailResponseOrganization;
  /**
   * The email address of the invited user
  */
  email: string;
  invitedBy: OrganizationInvitationDetailResponseInvitedBy;
  /**
   * Indicates whether the invited user already exists
  */
  isExistingUser: boolean;
  /**
   * The role assigned to the invited user
  */
  role?: string;
}

export interface OrganizationInvitationSimpleDetailResponse {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The role assigned to the invited user
  */
  role: string;
}

export interface AdministeredOrgsResponseOrganizations {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface AdministeredOrgsResponse {
  organizations: AdministeredOrgsResponseOrganizations;
}

export interface OrganizationResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface OrganizationResponseInternal {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
  /**
   * The feature flags that are enabled for this organization
  */
  featureFlags?: string[];
}

export interface OrganizationResponseManagement {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
  /**
   * The feature flags that are enabled for this organization
  */
  featureFlags?: string[];
  /**
   * The organization email, if the app was synced from HockeyApp
  */
  email?: string;
}

export interface OrganizationUserResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The date when the user joined the organization
  */
  joinedAt: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role the user has within the organization
  */
  role: string;
}

export interface TeamAppUpdateRequest {
  /**
   * The permissions all members of the team have on the app
  */
  permissions: string[];
}

export interface TeamRequest {
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The name of the team
  */
  name?: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface TeamUpdateRequest {
  /**
   * The new display name of the team
  */
  displayName: string;
}

export interface TeamResponse {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface TeamAppResponse {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
  /**
   * The permissions the team has for the app
  */
  permissions?: string[];
}

export interface StatusResponse {
  status: string;
}

export interface PurgeResponse {
  status: string;
}

export interface ServiceBusStatusResponseSubscriptionsItem {
  /**
   * The name of the subsciption (prefixed with the topic name)
  */
  name: string;
  /**
   * The number of messages in the subscription
  */
  messageCount: number;
}

export interface ServiceBusStatusResponse {
  status: string;
  subscriptions?: ServiceBusStatusResponseSubscriptionsItem[];
}

export interface SubscriptionMetrics {
  /**
   * The name of the subsciption (prefixed with the topic name)
  */
  name: string;
  /**
   * The number of messages in the subscription
  */
  messageCount: number;
}

export interface TeamUserResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role of the user has within the team
  */
  role: any;
}

export interface UserAuthResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The name of the external auth provider
  */
  externalProvider?: string;
  /**
   * The user ID given by the external provider
  */
  externalUserId?: string;
  /**
   * The unique name that is used to identify the user
  */
  name: string;
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface UserLiteProfileResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
}

export interface UserNameAvailabilityResponse {
  /**
   * The availability status of the requested user name
  */
  available: boolean;
  /**
   * The requested user name
  */
  name: string;
}

export interface AppIntegration {
  /**
   * app id
  */
  appId: string;
  /**
   * integration state
  */
  state: string;
  /**
   * provider type
  */
  provider: string;
}

export interface AppIntegrationResponse {
  /**
   * app id
  */
  appId: string;
}

export interface AppMembershipsResponseMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
  sourceId?: string;
}

export interface AppMembershipsResponse {
  /**
   * The app's origin
  */
  appOrigin?: string;
  /**
   * An array of all ways a user has access to the app, based on the app_memberships table.
  */
  memberships?: AppMembershipsResponseMembershipsItem[];
}

export interface AppMembership {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
  sourceId?: string;
}

export interface AppMembershipsValidationResponseExcessAppMembershipsAppUsersMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
  sourceId?: string;
}

export interface AppMembershipsValidationResponseExcessAppMembershipsDistributionGroupMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
  sourceId?: string;
}

export interface AppMembershipsValidationResponseExcessAppMembershipsOrganizationAdminMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  /**
   * Possible values include: 'appcenter', 'hockeyapp', 'codepush', 'testcloud',
   * 'hockeyapp-dogfood'
  */
  origin?: string;
  /**
   * Possible values include: 'user', 'org', 'distribution_group', 'team', 'release'
  */
  sourceType?: string;
  sourceId?: string;
}

export interface AppMembershipsValidationResponseExcessAppMemberships {
  appUsersMemberships?:
  AppMembershipsValidationResponseExcessAppMembershipsAppUsersMembershipsItem[];
  distributionGroupMemberships?:
  AppMembershipsValidationResponseExcessAppMembershipsDistributionGroupMembershipsItem[];
  organizationAdminMemberships?:
  AppMembershipsValidationResponseExcessAppMembershipsOrganizationAdminMembershipsItem[];
}

export interface AppMembershipsValidationResponseAppUsersWithMissingMembershipsItem {
  appId?: string;
  userId?: string;
  permissions?: string[];
  origin?: string;
}

export interface AppMembershipsValidationResponseDistributionGroupUsersWithMissingMembershipsItem {
  distributionGroupId?: string;
  userId?: string;
  origin?: string;
}

export interface AppMembershipsValidationResponseOrganizationAdminsWithMissingMembershipsItem {
  organizationId?: string;
  userId?: string;
  role?: string;
  origin?: string;
}

export interface AppMembershipsValidationResponse {
  excessAppMemberships?: AppMembershipsValidationResponseExcessAppMemberships;
  appUsersWithMissingMemberships?:
  AppMembershipsValidationResponseAppUsersWithMissingMembershipsItem[];
  distributionGroupUsersWithMissingMemberships?:
  AppMembershipsValidationResponseDistributionGroupUsersWithMissingMembershipsItem[];
  organizationAdminsWithMissingMemberships?:
  AppMembershipsValidationResponseOrganizationAdminsWithMissingMembershipsItem[];
}

export interface UserProfileResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface UserProfileAdminResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
  /**
   * The user's role in the organization. Possible values include: 'admin', 'collaborator',
   * 'member'
  */
  role?: string;
}

/**
 * The user's settings
*/
export interface UserProfileResponseInternalSettings {
  /**
   * The marketing opt-in setting
  */
  marketingOptIn?: string;
}

export interface UserProfileResponseInternal {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
  /**
   * The feature flags that are enabled for this app
  */
  featureFlags?: string[];
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole?: string;
  /**
   * The user's settings
  */
  settings?: UserProfileResponseInternalSettings;
}

/**
 * The user's settings
*/
export interface UserProfileResponseManagementSettings {
  /**
   * The marketing opt-in setting
  */
  marketingOptIn?: string;
}

export interface UserProfileResponseManagementIdentityProvidersItem {
  /**
   * The name of the identity provider type. Possible values include: 'github', 'aad', 'facebook',
   * 'google'
  */
  providerName?: string;
  /**
   * Whether the identity provider originated in HockeyApp or App Center
  */
  origin?: string;
}

export interface UserProfileResponseManagement {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
  /**
   * The feature flags that are enabled for this app
  */
  featureFlags?: string[];
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole?: string;
  /**
   * The user's settings
  */
  settings?: UserProfileResponseManagementSettings;
  /**
   * The date when the app was last updated
  */
  updatedAt?: string;
  /**
   * A boolean flag that indicates if the user is already verified
  */
  verified?: boolean;
  /**
   * The identity providers associated with the user's account
  */
  identityProviders?: UserProfileResponseManagementIdentityProvidersItem[];
}

/**
 * A user's setting
*/
export interface UserSettingResponse {
  /**
   * The marketing opt-in setting
  */
  marketingOptIn?: string;
}

/**
 * The information about the app's owner
*/
export interface Owner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AADGroup {
  /**
   * The id of the aad group
  */
  aadGroupId: string;
  /**
   * The id of the aad tenant
  */
  tenantId: string;
  /**
   * The display name of the aad group
  */
  displayName: string;
}

/**
 * an AAD user's id and tenant id
*/
export interface AADUser {
  /**
   * the aad user's id
  */
  objectId: string;
  /**
   * the aad user's tenant id
  */
  tenantId: string;
}

/**
 * an MSA user's hex CID
*/
export interface MSAUser {
  /**
   * the user's CID
  */
  hexcid: string;
}

export interface LinkAADtoUserRequest {
  /**
   * An array of AAD tenant data needed to link the user to the tenants
  */
  aadTenantIds: string[];
  /**
   * The role of the user to be added. Possible values include: 'admin', 'collaborator', 'member'
  */
  role?: string;
}

export interface AddUserAsRoleRequest {
  /**
   * The role of the user to be added. Possible values include: 'admin', 'collaborator', 'member'
  */
  role?: string;
}

export interface OrganizationAadGroupPatchRequest {
  /**
   * The user's role in the organizatiion. Possible values include: 'admin', 'collaborator',
   * 'member'
  */
  role?: string;
}

export interface AddAADGroupResponse {
  /**
   * The unique ID (UUID) of the aad group
  */
  id?: string;
}

/**
 * Shared connection patch request
*/
export interface SharedConnectionPatchRequest {
  /**
   * Display name of the shared connection
  */
  displayName?: string;
  /**
   * Represents the data for connecting to service
  */
  data: any;
}

/**
 * SharedConnectionRequest
*/
export interface SharedConnectionRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * SharedConnectionResponse
*/
export interface SharedConnectionResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * PrivateSharedConnectionResponse
*/
export interface PrivateSharedConnectionResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * Polymorphic Discriminator
  */
  credentialType: string;
}

/**
 * apple secret details
*/
export interface AppleCredentialsMultifactorSecretRequestData {
  /**
   * username to connect to apple store.
  */
  username: string;
  /**
   * password to connect to apple store.
  */
  password: string;
  /**
   * The 6 digit Apple OTP for Multifactor accounts
  */
  authCode: string;
  /**
   * The app specific password required for app publishing for 2FA accounts
  */
  appSpecificPassword?: string;
}

/**
 * Apple connection secrets
*/
export interface AppleCredentialsMultifactorSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * apple secret details
  */
  data: AppleCredentialsMultifactorSecretRequestData;
}

/**
 * apple secret details
*/
export interface AppleCredentialsSecretRequestData {
  /**
   * username to connect to apple store.
  */
  username?: string;
  /**
   * 6 digit auth code
  */
  authCode?: string;
  /**
   * password to connect to apple store.
  */
  password?: string;
}

/**
 * Apple connection secrets
*/
export interface AppleCredentialsSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * apple secret details
  */
  data: AppleCredentialsSecretRequestData;
}

/**
 * apple secret details
*/
export interface AppleCertificateSecretRequestData {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
}

/**
 * Apple certificate secrets
*/
export interface AppleCertificateSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * apple secret details
  */
  data: AppleCertificateSecretRequestData;
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
}

/**
 * apple secret details
*/
export interface PrivateAppleCredentialsSecretResponseData {
  /**
   * username to connect to apple store.
  */
  username?: string;
  /**
   * 6 digit auth code
  */
  authCode?: string;
  /**
   * password to connect to apple store.
  */
  password?: string;
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleCredentialsSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * apple secret details
  */
  data: PrivateAppleCredentialsSecretResponseData;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * apple secret details
*/
export interface PrivateAppleCertificateSecretResponseData {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * private Apple connection secrets response
*/
export interface PrivateAppleCertificateSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * apple secret details
  */
  data: PrivateAppleCertificateSecretResponseData;
}

/**
 * Apple secret details
*/
export interface AppleSecretDetails {
  /**
   * username to connect to apple store.
  */
  username?: string;
  /**
   * 6 digit auth code
  */
  authCode?: string;
  /**
   * password to connect to apple store.
  */
  password?: string;
}

/**
 * Apple secret details
*/
export interface AppleMultifactorSecretDetails {
  /**
   * username to connect to apple store.
  */
  username: string;
  /**
   * password to connect to apple store.
  */
  password: string;
  /**
   * The 6 digit Apple OTP for Multifactor accounts
  */
  authCode: string;
  /**
   * The app specific password required for app publishing for 2FA accounts
  */
  appSpecificPassword?: string;
}

/**
 * Apple secret details
*/
export interface AppleSecretDetailsResponse {
  /**
   * username to connect to apple store
  */
  username: string;
}

/**
 * apple secret details
*/
export interface AppleConnectionSecretResponseData {
  /**
   * username to connect to apple store
  */
  username: string;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * apple secret details
  */
  data: AppleConnectionSecretResponseData;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Apple connection secrets
*/
export interface AppleConnectionNonSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  credentialType: string;
}

/**
 * Apple credentials non-secret data
*/
export interface AppleCredentialNonSecretDetailsResponseData {
  /**
   * username to connect to apple store
  */
  username: string;
}

/**
 * Apple credentials non-secret details
*/
export interface AppleCredentialNonSecretDetailsResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Apple credentials non-secret data
  */
  data: AppleCredentialNonSecretDetailsResponseData;
}

/**
 * apple certificate non-secret details
*/
export interface AppleCertificateNonSecretDetailsResponseData {
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * Apple certificate non-secret details
*/
export interface AppleCertificateNonSecretDetailsResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * apple certificate non-secret details
  */
  data: AppleCertificateNonSecretDetailsResponseData;
}

/**
 * apple certificate secret details.
*/
export interface AppleCertificateSecretDetailsResponseData {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * Apple connection secrets
*/
export interface AppleCertificateSecretDetailsResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * apple certificate secret details.
  */
  data: AppleCertificateSecretDetailsResponseData;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Apple Certificate Secret Details
*/
export interface AppleCertificateSecretDetails {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * Apple Certificate Details
*/
export interface AppleCertificateDetails {
  /**
   * The certificate contents in base 64 encoded string
  */
  base64Certificate: string;
  /**
   * The password for the certificate
  */
  password: string;
}

/**
 * Apple Certificate Secret Details
*/
export interface AppleCertificateNonSecretDetails {
  /**
   * The display name (CN) of the certificate
  */
  displayName: string;
  /**
   * The date-time from which the certificate is valid
  */
  certificateValidityStartDate: string;
  /**
   * The date-time till which the certificate is valid
  */
  certificateValidityEndDate: string;
}

/**
 * jira secret details
*/
export interface JiraConnectionSecretRequestData {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
  /**
   * password to connect to jira instance
  */
  password: string;
}

/**
 * Jira connection secrets
*/
export interface JiraConnectionSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * jira secret details
  */
  data: JiraConnectionSecretRequestData;
}

/**
 * jira secret details
*/
export interface JiraConnectionSecretResponseData {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
}

/**
 * Jira connection secrets
*/
export interface JiraConnectionSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * jira secret details
  */
  data: JiraConnectionSecretResponseData;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * jira secret details
*/
export interface PrivateJiraConnectionSecretResponseData {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
  /**
   * password to connect to jira instance
  */
  password: string;
}

/**
 * private Jira connection secrets response
*/
export interface PrivateJiraConnectionSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * jira secret details
  */
  data: PrivateJiraConnectionSecretResponseData;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Jira secret details
*/
export interface JiraSecretDetails {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
  /**
   * password to connect to jira instance
  */
  password: string;
}

/**
 * Jira secret details
*/
export interface JiraSecretDetailsResponse {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
}

/**
 * Google Play connection secrets this should be the JSON file data which is provided by google
 * play
*/
export interface GooglePlayConnectionSecretRequest {
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira|applecertificate.
   * Possible values include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * credential type of the shared connection. Values can be credentials|certificate. Possible
   * values include: 'credentials', 'certificate'
  */
  credentialType?: string;
  /**
   * google secret details
  */
  data: any;
}

/**
 * Google Play connection secrets
*/
export interface GooglePlayConnectionSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * google play secret details
  */
  data: any;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * private google connection secrets response
*/
export interface PrivateGooglePlayConnectionSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * google secret details
  */
  data: any;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

/**
 * Google Play non-secret data
*/
export interface GooglePlayConnectionNonSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  credentialType: string;
}

/**
 * Google Play credentials non-secret details
*/
export interface GooglePlayCredentialNonSecretDetailsResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Google Play credentials non-secret details
  */
  data: any;
}

/**
 * Jira non-secret data
*/
export interface JiraConnectionNonSecretResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  credentialType: string;
}

/**
 * Jira credentials non-secret details
*/
export interface JiraCredentialNonSecretDetailsResponseData {
  /**
   * baseUrl to connect to jira instance
  */
  baseUrl: string;
  /**
   * username to connect to jira instance
  */
  username: string;
}

/**
 * Jira credentials non-secret details
*/
export interface JiraCredentialNonSecretDetailsResponse {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * service type of shared connection can be apple|gitlab|googleplay|jira. Possible values
   * include: 'apple', 'jira', 'googleplay', 'gitlab'
  */
  serviceType: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Jira credentials non-secret details
  */
  data: JiraCredentialNonSecretDetailsResponseData;
}

export interface ApiTokenResponsev2 {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The creation time
  */
  createdAt: string;
  /**
   * The token's scope. A list of allowed roles.
  */
  scope?: string[];
  /**
   * The encrypted value of a token. This value will only be returned for token of type
   * in_app_update.
  */
  encryptedToken?: string;
  /**
   * The description of the token
  */
  description?: string;
}

export interface UserDataResponse {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The display name of the user
  */
  displayName?: string;
  /**
   * The name of the user
  */
  name?: string;
  /**
   * The url at which the user's avatar can be reached
  */
  avatarUrl?: string;
}

export interface UserProfileResponsev2 {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The created date of the user
  */
  createdAt?: string;
  /**
   * The date in the future when the user should be checked again for NPS eligibility
  */
  nextNpsSurveyDate?: string;
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
  /**
   * The feature flags that are enabled for this user
  */
  featureFlags?: string[];
  /**
   * The new admin_role. Possible values include: 'superAdmin', 'admin', 'devOps',
   * 'customerSupport', 'notAdmin'
  */
  adminRole?: string;
  /**
   * The user's settings
  */
  settings?: any;
  /**
   * The session hash of the user
  */
  sessionHash?: string;
}

export interface MbaasSurveyDataResponse {
  /**
   * The next mbaas survey date for the user
  */
  nextSurveyDate?: string;
}

export interface ErrorDetailsv2 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized'
  */
  code: string;
  message: string;
}

export interface ErrorResponsev2Error {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized'
  */
  code: string;
  message: string;
}

export interface ErrorResponsev2 {
  error: ErrorResponsev2Error;
}

export interface OptimizelyUserMetaDataResponse {
  userId?: string;
  metadata?: any;
}

export interface OptimizelyUserMetaDataRequest {
  metadata?: any;
}

export interface FileAsset {
  id?: string;
  location?: string;
  token?: string;
  uploadDomain?: string;
  uploadWindowLocation?: string;
  urlEncodedToken?: string;
}

/**
 * The source repository
*/
export interface SourceRepository {
  /**
   * The repository name
  */
  name?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
}

/**
 * The source repository
*/
export interface SourceRepositoriesItem {
  /**
   * The repository name
  */
  name?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
}

/**
 * The GitHub Installation
*/
export interface GitHubInstallationLiteAccount {
  /**
   * GitHub Account Id
  */
  id?: string;
  /**
   * GitHub Account Login Name
  */
  login?: string;
  /**
   * GitHub Account Type
  */
  type?: string;
  /**
   * GitHub Account Url
  */
  url?: string;
}

/**
 * The GitHub Installation
*/
export interface GitHubInstallationLite {
  /**
   * GitHub Installation Id
  */
  id?: number;
  /**
   * The GitHub Installation
  */
  account?: GitHubInstallationLiteAccount;
  /**
   * GitHub Installation App Id
  */
  appId?: number;
}

/**
 * The GitHub Installation
*/
export interface GitHubAccountLite {
  /**
   * GitHub Account Id
  */
  id?: string;
  /**
   * GitHub Account Login Name
  */
  login?: string;
  /**
   * GitHub Account Type
  */
  type?: string;
  /**
   * GitHub Account Url
  */
  url?: string;
}

/**
 * The repository which is accessiable by GitHub App Installation
*/
export interface GitHubInstallationRepository {
  /**
   * The repository name
  */
  name?: string;
  /**
   * The discription of repository
  */
  description?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
  /**
   * The default branch for the repo
  */
  defaultBranch?: string;
  /**
   * The language in the repository
  */
  language?: string;
  /**
   * The repository updated time
  */
  updatedAt?: string;
  /**
   * Whether the repository is a fork
  */
  fork?: boolean;
}

/**
 * The repository which is accessiable by GitHub App Installation
*/
export interface GitHubInstallationRepositoriesItem {
  /**
   * The repository name
  */
  name?: string;
  /**
   * The discription of repository
  */
  description?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
  /**
   * The default branch for the repo
  */
  defaultBranch?: string;
  /**
   * The language in the repository
  */
  language?: string;
  /**
   * The repository updated time
  */
  updatedAt?: string;
  /**
   * Whether the repository is a fork
  */
  fork?: boolean;
}

/**
 * App Center account details from GitHub billing
*/
export interface GitHubBillingAccount {
  /**
   * The unique id (UUID) of the account
  */
  id: string;
  /**
   * The account's display name
  */
  displayName: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

/**
 * The lite version of GitHub repository
*/
export interface GitHubPullRequestLiteHeadRepo {
  /**
   * The repository id
  */
  id?: number;
}

/**
 * The lite version of GitHub branch
*/
export interface GitHubPullRequestLiteHead {
  /**
   * The repository name
  */
  ref?: string;
  /**
   * The discription of repository
  */
  sha?: string;
  /**
   * The lite version of GitHub repository
  */
  repo?: GitHubPullRequestLiteHeadRepo;
}

/**
 * The lite version of GitHub repository
*/
export interface GitHubPullRequestLiteBaseRepo {
  /**
   * The repository id
  */
  id?: number;
}

/**
 * The lite version of GitHub branch
*/
export interface GitHubPullRequestLiteBase {
  /**
   * The repository name
  */
  ref?: string;
  /**
   * The discription of repository
  */
  sha?: string;
  /**
   * The lite version of GitHub repository
  */
  repo?: GitHubPullRequestLiteBaseRepo;
}

/**
 * The lite version of GitHub pull request
*/
export interface GitHubPullRequestLite {
  /**
   * The lite version of GitHub branch
  */
  head?: GitHubPullRequestLiteHead;
  /**
   * The lite version of GitHub branch
  */
  base?: GitHubPullRequestLiteBase;
}

/**
 * The lite version of GitHub repository
*/
export interface GitHubBranchLiteRepo {
  /**
   * The repository id
  */
  id?: number;
}

/**
 * The lite version of GitHub branch
*/
export interface GitHubBranchLite {
  /**
   * The repository name
  */
  ref?: string;
  /**
   * The discription of repository
  */
  sha?: string;
  /**
   * The lite version of GitHub repository
  */
  repo?: GitHubBranchLiteRepo;
}

/**
 * The lite version of GitHub repository
*/
export interface GitHubRepositoryLite {
  /**
   * The repository id
  */
  id?: number;
}

/**
 * App extension information
*/
export interface IosAppExtensionInfo {
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

/**
 * Provisioning profile fetch and store information
*/
export interface ProvisioningProfileFile {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * VSTS user profile
*/
export interface VSTSProfile {
  /**
   * Profile id
  */
  id?: string;
  /**
   * Profile display name
  */
  displayName?: string;
  /**
   * Profile alias
  */
  publicAlias?: string;
  /**
   * Profile email
  */
  emailAddress?: string;
}

/**
 * VSTS project
*/
export interface VSTSProject {
  /**
   * Project id
  */
  id?: string;
  /**
   * Project name
  */
  name?: string;
  /**
   * Project description
  */
  description?: string;
  /**
   * Project URL
  */
  url?: string;
  /**
   * Project state
  */
  state?: string;
  /**
   * Project visibility
  */
  visibility?: string;
}

/**
 * VSTS user profile
*/
export interface VSTSAccountUser {
  /**
   * Profile id
  */
  id?: string;
  /**
   * Profile display name
  */
  displayName?: string;
  /**
   * Profile alias
  */
  publicAlias?: string;
  /**
   * Profile email
  */
  emailAddress?: string;
}

/**
 * VSTS project
*/
export interface VSTSAccountProjectsItem {
  /**
   * Project id
  */
  id?: string;
  /**
   * Project name
  */
  name?: string;
  /**
   * Project description
  */
  description?: string;
  /**
   * Project URL
  */
  url?: string;
  /**
   * Project state
  */
  state?: string;
  /**
   * Project visibility
  */
  visibility?: string;
}

/**
 * VSTS account with projects list and user info
*/
export interface VSTSAccount {
  /**
   * Account id
  */
  accountId?: string;
  /**
   * Account uri
  */
  accountUri?: string;
  /**
   * Account name
  */
  accountName?: string;
  /**
   * Account type
  */
  accountType?: string;
  /**
   * Account status
  */
  accountStatus?: string;
  /**
   * VSTS user profile
  */
  user?: VSTSAccountUser;
  /**
   * Account projects
  */
  projects?: VSTSAccountProjectsItem[];
}

/**
 * VSTS user profile
*/
export interface VSTSAccountsItemUser {
  /**
   * Profile id
  */
  id?: string;
  /**
   * Profile display name
  */
  displayName?: string;
  /**
   * Profile alias
  */
  publicAlias?: string;
  /**
   * Profile email
  */
  emailAddress?: string;
}

/**
 * VSTS project
*/
export interface VSTSAccountsItemProjectsItem {
  /**
   * Project id
  */
  id?: string;
  /**
   * Project name
  */
  name?: string;
  /**
   * Project description
  */
  description?: string;
  /**
   * Project URL
  */
  url?: string;
  /**
   * Project state
  */
  state?: string;
  /**
   * Project visibility
  */
  visibility?: string;
}

/**
 * VSTS account with projects list and user info
*/
export interface VSTSAccountsItem {
  /**
   * Account id
  */
  accountId?: string;
  /**
   * Account uri
  */
  accountUri?: string;
  /**
   * Account name
  */
  accountName?: string;
  /**
   * Account type
  */
  accountType?: string;
  /**
   * Account status
  */
  accountStatus?: string;
  /**
   * VSTS user profile
  */
  user?: VSTSAccountsItemUser;
  /**
   * Account projects
  */
  projects?: VSTSAccountsItemProjectsItem[];
}

/**
 * A download reference
*/
export interface DownloadContainer {
  /**
   * Download URI
  */
  uri: string;
}

/**
 * A websocket reference
*/
export interface WebSocketContainer {
  /**
   * WebSocket URL
  */
  url: string;
}

export interface XcodeArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface XcodeSchemeArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface XcodeScheme {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?: XcodeSchemeArchiveProject;
}

export interface XcodeToolsetXcodeSchemeContainersItemSharedSchemesItemArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface XcodeToolsetXcodeSchemeContainersItemSharedSchemesItem {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?: XcodeToolsetXcodeSchemeContainersItemSharedSchemesItemArchiveProject;
}

/**
 * App extension information
*/
export interface XcodeToolsetXcodeSchemeContainersItemAppExtensionTargetsItem {
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

export interface XcodeToolsetXcodeSchemeContainersItem {
  /**
   * Path to project
  */
  path: string;
  /**
   * Project schemes
  */
  sharedSchemes: XcodeToolsetXcodeSchemeContainersItemSharedSchemesItem[];
  /**
   * Path to CocoaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  /**
   * repo object Id of the pbxproject
  */
  xcodeProjectSha?: string;
  /**
   * Related projects paths for xcworkspace
  */
  workspaceProjectPaths?: string;
  /**
   * Information regarding project app extensions, if present
  */
  appExtensionTargets?: XcodeToolsetXcodeSchemeContainersItemAppExtensionTargetsItem[];
}

export interface XcodeToolset {
  /**
   * The Xcode scheme containers
  */
  xcodeSchemeContainers: XcodeToolsetXcodeSchemeContainersItem[];
}

export interface XcodeSchemeContainerSharedSchemesItemArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface XcodeSchemeContainerSharedSchemesItem {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?: XcodeSchemeContainerSharedSchemesItemArchiveProject;
}

/**
 * App extension information
*/
export interface XcodeSchemeContainerAppExtensionTargetsItem {
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

export interface XcodeSchemeContainer {
  /**
   * Path to project
  */
  path: string;
  /**
   * Project schemes
  */
  sharedSchemes: XcodeSchemeContainerSharedSchemesItem[];
  /**
   * Path to CocoaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  /**
   * repo object Id of the pbxproject
  */
  xcodeProjectSha?: string;
  /**
   * Related projects paths for xcworkspace
  */
  workspaceProjectPaths?: string;
  /**
   * Information regarding project app extensions, if present
  */
  appExtensionTargets?: XcodeSchemeContainerAppExtensionTargetsItem[];
}

export interface XamarinToolsetXamarinSolutionsItem {
  /**
   * Path to solution
  */
  path: string;
  /**
   * Solution configurations
  */
  configurations: string[];
  /**
   * Solution default configuration
  */
  defaultConfiguration?: string;
}

export interface XamarinToolset {
  /**
   * Xamarin solutions for the toolset
  */
  xamarinSolutions: XamarinToolsetXamarinSolutionsItem[];
}

export interface XamarinSolution {
  /**
   * Path to solution
  */
  path: string;
  /**
   * Solution configurations
  */
  configurations: string[];
  /**
   * Solution default configuration
  */
  defaultConfiguration?: string;
}

/**
 * Android signing config. Null if not specified
*/
export interface AndroidProjectAndroidModulesItemBuildConfigurationsItemSigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface AndroidProjectAndroidModulesItemBuildConfigurationsItem {
  /**
   * Name of build configuration (the same as a build type name)
  */
  name: string;
  /**
   * Android signing config. Null if not specified
  */
  signingConfig?: AndroidProjectAndroidModulesItemBuildConfigurationsItemSigningConfig;
}

export interface AndroidProjectAndroidModulesItem {
  /**
   * Name of the Android module
  */
  name: string;
  /**
   * Module contains bundle settings
  */
  hasBundle?: boolean;
  /**
   * The product flavors of the Android module
  */
  productFlavors?: string[];
  /**
   * The detected build variants of the Android module (matrix of product flavor + build type
   * (debug|release))
  */
  buildVariants?: string[];
  /**
   * The detected build types of the Android module
  */
  buildTypes?: string[];
  /**
   * The detected build configurations of the Android module
  */
  buildConfigurations?: AndroidProjectAndroidModulesItemBuildConfigurationsItem[];
  /**
   * Whether the module is at the root level of the project
  */
  isRoot?: boolean;
}

export interface AndroidProject {
  /**
   * Android Gradle modules
  */
  androidModules: AndroidProjectAndroidModulesItem[];
  /**
   * The path of the Gradle wrapper
  */
  gradleWrapperPath?: string;
}

/**
 * Android signing config. Null if not specified
*/
export interface AndroidModuleBuildConfigurationsItemSigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface AndroidModuleBuildConfigurationsItem {
  /**
   * Name of build configuration (the same as a build type name)
  */
  name: string;
  /**
   * Android signing config. Null if not specified
  */
  signingConfig?: AndroidModuleBuildConfigurationsItemSigningConfig;
}

export interface AndroidModule {
  /**
   * Name of the Android module
  */
  name: string;
  /**
   * Module contains bundle settings
  */
  hasBundle?: boolean;
  /**
   * The product flavors of the Android module
  */
  productFlavors?: string[];
  /**
   * The detected build variants of the Android module (matrix of product flavor + build type
   * (debug|release))
  */
  buildVariants?: string[];
  /**
   * The detected build types of the Android module
  */
  buildTypes?: string[];
  /**
   * The detected build configurations of the Android module
  */
  buildConfigurations?: AndroidModuleBuildConfigurationsItem[];
  /**
   * Whether the module is at the root level of the project
  */
  isRoot?: boolean;
}

/**
 * Android signing config. Null if not specified
*/
export interface BuildConfigurationSigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface BuildConfiguration {
  /**
   * Name of build configuration (the same as a build type name)
  */
  name: string;
  /**
   * Android signing config. Null if not specified
  */
  signingConfig?: BuildConfigurationSigningConfig;
}

export interface SigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface JavaScriptToolsetJavascriptSolutionsItem {
  /**
   * The path to the detected package.json
  */
  packageJsonPath: string;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

export interface JavaScriptToolset {
  /**
   * Paths for detected package.json files
  */
  packageJsonPaths: string[];
  /**
   * The React Native solutions detected
  */
  javascriptSolutions?: JavaScriptToolsetJavascriptSolutionsItem[];
}

export interface JavaScriptSolution {
  /**
   * The path to the detected package.json
  */
  packageJsonPath: string;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

export interface UWPToolsetUwpSolutionsItem {
  /**
   * The path to the UWP solution
  */
  path: string;
  /**
   * The possible configurations detected for the UWP solution
  */
  configurations: string[];
}

export interface UWPToolset {
  /**
   * The UWP solutions detected
  */
  uwpSolutions: UWPToolsetUwpSolutionsItem[];
}

export interface UWPSolution {
  /**
   * The path to the UWP solution
  */
  path: string;
  /**
   * The possible configurations detected for the UWP solution
  */
  configurations: string[];
}

export interface TestCloudToolsetProjectsItemFrameworkProperties {
  configurations?: string[];
}

export interface TestCloudToolsetProjectsItem {
  /**
   * The path to the TestCloud project
  */
  path: string;
  /**
   * Possible values include: 'Appium', 'Calabash', 'Espresso', 'UITest', 'Generated'
  */
  frameworkType: string;
  frameworkProperties?: TestCloudToolsetProjectsItemFrameworkProperties;
}

export interface TestCloudToolset {
  /**
   * The TestCloud projects detected
  */
  projects: TestCloudToolsetProjectsItem[];
}

export interface TestCloudProjectFrameworkProperties {
  configurations?: string[];
}

export interface TestCloudProject {
  /**
   * The path to the TestCloud project
  */
  path: string;
  /**
   * Possible values include: 'Appium', 'Calabash', 'Espresso', 'UITest', 'Generated'
  */
  frameworkType: string;
  frameworkProperties?: TestCloudProjectFrameworkProperties;
}

export interface TestCloudProjectFrameworkPropertiesModel {
  configurations?: string[];
}

export interface ToolsetProjectsXcodeXcodeSchemeContainersItemSharedSchemesItemArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface ToolsetProjectsXcodeXcodeSchemeContainersItemSharedSchemesItem {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?: ToolsetProjectsXcodeXcodeSchemeContainersItemSharedSchemesItemArchiveProject;
}

/**
 * App extension information
*/
export interface ToolsetProjectsXcodeXcodeSchemeContainersItemAppExtensionTargetsItem {
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

export interface ToolsetProjectsXcodeXcodeSchemeContainersItem {
  /**
   * Path to project
  */
  path: string;
  /**
   * Project schemes
  */
  sharedSchemes: ToolsetProjectsXcodeXcodeSchemeContainersItemSharedSchemesItem[];
  /**
   * Path to CocoaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  /**
   * repo object Id of the pbxproject
  */
  xcodeProjectSha?: string;
  /**
   * Related projects paths for xcworkspace
  */
  workspaceProjectPaths?: string;
  /**
   * Information regarding project app extensions, if present
  */
  appExtensionTargets?: ToolsetProjectsXcodeXcodeSchemeContainersItemAppExtensionTargetsItem[];
}

export interface ToolsetProjectsXcode {
  /**
   * The Xcode scheme containers
  */
  xcodeSchemeContainers: ToolsetProjectsXcodeXcodeSchemeContainersItem[];
}

export interface ToolsetProjectsJavascriptJavascriptSolutionsItem {
  /**
   * The path to the detected package.json
  */
  packageJsonPath: string;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

export interface ToolsetProjectsJavascript {
  /**
   * Paths for detected package.json files
  */
  packageJsonPaths: string[];
  /**
   * The React Native solutions detected
  */
  javascriptSolutions?: ToolsetProjectsJavascriptJavascriptSolutionsItem[];
}

export interface ToolsetProjectsXamarinXamarinSolutionsItem {
  /**
   * Path to solution
  */
  path: string;
  /**
   * Solution configurations
  */
  configurations: string[];
  /**
   * Solution default configuration
  */
  defaultConfiguration?: string;
}

export interface ToolsetProjectsXamarin {
  /**
   * Xamarin solutions for the toolset
  */
  xamarinSolutions: ToolsetProjectsXamarinXamarinSolutionsItem[];
}

/**
 * Android signing config. Null if not specified
*/
export interface ToolsetProjectsAndroidAndroidModulesItemBuildConfigurationsItemSigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface ToolsetProjectsAndroidAndroidModulesItemBuildConfigurationsItem {
  /**
   * Name of build configuration (the same as a build type name)
  */
  name: string;
  /**
   * Android signing config. Null if not specified
  */
  signingConfig?: ToolsetProjectsAndroidAndroidModulesItemBuildConfigurationsItemSigningConfig;
}

export interface ToolsetProjectsAndroidAndroidModulesItem {
  /**
   * Name of the Android module
  */
  name: string;
  /**
   * Module contains bundle settings
  */
  hasBundle?: boolean;
  /**
   * The product flavors of the Android module
  */
  productFlavors?: string[];
  /**
   * The detected build variants of the Android module (matrix of product flavor + build type
   * (debug|release))
  */
  buildVariants?: string[];
  /**
   * The detected build types of the Android module
  */
  buildTypes?: string[];
  /**
   * The detected build configurations of the Android module
  */
  buildConfigurations?: ToolsetProjectsAndroidAndroidModulesItemBuildConfigurationsItem[];
  /**
   * Whether the module is at the root level of the project
  */
  isRoot?: boolean;
}

export interface ToolsetProjectsAndroid {
  /**
   * Android Gradle modules
  */
  androidModules: ToolsetProjectsAndroidAndroidModulesItem[];
  /**
   * The path of the Gradle wrapper
  */
  gradleWrapperPath?: string;
}

/**
 * Abstract platform project
*/
export interface ToolsetProjectsBuildscriptsValue {
  name?: string;
  path?: string;
}

export interface ToolsetProjectsUwpUwpSolutionsItem {
  /**
   * The path to the UWP solution
  */
  path: string;
  /**
   * The possible configurations detected for the UWP solution
  */
  configurations: string[];
}

export interface ToolsetProjectsUwp {
  /**
   * The UWP solutions detected
  */
  uwpSolutions: ToolsetProjectsUwpUwpSolutionsItem[];
}

export interface ToolsetProjectsTestcloudProjectsItemFrameworkProperties {
  configurations?: string[];
}

export interface ToolsetProjectsTestcloudProjectsItem {
  /**
   * The path to the TestCloud project
  */
  path: string;
  /**
   * Possible values include: 'Appium', 'Calabash', 'Espresso', 'UITest', 'Generated'
  */
  frameworkType: string;
  frameworkProperties?: ToolsetProjectsTestcloudProjectsItemFrameworkProperties;
}

export interface ToolsetProjectsTestcloud {
  /**
   * The TestCloud projects detected
  */
  projects: ToolsetProjectsTestcloudProjectsItem[];
}

/**
 * A collection of projects for each type of toolset
*/
export interface ToolsetProjects {
  /**
   * The commit hash of the analyzed commit
  */
  commit?: string;
  xcode?: ToolsetProjectsXcode;
  javascript?: ToolsetProjectsJavascript;
  xamarin?: ToolsetProjectsXamarin;
  android?: ToolsetProjectsAndroid;
  /**
   * A collection of detected pre/post buildscripts for current platform toolset
  */
  buildscripts?: { [propertyName: string]: ToolsetProjectsBuildscriptsValue };
  uwp?: ToolsetProjectsUwp;
  testcloud?: ToolsetProjectsTestcloud;
}

/**
 * Abstract platform project
*/
export interface BuildScriptsValue {
  name?: string;
  path?: string;
}

/**
 * Abstract platform project
*/
export interface ToolsetProject {
  name?: string;
  path?: string;
}

export interface BranchStatusCollectionItemValueBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface BranchStatusCollectionItemValueBranch {
  /**
   * The branch name
  */
  name: string;
  commit: BranchStatusCollectionItemValueBranchCommit;
}

/**
 * The branch build core properties
*/
export interface BranchStatusCollectionItemValue {
  branch?: BranchStatusCollectionItemValueBranch;
  enabled?: boolean;
}

export interface BranchStatusCollectionItemLastBuild {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

/**
 * The branch build status
*/
export interface BranchStatusCollectionItem {
  configured: boolean;
  lastBuild?: BranchStatusCollectionItemLastBuild;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "BranchStatusCollectionItemValue". Due to valid TS constraints we have modeled this as a union
   * of `BranchStatusCollectionItemValue | any`.
  */
  [additionalPropertyName: string]: BranchStatusCollectionItemValue | any;
}

export interface BranchStatusValueBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface BranchStatusValueBranch {
  /**
   * The branch name
  */
  name: string;
  commit: BranchStatusValueBranchCommit;
}

/**
 * The branch build core properties
*/
export interface BranchStatusValue {
  branch?: BranchStatusValueBranch;
  enabled?: boolean;
}

export interface BranchStatusLastBuild {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

/**
 * The branch build status
*/
export interface BranchStatus {
  configured: boolean;
  lastBuild?: BranchStatusLastBuild;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "BranchStatusValue". Due to valid TS constraints we have modeled this as a union of
   * `BranchStatusValue | any`.
  */
  [additionalPropertyName: string]: BranchStatusValue | any;
}

export interface BranchPropertiesBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface BranchPropertiesBranch {
  /**
   * The branch name
  */
  name: string;
  commit: BranchPropertiesBranchCommit;
}

/**
 * The branch build core properties
*/
export interface BranchProperties {
  branch?: BranchPropertiesBranch;
  enabled?: boolean;
}

export interface BranchConfigurationValueBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface BranchConfigurationValueBranch {
  /**
   * The branch name
  */
  name: string;
  commit: BranchConfigurationValueBranchCommit;
}

/**
 * The branch build core properties
*/
export interface BranchConfigurationValue {
  branch?: BranchConfigurationValueBranch;
  enabled?: boolean;
}

/**
 * Provisioning profile fetch and store information
*/
export interface BranchConfigurationToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface BranchConfigurationToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  BranchConfigurationToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface BranchConfigurationToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface BranchConfigurationToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface BranchConfigurationToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface BranchConfigurationToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: BranchConfigurationToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: BranchConfigurationToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: BranchConfigurationToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: BranchConfigurationToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface BranchConfigurationArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

/**
 * The branch build configuration
*/
export interface BranchConfiguration {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: BranchConfigurationToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: BranchConfigurationArtifactVersioning;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "BranchConfigurationValue". Due to valid TS constraints we have modeled this as a union of
   * `BranchConfigurationValue | any`.
  */
  [additionalPropertyName: string]: BranchConfigurationValue | any;
}

/**
 * user who made a change in branch configuration
*/
export interface BranchConfigurationRevisionsItemChangedBy {
  displayName?: string;
  url?: string;
}

/**
 * branch configuration revision
*/
export interface BranchConfigurationRevisionsItem {
  id?: string;
  revision?: number;
  changedDate?: string;
  name?: string;
  changeType?: string;
  definitionUrl?: string;
  /**
   * user who made a change in branch configuration
  */
  changedBy?: BranchConfigurationRevisionsItemChangedBy;
}

/**
 * user who made a change in branch configuration
*/
export interface BranchConfigurationRevisionChangedBy {
  displayName?: string;
  url?: string;
}

/**
 * branch configuration revision
*/
export interface BranchConfigurationRevision {
  id?: string;
  revision?: number;
  changedDate?: string;
  name?: string;
  changeType?: string;
  definitionUrl?: string;
  /**
   * user who made a change in branch configuration
  */
  changedBy?: BranchConfigurationRevisionChangedBy;
}

/**
 * user who made a change in branch configuration
*/
export interface BranchConfigurationRevisionAuthor {
  displayName?: string;
  url?: string;
}

/**
 * Provisioning profile fetch and store information
*/
export interface BranchConfigurationWithIdToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface BranchConfigurationWithIdToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  BranchConfigurationWithIdToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface BranchConfigurationWithIdToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface BranchConfigurationWithIdToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface BranchConfigurationWithIdToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface BranchConfigurationWithIdToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: BranchConfigurationWithIdToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: BranchConfigurationWithIdToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: BranchConfigurationWithIdToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: BranchConfigurationWithIdToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface BranchConfigurationWithIdArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

export interface BranchConfigurationWithId {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: BranchConfigurationWithIdToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: BranchConfigurationWithIdArtifactVersioning;
  id: number;
}

/**
 * Provisioning profile fetch and store information
*/
export interface BranchConfigurationToolsetsXcodeAppExtensionProvisioningProfileFilesItemModel {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface BranchConfigurationToolsetsXcodeModel {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  BranchConfigurationToolsetsXcodeAppExtensionProvisioningProfileFilesItemModel[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface BranchConfigurationToolsetsJavascriptModel {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface BranchConfigurationToolsetsXamarinModel {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface BranchConfigurationToolsetsAndroidModel {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface BranchConfigurationToolsetsModel {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: BranchConfigurationToolsetsXcodeModel;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: BranchConfigurationToolsetsJavascriptModel;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: BranchConfigurationToolsetsXamarinModel;
  /**
   * Build configuration for Android projects
  */
  android?: BranchConfigurationToolsetsAndroidModel;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface BranchConfigurationArtifactVersioningModel {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

/**
 * Provisioning profile fetch and store information
*/
export interface XcodeBranchConfigurationPropertiesAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface XcodeBranchConfigurationProperties {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  XcodeBranchConfigurationPropertiesAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration for Android projects
*/
export interface AndroidBranchConfigurationProperties {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface JavaScriptBranchConfigurationProperties {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface XamarinBranchConfigurationProperties {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

export interface BranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface Branch {
  /**
   * The branch name
  */
  name: string;
  commit: BranchCommit;
}

export interface Commit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface CommitDetailsCommitAuthor {
  /**
   * Date and time of the commit
  */
  date?: string;
  /**
   * Author name
  */
  name?: string;
  /**
   * Author's email
  */
  email?: string;
}

export interface CommitDetailsCommit {
  /**
   * Commit message
  */
  message?: string;
  author?: CommitDetailsCommitAuthor;
}

export interface CommitDetails {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
  commit?: CommitDetailsCommit;
}

export interface CommitDetailsListItemCommitAuthor {
  /**
   * Date and time of the commit
  */
  date?: string;
  /**
   * Author name
  */
  name?: string;
  /**
   * Author's email
  */
  email?: string;
}

export interface CommitDetailsListItemCommit {
  /**
   * Commit message
  */
  message?: string;
  author?: CommitDetailsListItemCommitAuthor;
}

export interface CommitDetailsListItem {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
  commit?: CommitDetailsListItemCommit;
}

export interface RepoConfig {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
  /**
   * The GitHub App Installation id. Required for repositories connected from GitHub App
  */
  installationId?: string;
  /**
   * Repository configuration identifier
  */
  id: string;
  /**
   * Type of repository
  */
  type: string;
  /**
   * State of the configuration. Possible values include: 'unauthorized', 'inactive', 'active'
  */
  state: string;
  /**
   * Email of the user who linked the repository
  */
  userEmail?: string;
}

export interface RepoConfigPostRequest {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
  /**
   * The GitHub App Installation id. Required for repositories connected from GitHub App
  */
  installationId?: string;
}

export interface RepoConfigCommon {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl?: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
}

export interface RepoConfigsItem {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
  /**
   * The GitHub App Installation id. Required for repositories connected from GitHub App
  */
  installationId?: string;
  /**
   * Repository configuration identifier
  */
  id: string;
  /**
   * Type of repository
  */
  type: string;
  /**
   * State of the configuration. Possible values include: 'unauthorized', 'inactive', 'active'
  */
  state: string;
  /**
   * Email of the user who linked the repository
  */
  userEmail?: string;
}

export interface RepoInfo {
  /**
   * The repository url
  */
  repoUrl: string;
  /**
   * The external user ID
  */
  externalUserId?: string;
}

export interface PatchRepoInfo {
  /**
   * The external user ID
  */
  externalUserId?: string;
}

/**
 * The Xamarin SDK bundle
*/
export interface ToolsetsXamarinItem {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

/**
 * The Xcode version
*/
export interface ToolsetsXcodeItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

/**
 * The Node version
*/
export interface ToolsetsNodeItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Node version is default for AppCenter
  */
  current?: boolean;
}

/**
 * Set of toolsets available for app
*/
export interface Toolsets {
  /**
   * A list of Xamarin SDK bundles
  */
  xamarin?: ToolsetsXamarinItem[];
  /**
   * A list of Xcode versions
  */
  xcode?: ToolsetsXcodeItem[];
  /**
   * A list of Node versions
  */
  node?: ToolsetsNodeItem[];
}

/**
 * The Xcode version
*/
export interface XcodeVersionsItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

/**
 * The Xcode version
*/
export interface XcodeVersion {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

/**
 * The Xamarin SDK bundle
*/
export interface XamarinSDKBundlesItem {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

/**
 * The Xamarin SDK bundle
*/
export interface XamarinSDKBundle {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

/**
 * The Node version
*/
export interface NodeVersionsItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Node version is default for AppCenter
  */
  current?: boolean;
}

/**
 * The Node version
*/
export interface NodeVersion {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Node version is default for AppCenter
  */
  current?: boolean;
}

export interface BuildsItem {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface BuildParams {
  /**
   * Version to build which represents the full Git commit reference
  */
  sourceVersion?: string;
  /**
   * Run build in debug mode
  */
  debug?: boolean;
}

export interface Build {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface BuildPatch {
  /**
   * The build status; used to cancel builds. Possible values include: 'cancelling'
  */
  status?: string;
}

export interface BuildLog {
  value?: string[];
}

export interface BuildTimelineRecordsItemIssuesItem {
  category?: string;
  message?: string;
  type?: string;
}

export interface BuildTimelineRecordsItem {
  id?: string;
  name?: string;
  order?: number;
  percentComplete?: number;
  currentOperation?: string;
  state?: string;
  result?: string;
  errorCount?: number;
  warningCount?: number;
  issues?: BuildTimelineRecordsItemIssuesItem[];
  startTime?: string;
  finishTime?: string;
  type?: string;
}

export interface BuildTimeline {
  id?: string;
  records?: BuildTimelineRecordsItem[];
}

export interface BuildTimelineRecordIssuesItem {
  category?: string;
  message?: string;
  type?: string;
}

export interface BuildTimelineRecord {
  id?: string;
  name?: string;
  order?: number;
  percentComplete?: number;
  currentOperation?: string;
  state?: string;
  result?: string;
  errorCount?: number;
  warningCount?: number;
  issues?: BuildTimelineRecordIssuesItem[];
  startTime?: string;
  finishTime?: string;
  type?: string;
}

export interface BuildIssue {
  category?: string;
  message?: string;
  type?: string;
}

/**
 * Destination details for distributing build releases
*/
export interface DistributionRequestDestinationsItem {
  id: string;
  /**
   * Possible values include: 'store', 'group', 'tester'
  */
  type: string;
}

export interface DistributionRequest {
  /**
   * Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID,
   * or tester email, and "type" being "group", "store", or "tester"
  */
  destinations?: DistributionRequestDestinationsItem[];
  /**
   * The release notes
  */
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  notifyTesters?: boolean;
}

export interface DistributionResponse {
  /**
   * Status of the Request
  */
  status?: string;
  /**
   * A unique ID of the upload
  */
  uploadId?: string;
}

export interface BuildServiceStatus {
  status?: string;
  service?: string;
  message?: string;
  url?: string;
  validUntil?: number;
  os?: string;
}

export interface BuildAgentQueue {
  queue: string;
}

export interface ValidationErrorResponse {
  id: string;
  code: string;
  message: string;
}

/**
 * Queue configured in build definition
*/
export interface BuildAgentQueuesResponseItem {
  /**
   * Name of the build definition
  */
  buildDefinition?: string;
  /**
   * Name of the queue
  */
  name?: string;
}

/**
 * Queue configured in build definition
*/
export interface BuildAgentQueueResponse {
  /**
   * Name of the build definition
  */
  buildDefinition?: string;
  /**
   * Name of the queue
  */
  name?: string;
}

/**
 * Agent queue
*/
export interface AgentQueuesResponseItem {
  id?: number;
  name?: string;
}

/**
 * Agent queue
*/
export interface AgentQueueResponse {
  id?: number;
  name?: string;
}

/**
 * supported feature
*/
export interface AppBuildFeaturesItem {
  name?: string;
  value?: boolean;
}

/**
 * supported feature
*/
export interface AppBuildFeature {
  name?: string;
  value?: boolean;
}

/**
 * Destination details for distributing build releases
*/
export interface DestinationDetails {
  id: string;
  /**
   * Possible values include: 'store', 'group', 'tester'
  */
  type: string;
}

/**
 * Additional details required for file validation
*/
export interface FileValidationDetails {
  p12password: string;
  certificateUploadId?: string;
}

/**
 * Number of pipelines
*/
export interface BuildConcurrencyResponse {
  /**
   * The number of pipelines set by the billing plan
  */
  quantity?: number;
  /**
   * The number of pipelines committed, which can be equal or greater than the number from the
   * billing plan
  */
  committedQuantity?: number;
}

export interface CreateReleaseUploadResponse {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The access token used for upload permissions.
  */
  token: string;
  /**
   * The access token used for upload permissions (URL encoded to use as a single query parameter).
  */
  urlEncodedToken: string;
  /**
   * The associated asset ID in the file management service associated with this uploaded.
  */
  packageAssetId: string;
}

export interface GetReleaseStatusResponse {
  /**
   * The ID for the upload.
  */
  id: string;
  /**
   * The current upload status. Possible values include: 'uploadStarted', 'uploadFinished',
   * 'readyToBePublished', 'malwareDetected', 'error'
  */
  uploadStatus: string;
  /**
   * Details describing what went wrong processing the upload. Will only be set if status =
   * 'error'.
  */
  errorDetails?: string;
  /**
   * The distinct ID of the release. Will only be set when the status = 'readyToBePublished'.
  */
  releaseDistinctId?: number;
  /**
   * The URL of the release. Will only be set when the status = 'readyToBePublished'.
  */
  releaseUrl?: any;
}

export interface PatchReleaseUploadStatusRequest {
  /**
   * The new status of the release upload. Possible values include: 'uploadFinished',
   * 'uploadCanceled'
  */
  uploadStatus: string;
}

export interface PostCreateReleaseUploadRequest {
  /**
   * User defined build version
  */
  buildVersion?: string;
  /**
   * User defined build number
  */
  buildNumber?: string;
}

export interface PatchReleaseUploadStatusResponse {
  /**
   * The ID for the upload.
  */
  id: string;
  /**
   * The current upload status. Possible values include: 'uploadStarted', 'uploadFinished',
   * 'uploadCanceled', 'readyToBePublished', 'malwareDetected', 'error'
  */
  uploadStatus: string;
}

export interface TesterAppWithReleaseResponseRelease {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
}

/**
 * The information about the app's owner
*/
export interface TesterAppWithReleaseResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id?: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName?: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name?: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type?: string;
}

export interface TesterAppWithReleaseResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id?: string;
  release?: TesterAppWithReleaseResponseRelease;
  /**
   * The app's name.
  */
  name?: string;
  /**
   * The app's display name.
  */
  displayName?: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * A URL to the app's icon.
  */
  iconUrl?: string;
  /**
   * The app's os.
  */
  os?: string;
  /**
   * The information about the app's owner
  */
  owner?: TesterAppWithReleaseResponseOwner;
}

export interface TesterAppRelease {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
}

export interface SendNotificationRequest {
  /**
   * user list to send email notification
  */
  userIds: string[];
}

/**
 * Response for retrieving user interaction metrics.
*/
export interface UserInteractionMetricsResponse {
  /**
   * check if the user has less than 100 apps.
  */
  lessThan100Apps?: boolean;
  /**
   * check if the user's whole apps has more than 1 releases.
  */
  hasMoreThan1Release?: boolean;
}

export interface ReleaseUpdateResponseDestinationsItem {
  id?: string;
  name?: string;
}

/**
 * Response for updating a release
*/
export interface ReleaseUpdateResponse {
  enabled?: boolean;
  mandatoryUpdate?: boolean;
  releaseNotes?: string;
  provisioningStatusUrl?: string;
  destinations?: ReleaseUpdateResponseDestinationsItem[];
}

/**
 * Response for updating release details
*/
export interface ReleaseDetailsUpdateResponse {
  releaseNotes?: string;
}

/**
 * Response for updating release external url
*/
export interface ReleaseExternalUrlUpdateResponse {
  externalDownloadUrl?: string;
}

/**
 * Response for provisioning a release
*/
export interface ReleaseProvisionResponse {
  /**
   * The url to check provisioning status.
  */
  statusUrl?: string;
}

/**
 * Details of an uploaded release
*/
export interface PrivateReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * the destination where release is distributed
  */
  distributionGroupId?: string;
  /**
   * the publishing status of the distributed release
  */
  publishingStatus?: string;
  /**
   * The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

/**
 * Basic information on a release for private apis
*/
export interface PrivateBasicReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * the destination id of release where it is distributed.
  */
  distributionGroupId?: string;
  /**
   * The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Indicates if this is the latest release in the group.
  */
  isLatest?: boolean;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * the publishing status of the distributed release
  */
  publishingStatus?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

/**
 * Response for getting a list of releases in a distribution group
*/
export interface DistributionGroupReleasesResponseItem {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

/**
 * Response for getting a list of releases in a distribution group
*/
export interface DistributionGroupRelease {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface BasicReleaseDetailsResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface BasicReleaseDetailsResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface BasicReleaseDetailsResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Build information for the release

*/
export interface BasicReleaseDetailsResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Basic information on a release
*/
export interface BasicReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: BasicReleaseDetailsResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: BasicReleaseDetailsResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: BasicReleaseDetailsResponseDestinationsItem[];
  /**
   * Build information for the release

  */
  build?: BasicReleaseDetailsResponseBuild;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface ReleaseDetailsResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface ReleaseDetailsResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface ReleaseDetailsResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface ReleaseDetailsResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Details of an uploaded release
*/
export interface ReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName: string;
  /**
   * The app's display name.
  */
  appDisplayName: string;
  /**
   * The app's OS.
  */
  appOs?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * Hashes for the packages.
  */
  packageHashes?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: ReleaseDetailsResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: ReleaseDetailsResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: ReleaseDetailsResponseDestinationsItem[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: ReleaseDetailsResponseBuild;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * Status of the release.
  */
  status?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

/**
 * Details of an uploaded release
*/
export interface ManagementReleaseDetailsResponse {
  /**
   * ID identifying this unique release.
  */
  distinctId?: number;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's buildVersion.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  buildVersion?: string;
  /**
   * The release's sortVersion.
  */
  sortVersion?: string;
  /**
   * UTC time the release was created in ISO 8601 format.
  */
  createdAt?: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled?: boolean;
  /**
   * UTC time the release was created in ISO 8601 format.
  */
  deletedAt?: string;
}

/**
 * A response containing information pertaining to starting a release upload process
*/
export interface ReleaseUploadBeginResponse {
  /**
   * The ID for the current upload
  */
  uploadId: string;
  /**
   * The URL where the client needs to upload the release to
  */
  uploadUrl: string;
  /**
   * The ID for the current upload, reserved for future use
  */
  assetId?: string;
  /**
   * The URL for the current upload, reserved for future use
  */
  assetDomain?: string;
  /**
   * The token for the current upload, reserved for future use
  */
  assetToken?: string;
}

/**
 * A request containing a set of release ids to validate
*/
export interface GDPRValidationRequest {
  /**
   * a list of release ids to validate (AC flow)
  */
  releaseIds: number[];
  /**
   * a list of release ids to validate (HA flow)
  */
  hockeyappReleaseIds?: number[];
  /**
   * a list of release uploads ids to validate
  */
  releaseUploadIds?: string[];
}

/**
 * A request containing information pertaining to begin a release upload process
*/
export interface ReleaseUploadBeginRequest {
  /**
   * Optional value for explicitly specifying the ID of existing release.
  */
  releaseId?: number;
  /**
   * The build version of the uploaded binary, used for macOS, Windows and Custom app support.
  */
  buildVersion?: string;
  /**
   * The build number of the uploaded binary, used with build_version for macOS app support.
  */
  buildNumber?: string;
}

/**
 * A request containing information pertaining to complete a release upload process
*/
export interface ReleaseUploadEndRequest {
  /**
   * The desired operation for the upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

/**
 * A response containing information about the uploaded release.
*/
export interface ReleaseUploadEndResponse {
  /**
   * The ID of the release.
  */
  releaseId?: number;
  /**
   * A URL to the new release. If upload was aborted will be null.
  */
  releaseUrl?: string;
}

/**
 * An object containing a UUID for an architecture for an iOS app.
*/
export interface ReleaseCreateRequestIpaUuidsItem {
  /**
   * The architecture that the UUID belongs to, i.e. armv7 or arm64.
  */
  architecture: string;
  /**
   * The unique identifier.
  */
  uuid: string;
}

/**
 * An object containing information about an iOS provisioning profile.
*/
export interface ReleaseCreateRequestProvision {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The application identifier.
  */
  applicationIdentifier: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  profileType: string;
  /**
   * The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
  */
  expiredAt: Date;
  udids?: string[];
}

/**
 * An object containing information about an iOS provisioning profile.
*/
export interface ReleaseCreateRequestAppexProvisioningProfilesItem {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The application identifier.
  */
  applicationIdentifier: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  profileType: string;
  /**
   * The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
  */
  expiredAt: Date;
  udids?: string[];
}

/**
 * A request containing information for creating a release.
*/
export interface ReleaseCreateRequest {
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  buildVersion?: string;
  /**
   * The identifier of the app's bundle.
  */
  uniqueIdentifier?: string;
  /**
   * The release's minimum required operating system.
  */
  minimumOsVersion?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The languages supported by the release. Limited to 510 characters in a serialized array.
  */
  languages?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint: string;
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The URL to the release's binary.
  */
  packageUrl?: string;
  /**
   * The file extension of the asset. Does not include the initial period.
  */
  fileExtension?: string;
  /**
   * The upload id associated with the release, to map to the releases upload table.
  */
  uploadId: string;
  /**
   * The assetId associated with the icon uploaded to app center file upload service.
  */
  iconAssetId?: string;
  /**
   * A list of UUIDs for architectures for an iOS app.
  */
  ipaUuids?: ReleaseCreateRequestIpaUuidsItem[];
  /**
   * An object containing information about an iOS provisioning profile.
  */
  provision?: ReleaseCreateRequestProvision;
  /**
   * iOS app extension provisioning profiles included in the release.
  */
  appexProvisioningProfiles?: ReleaseCreateRequestAppexProvisioningProfilesItem[];
  /**
   * If true this release was uploaded to the AKS upload proxy
  */
  proxyFlow?: boolean;
}

/**
 * A request containing information for creating an externally hosted release.
*/
export interface ExternallyHostedReleaseCreateRequest {
  /**
   * The build version of the uploaded binary
  */
  buildVersion: string;
  /**
   * The build number of the uploaded binary
  */
  buildNumber?: string;
  /**
   * The external URL to the release's binary.
  */
  externalDownloadUrl: string;
}

/**
 * A request containing information for creating an externally hosted release.
*/
export interface UpdateExternalUrlRequest {
  /**
   * The external URL to the release's binary.
  */
  externalDownloadUrl: string;
}

/**
 * A unique identifier for a destination. A destination can be identified by an ID (guid) or by a
 * name. DestinationId encapsulates both options. A destination can be either a distribution group
 * or a store.
*/
export interface ReleaseUpdateRequestDestinationsItem {
  /**
   * Name of a distribution group / distribution store. The release will be associated with this
   * distribution group or store. If the distribution group / store doesn't exist a 400 is
   * returned. If both distribution group / store name and id are passed, the id is taking
   * precedence.
  */
  name?: string;
  /**
   * Id of a distribution group / store. The release will be associated with this distribution
   * group / store. If the distribution group / store doesn't exist a 400 is returned. If both
   * distribution group / store name and id are passed, the id is taking precedence.
  */
  id?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface ReleaseUpdateRequestBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * An object containing all the release metadata.
*/
export interface ReleaseUpdateRequestMetadata {
  /**
   * dsa signature of the release for the sparkle feed.
  */
  dsaSignature?: string;
  /**
   * edDSA signature of the release for the sparkle feed.
  */
  edSignature?: string;
}

/**
 * A request containing information for updating a release.
*/
export interface ReleaseUpdateRequest {
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * distribution group. The release will be associated with this distribution group. If the
   * distribution group doesn't exist a 400 is returned. If both distribution group name and id are
   * passed, the id is taking precedence.

  */
  distributionGroupName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution
   * group. The release will be associated with this distribution group. If the distribution group
   * doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is
   * taking precedence.

  */
  distributionGroupId?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * destination. The release will be associated with this destination. If the destination doesn't
   * exist a 400 is returned. If both distribution group name and id are passed, the id is taking
   * precedence.

  */
  destinationName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination.
   * The release will be associated with this destination. If the destination doesn't exist a 400
   * is returned. If both destination name and id are passed, the id is taking precedence.

  */
  destinationId?: string;
  /**
   * Not used anymore.
  */
  destinationType?: string;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  /**
   * A boolean which determines whether this version should be a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * Distribute this release under the following list of destinations (store groups or distribution
   * groups).
  */
  destinations?: ReleaseUpdateRequestDestinationsItem[];
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: ReleaseUpdateRequestBuild;
  /**
   * A boolean which determines whether to notify testers of a new release, default to true.
  */
  notifyTesters?: boolean;
  /**
   * An object containing all the release metadata.
  */
  metadata?: ReleaseUpdateRequestMetadata;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface ReleaseDetailsUpdateRequestBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * A request containing information for updating details of a release
*/
export interface ReleaseDetailsUpdateRequest {
  /**
   * Toggle this release to be enable distribute/download or not.
  */
  enabled?: boolean;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: ReleaseDetailsUpdateRequestBuild;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface BuildInfo {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * An object containing all the release metadata.
*/
export interface ReleaseMetadata {
  /**
   * dsa signature of the release for the sparkle feed.
  */
  dsaSignature?: string;
  /**
   * edDSA signature of the release for the sparkle feed.
  */
  edSignature?: string;
}

/**
 * A unique identifier for a destination. A destination can be identified by an ID (guid) or by a
 * name. DestinationId encapsulates both options. A destination can be either a distribution group
 * or a store.
*/
export interface DestinationId {
  /**
   * Name of a distribution group / distribution store. The release will be associated with this
   * distribution group or store. If the distribution group / store doesn't exist a 400 is
   * returned. If both distribution group / store name and id are passed, the id is taking
   * precedence.
  */
  name?: string;
  /**
   * Id of a distribution group / store. The release will be associated with this distribution
   * group / store. If the distribution group / store doesn't exist a 400 is returned. If both
   * distribution group / store name and id are passed, the id is taking precedence.
  */
  id?: string;
}

export interface ReleaseDestinationRequest {
  /**
   * Unique id of the release destination
  */
  id: string;
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface ReleaseStoreDestinationRequest {
  /**
   * Unique id of the release destination
  */
  id: string;
}

export interface ReleaseTesterDestinationRequest {
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Tester's email address
  */
  email: string;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface ReleaseDestinationResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate: boolean;
  /**
   * The url to check provisioning status.
  */
  provisioningStatusUrl?: string;
}

export interface ReleaseStoreDestinationResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
}

export interface Destination {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * A request containing information for updating a release.
*/
export interface PrivateReleaseUpdateRequest {
  /**
   * The store publishing status. Possible values include: 'failed', 'processing', 'submitted',
   * 'timeout'
  */
  publishingStatus?: string;
}

export interface DistributionGroup {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface DistributionGroupWithoutIsLatest {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface DistributionStore {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface DistributionStoreWithoutIsLatest {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * An object containing a UUID for an architecture for an iOS app.
*/
export interface ArchIdentifier {
  /**
   * The architecture that the UUID belongs to, i.e. armv7 or arm64.
  */
  architecture: string;
  /**
   * The unique identifier.
  */
  uuid: string;
}

/**
 * An object containing information about an iOS provisioning profile.
*/
export interface ProvisioningProfile {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The application identifier.
  */
  applicationIdentifier: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  profileType: string;
  /**
   * The profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z
  */
  expiredAt: Date;
  udids?: string[];
}

/**
 * A response containing information about an iOS provisioning profile.
*/
export interface ProvisioningProfileResponse {
  /**
   * Possible values include: 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType: string;
  udids?: string[];
  /**
   * The name of the provisioning profile.
  */
  provisioningProfileName?: string;
  /**
   * The team identifier.
  */
  teamIdentifier?: string;
  /**
   * The bundle identifier associated with the profile.
  */
  provisioningBundleId?: string;
  /**
   * Array of provisioning profiles for any app extensions
  */
  appexProfiles?: ProvisioningProfileResponse[];
}

export interface ReleaseUpdateErrorDestinationsItem {
  /**
   * Error Codes:<br>
   * <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not
   * valid.<br>
   * <b>store_release_bad_request</b>: Proper package release details for the store is not
   * provided.<br>
   * <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid
   * developer credentials.<br>
   * <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the
   * release version and already existing version in the store.<br>
   * <b>store_release_promotion</b>: Release already distributed, promoting a release is not
   * supported.<br>
   * <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release.
   * This is not supported yet.<br>
   * <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
   * <b>store_release_not_available</b>: The release is not available.<br>
   * <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server
   * error.

  */
  code?: string;
  message?: string;
  id?: string;
  name?: string;
}

export interface ReleaseUpdateError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  destinations?: ReleaseUpdateErrorDestinationsItem[];
}

export interface DestinationError {
  /**
   * Error Codes:<br>
   * <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not
   * valid.<br>
   * <b>store_release_bad_request</b>: Proper package release details for the store is not
   * provided.<br>
   * <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid
   * developer credentials.<br>
   * <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the
   * release version and already existing version in the store.<br>
   * <b>store_release_promotion</b>: Release already distributed, promoting a release is not
   * supported.<br>
   * <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release.
   * This is not supported yet.<br>
   * <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
   * <b>store_release_not_available</b>: The release is not available.<br>
   * <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server
   * error.

  */
  code?: string;
  message?: string;
  id?: string;
  name?: string;
}

/**
 * A request containing information for creating a Auto Provisioning Config.
*/
export interface AutoProvisioningConfigRequest {
  /**
   * A key to a secret in customer-credential-store. apple_developer_account refers to the user's
   * developer account that is used to log into https://developer.apple.com. Normally the user's
   * email.
  */
  appleDeveloperAccountKey?: string;
  /**
   * A key to a secret in customer-credential-store. distribution_certificate refers to the
   * customer's certificate (that holds the private key) that will be used to sign the app.
  */
  appleDistributionCertificateKey?: string;
  /**
   * When *true* enables auto provisioning
  */
  allowAutoProvisioning?: boolean;
}

/**
 * A response from API containing information for a Auto Provisioning Config.
*/
export interface AutoProvisioningConfigResponse {
  /**
   * The identifier of the config.
  */
  id?: number;
  /**
   * The identifier of the App.
  */
  appId?: string;
  /**
   * The identifier of the destination.
  */
  destinationId?: string;
  /**
   * A key to a secret in customer-credential-store. apple_developer_account refers to the user's
   * developer account that is used to log into https://developer.apple.com. Normally the user's
   * email.
  */
  appleDeveloperAccountKey?: string;
  /**
   * A key to a secret in customer-credential-store. distribution_certificate refers to the
   * cusomer's certificate (that holds the private key) that will be used to sign the app.
  */
  appleDistributionCertificateKey?: string;
  /**
   * When *true* enables auto provisioning
  */
  allowAutoProvisioning?: boolean;
}

export interface AnalyticsReleasesResponseReleasesItem {
  /**
   * release id
  */
  releaseId: number;
  /**
   * distribution group id
  */
  distributionGroupId: string;
  /**
   * user id
  */
  userId: string;
}

export interface AnalyticsReleasesResponse {
  releases?: AnalyticsReleasesResponseReleasesItem[];
}

export interface AnalyticsReleasesParameter {
  /**
   * release id
  */
  releaseId: number;
  /**
   * distribution group id
  */
  distributionGroupId: string;
  /**
   * user id
  */
  userId: string;
}

export interface HockeyAppCompatibilityReleaseResponse {
  id?: number;
  shortversion?: string;
  version?: string;
  uploadedAt?: Date;
  appsize?: number;
  notes?: string;
  mandatory?: boolean;
  external?: boolean;
  deviceFamily?: string;
  minimumOsVersion?: string;
  installUrl?: string;
  bundleIdentifier?: string;
}

/**
 * Describes the migration schema for a provisioning profile defined in HockeyApp.
*/
export interface ProvisioningProfileMigration {
  /**
   * The name of the provisioning profile.
  */
  name: string;
  /**
   * The bundle/application identifier.
  */
  bundleId: string;
  /**
   * The team identifier.
  */
  teamIdentifier: string;
  /**
   * The type of provisoning profile.
  */
  type: number;
  /**
   * A boolean value that indicates whether the provisioning profile represents an app extension.
  */
  isAppex: boolean;
  /**
   * The provisioning profile's expiration date in RFC 3339 format, i.e. 2017-07-21T17:32:28Z.
  */
  expiredAt?: Date;
  /**
   * A list of UDIDs of provisioned devices.
  */
  udids?: string[];
  /**
   * A provisioning profile URL that indicates where to download it from.
  */
  url?: string;
}

/**
 * Details of the upload to patch
*/
export interface PrivateUpdateUploadDetails {
  /**
   * Possible values include: 'uploadStarted', 'uploadFinished', 'readyToBePublished',
   * 'malwareDetected', 'error'
  */
  status: string;
  /**
   * Message of the error
  */
  errorMessage: string;
}

/**
 * Set the download URL of an external build
*/
export interface PostExternalDownloadUrl {
  /**
   * The new download URL
  */
  downloadUrl?: string;
}

/**
 * Patch the asset id of a release request body
*/
export interface PatchReleaseAssetIdRequest {
  /**
   * The release new package id in ACFUS
  */
  packageAssetId: string;
  /**
   * The release upload id used to upload the release
  */
  uploadId: string;
  /**
   * The ipa UUIDs for this release, as a serialized JSON array
  */
  ipaUuids?: string;
}

/**
 * Malware scan result from Malware Scan service
*/
export interface MalwareScanResultPayload {
  /**
   * Scan request identifier
  */
  requestId: string;
  /**
   * Scan result. Possible values include: 'clean', 'infected', 'error'
  */
  result: string;
}

export interface DistributionSettingsResponse {
  /**
   * Is this app using the "Default to Public Distribution Groups" logic
  */
  defaultPublic: boolean;
}

export interface PublicDistributionGroupsResponse {
  /**
   * The id of the distribution group
  */
  id: string;
}

/**
 * A response containing the fully encoded binary blob for a mobileconfig
*/
export interface DeviceConfigurationResponse {
  /**
   * A data URL containing a signed mobileconfig profile
  */
  dataUrl: string;
}

/**
 * The information for a single iOS device
*/
export interface DeviceInfoRequest {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The build number of the last known OS version running on the device
  */
  osBuild?: string;
  /**
   * The last known OS version running on the device
  */
  osVersion?: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
}

/**
 * The information for a single iOS device
*/
export interface DeviceInfoResponse {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

/**
 * The status of the resign operation.
*/
export interface ResignStatus {
  /**
   * The status of the resign
  */
  status: string;
  /**
   * Error code for any error that occured during the resigning operation.
  */
  errorCode?: string;
  /**
   * Error message for any error that occured during the resigning operation.
  */
  errorMessage?: string;
}

/**
 * The information for a resign attempt.
*/
export interface ResignInfo {
  /**
   * The group name of the resign attempt
  */
  groupName?: string;
  /**
   * The provisioning profile name of group for the given resign attempt
  */
  profileName?: string;
  /**
   * The provisioning profile type of group for the given resign attempt
  */
  profileType?: string;
  /**
   * The name of the certificate used for the resign attempt
  */
  certificateName?: string;
  /**
   * The expiration date of the certificate used for the resign attempt
  */
  certificateExpiration?: string;
}

/**
 * The information for a single distribution group member and their ios device
*/
export interface MemberDevicesInfoResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

/**
 * The publising information.
*/
export interface PublishDevicesRequest {
  /**
   * The username for the Apple Developer account to publish the devices to.
  */
  username?: string;
  /**
   * The password for the Apple Developer account to publish the devices to.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  accountServiceConnectionId?: string;
  /**
   * When set to true, all unprovisioned devices will be published to the Apple Developer account.
   * When false, only the provided devices will be published to the Apple Developer account.
  */
  publishAllDevices?: boolean;
  /**
   * Array of device UDID's to be published to the Apple Developer account.
  */
  devices?: string[];
}

/**
 * The information for a single iOS device
*/
export interface PublishDevicesResponse {
  /**
   * The file name for the provisioning profile.
  */
  profileFileName?: string;
  /**
   * The updated provisioning profiles zip base64 encoded.
  */
  profilesZipBase64: string;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal
*/
export interface AppleLoginRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * The password for the Apple Developer account.
  */
  password: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Indicates if login was successful.
*/
export interface AppleLoginResponse {
  /**
   * True when login was successful.
  */
  successful?: boolean;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal
*/
export interface AppleMutifactorLoginRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * This is the six digit OTP used for completing the multi-factor authentication
  */
  authcode: string;
}

/**
 * The response of Multifactor login. This is a 30 day session token generated by apple.
*/
export interface AppleMultifactorLoginResponse {
  /**
   * the apple developer account.
  */
  username?: string;
  /**
   * The 30-day session Token generated by apple after successfully logging in with Multifactor
   * authentication.
  */
  cookie?: string;
  /**
   * The expiry date of the cookie generated by apple
  */
  expires?: string;
}

/**
 * The information needed to fetch the status of an application
*/
export interface ApplicationStatusRequest {
  /**
   * The username for the Apple Developer account.
  */
  username: string;
  /**
   * The password for the Apple Developer account.
  */
  password: string;
  /**
   * Bundle Identifier of application in Apple Itunes portal.
  */
  bundleIdentifier: string;
  /**
   * Track Identifier for which the status is to be fetched.
  */
  trackIdentifier: string;
  /**
   * The version of build for which real time status is to be fetched.
  */
  buildVersion?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The Train version for which the status is to be fetched.
  */
  trainVersion?: string;
}

/**
 * The status information from Itunes portal
*/
export interface ApplicationStatusResponse {
  /**
   * The type of version being returned (production/edit/test flight).
  */
  versionType: string;
  /**
   * The version of the application
  */
  version?: string;
}

/**
 * Apple credentials with username, password or service_connection_id of the stored credentials is
 * needed along with team_identifier.
*/
export interface ItunesAppsRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Apple credentials with username, password or service_connection_id of the stored credentials is
 * needed.
*/
export interface ItunesTeamsRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
}

/**
 * Itunes teams details .
*/
export interface ItunesTeamsResponse {
  /**
   * Itunes team id.
  */
  teamId?: string;
  /**
   * Itunes Team Name
  */
  teamName?: string;
}

/**
 * Itunes teams details .
*/
export interface AllItunesAppsResponse {
  /**
   * apple id for app team id.
  */
  appleId?: string;
  /**
   * bundle identifier of app
  */
  bundleId?: string;
  /**
   * App Name
  */
  name?: string;
  /**
   * url for the app icon from app store
  */
  iconUrl?: string;
}

/**
 * Apple details for fetching test flight groups from Apple Developer Portal. pass either apple_id
 * or bundle_identifier to get the test flight groups. if both are passed than apple_id will take
 * preference
*/
export interface AppleTestFlightGroupRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * apple_id of the app for which test flight groups need to be fetched.
  */
  appleId?: string;
  /**
   * apple_id of the app for which test flight groups need to be fetched.
  */
  bundleIdentifier?: string;
  /**
   * Identifier of the team to use when logged in.
  */
  teamIdentifier?: string;
  /**
   * The 30-day session cookie for multi-factor authentication backed accounts.
  */
  cookie?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  serviceConnectionId?: string;
}

/**
 * test flight group details for the app.
*/
export interface AppleTestFlightGroupResponse {
  /**
   * id of the group.
  */
  id?: string;
  /**
   * provider id of the group.
  */
  providerId?: number;
  /**
   * apple id of the group.
  */
  appAdamId?: number;
  /**
   * name of the group.
  */
  name?: string;
  /**
   * true if group is in active state.
  */
  active?: boolean;
  /**
   * true if the group is an internal group.
  */
  isInternalGroup?: boolean;
}

/**
 * Apple credentials needed to log into the Apple Developer Portal and access provisioning profiles
*/
export interface AvailabilityOfDevicesRequest {
  /**
   * The username for the Apple Developer account.
  */
  username?: string;
  /**
   * The password for the Apple Developer account.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instad of username, password.
  */
  serviceConnectionId?: string;
}

/**
 * ...
*/
export interface DeviceAvailability {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * ...
*/
export interface AvailabilityOfDevicesResponseIphones {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * ...
*/
export interface AvailabilityOfDevicesResponseIpads {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * ...
*/
export interface AvailabilityOfDevicesResponseIpods {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * ...
*/
export interface AvailabilityOfDevicesResponseWatches {
  registered: number;
  available: number;
  maximum: number;
}

/**
 * The current device availability (registered, available and maxmimum) for iPhones, iPads, iPods
 * and Watches from Apple Developer Portal
*/
export interface AvailabilityOfDevicesResponse {
  /**
   * ...
  */
  iphones: AvailabilityOfDevicesResponseIphones;
  /**
   * ...
  */
  ipads: AvailabilityOfDevicesResponseIpads;
  /**
   * ...
  */
  ipods: AvailabilityOfDevicesResponseIpods;
  /**
   * ...
  */
  watches: AvailabilityOfDevicesResponseWatches;
}

export interface UpdateDevicesRequestDestinationsItem {
  name?: string;
}

/**
 * Information required to publish devices to the Apple Developer account and resign the
 * application.
*/
export interface UpdateDevicesRequest {
  /**
   * When provided, will update the provided release with the new set of devices. By default the
   * latest release of the distribution group is used when this property is omitted. If
   * `release_id` is passed in the path, there is no need to pass in the body as well.
  */
  releaseId?: number;
  /**
   * The username for the Apple Developer account to publish the devices to.
  */
  username?: string;
  /**
   * The password for the Apple Developer account to publish the devices to.
  */
  password?: string;
  /**
   * The service_connection_id of the stored Apple credentials instead of username, password.
  */
  accountServiceConnectionId?: string;
  /**
   * The certificate to use for resigning the application with the updated provisioning profiles.
  */
  p12Base64?: string;
  /**
   * The service_connection_id of the stored Apple certificate instead of p12_base64 value.
  */
  p12ServiceConnectionId?: string;
  /**
   * The password certificate if one is needed.
  */
  p12Password?: string;
  /**
   * When set to true, all unprovisioned devices will be published to the Apple Developer account.
   * When false, only the provided devices will be published to the Apple Developer account.
  */
  publishAllDevices?: boolean;
  /**
   * Array of device UDID's to be published to the Apple Developer account.
  */
  devices?: string[];
  /**
   * Array of distribution groups that the devices should be provisioned from.
  */
  destinations?: UpdateDevicesRequestDestinationsItem[];
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface UpdateDevicesResponse {
  /**
   * URL that can be used to check the status of the update devices operation.
  */
  statusUrl: string;
}

/**
 * Updates the status of the resign request
*/
export interface UpdateResignStatusRequest {
  /**
   * The updated status for the resigning request.
  */
  status: string;
  /**
   * Error code if an error occured in the resigning operation.
  */
  errorCode?: string;
  /**
   * Error message if an error occured in the resigning operation.
  */
  errorMessage?: string;
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface UpdateResignStatusResponse {
  /**
   * The status.
  */
  status: string;
  /**
   * A zip of the updated provisioning profiles. Base64 encoded.
  */
  profilesZipBase64?: string;
}

/**
 * The url that can be navigated to in order to start the device registration process.
*/
export interface DeviceRegistrationUrl {
  /**
   * The url that can be navigated to in order to start the device registration process.
  */
  registrationUrl: string;
}

/**
 * URL that can be used to check the status of the update devices operation and the updated
 * profiles.
*/
export interface ResignAttemptResponse {
  /**
   * The status of the resigning operation.
  */
  status: string;
  /**
   * ID of the user performing the resign operaiton.
  */
  userId: string;
  /**
   * App ID that the resign operation is being performed against.
  */
  appId: string;
  /**
   * ID of the release which is being resigned.
  */
  originalReleaseId: number;
  /**
   * ID of the resign operation.
  */
  resignId: string;
  /**
   * Context ID for the resigning operation.
  */
  contextId: string;
  /**
   * The time that the resign operation was started.
  */
  startTime: number;
  /**
   * List of destinations that the resign operation is being performed against.
  */
  destinations?: any[];
  /**
   * Error code associated with the exception.
  */
  errorCode?: string;
  /**
   * Error message associated with the exception.
  */
  errorMessage?: string;
}

export interface StoresReleaseDetailsDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune or googleplay. Possible
   * values include: 'intune', 'googleplay'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * Details of an uploaded release
*/
export interface StoresReleaseDetails {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`. Possible values include: 'group',
   * 'store'
  */
  installUrl?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: StoresReleaseDetailsDistributionStoresItem[];
}

export interface StorePatchRequest {
  /**
   * Service connection id to updated.
  */
  serviceConnectionId: string;
}

export interface ExternalStoreRequestIntuneDetailsSecretJson {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface ExternalStoreRequestIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface ExternalStoreRequestIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface ExternalStoreRequestIntuneDetails {
  secretJson?: ExternalStoreRequestIntuneDetailsSecretJson;
  targetAudience?: ExternalStoreRequestIntuneDetailsTargetAudience;
  appCategory?: ExternalStoreRequestIntuneDetailsAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

/**
 * ExternalStoreRequest
*/
export interface ExternalStoreRequest {
  /**
   * store Type. Possible values include: 'googleplay', 'intune', 'apple'
  */
  type?: string;
  /**
   * name of the store. In case of googleplay, and Apple store this is fixed to Production.
  */
  name?: string;
  /**
   * track of the store. Can be production, alpha & beta for googleplay. Can be production,
   * testflight-internal & testflight-external for Apple Store. Possible values include:
   * 'production', 'alpha', 'beta', 'testflight-internal', 'testflight-external'
  */
  track?: string;
  intuneDetails?: ExternalStoreRequestIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
}

/**
 * Apple Mapping Request Type
*/
export interface AppleMappingRequest {
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId: string;
  /**
   * ID of the apple application in apple store, takes precedence over bundle_identifier when both
   * are provided
  */
  appleId?: string;
  /**
   * Bundle Identifier of the apple package
  */
  bundleIdentifier?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier: string;
}

/**
 * Apple Mapping Request Type
*/
export interface AppleMappingResponse {
  /**
   * ID of the apple application in Mobile Center
  */
  appId?: string;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
  /**
   * ID of the apple application in apple store
  */
  appleId?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier?: string;
}

/**
 * Apple Test Flight Groups Response Type
*/
export interface AppleTestFlightGroupsResponse {
  /**
   * id of the group.
  */
  id?: string;
  /**
   * provider id of the group.
  */
  providerId?: number;
  /**
   * apple id of the group.
  */
  appleId?: number;
  /**
   * name of the group.
  */
  name?: string;
}

export interface PrivateCreateStoreRequestIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface PrivateCreateStoreRequestIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface PrivateCreateStoreRequestIntuneDetails {
  targetAudience?: PrivateCreateStoreRequestIntuneDetailsTargetAudience;
  appCategory?: PrivateCreateStoreRequestIntuneDetailsAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

/**
 * create the store through private API. Used by UI.
*/
export interface PrivateCreateStoreRequest {
  /**
   * store Type. Possible values include: 'intune'
  */
  type?: string;
  /**
   * name of the store.
  */
  name?: string;
  intuneDetails?: PrivateCreateStoreRequestIntuneDetails;
}

export interface IntuneSecretDetails {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface IntuneCategoriesValueItem {
  /**
   * the id of the category
  */
  id?: string;
  /**
   * the display name for the category
  */
  displayName?: string;
  /**
   * modified date for category
  */
  lastModifiedDateTime?: string;
}

export interface IntuneCategories {
  /**
   * context
  */
  odatacontext?: string;
  /**
   * categories for intune app
  */
  value?: IntuneCategoriesValueItem[];
}

export interface IntuneCategoryValue {
  /**
   * the id of the category
  */
  id?: string;
  /**
   * the display name for the category
  */
  displayName?: string;
  /**
   * modified date for category
  */
  lastModifiedDateTime?: string;
}

export interface IntuneGroupsValueItem {
  /**
   * the id of the Group
  */
  id?: string;
  /**
   * the display name of the group
  */
  displayName?: string;
}

export interface IntuneGroups {
  /**
   * context
  */
  odatacontext?: string;
  /**
   * categories for intune app
  */
  value?: IntuneGroupsValueItem[];
}

export interface IntuneGroupValue {
  /**
   * the id of the Group
  */
  id?: string;
  /**
   * the display name of the group
  */
  displayName?: string;
}

export interface IntuneGroup {
  /**
   * the id of the Group
  */
  id?: string;
  /**
   * the display name of the group
  */
  displayName?: string;
  /**
   * species if it is a security group
  */
  securityEnabled?: boolean;
}

export interface CreateStoreSecretRequestSecretJson {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface CreateStoreSecretRequest {
  secretJson?: CreateStoreSecretRequestSecretJson;
  /**
   * the tenant id for user
  */
  tenantId?: string;
}

export interface CreateStoreSecretResponse {
  /**
   * the secret id for store secret
  */
  secretId?: string;
}

export interface SecretDetails {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

/**
 * ReleasePublishErrorResponse
*/
export interface ReleasePublishErrorResponse {
  /**
   * error Details
  */
  message?: string;
  /**
   * boolean property to tell if logs are available for download
  */
  isLogAvailable?: boolean;
}

/**
 * Status Data from store
*/
export interface ReleaseRealTimeStatusResponseStatus {
  /**
   * status from store
  */
  status?: string;
  /**
   * store type
  */
  storetype?: string;
  /**
   * track information from store
  */
  track?: string;
  /**
   * version of the app from store
  */
  version?: string;
}

/**
 * status of the app from store
*/
export interface ReleaseRealTimeStatusResponse {
  /**
   * release id
  */
  releaseId?: string;
  /**
   * app id
  */
  appId?: string;
  /**
   * Status Data from store
  */
  status?: ReleaseRealTimeStatusResponseStatus;
}

/**
 * Status Data from store
*/
export interface ValidationResponseStatus {
  /**
   * status from store
  */
  status?: string;
  /**
   * store type
  */
  storetype?: string;
  /**
   * track information from store
  */
  track?: string;
  /**
   * version of the app from store
  */
  version?: string;
}

/**
 * The response which contains the validation data that the connection is valid.
*/
export interface ValidationResponse {
  /**
   * app id
  */
  appId?: string;
  /**
   * Status Data from store
  */
  status?: ValidationResponseStatus;
}

/**
 * The response for the build uploaded check.
*/
export interface HasBuildUploadedResponse {
  /**
   * true if a build has been uploaded, false otherwise
  */
  hasBuildUploaded?: boolean;
}

/**
 * The response for the testflight metadata check.
*/
export interface HasTestflightMetadataResponse {
  /**
   * true if the app has the testflight metadata, false otherwise
  */
  hasTestflightMetadata?: boolean;
}

/**
 * Wheither or not to skip the validation for this release
*/
export interface SkipValidationRequest {
  /**
   * true if we want to skip the validation, false otherwise
  */
  skipValidation?: boolean;
}

/**
 * Status Data from store
*/
export interface StatusData {
  /**
   * status from store
  */
  status?: string;
  /**
   * store type
  */
  storetype?: string;
  /**
   * track information from store
  */
  track?: string;
  /**
   * version of the app from store
  */
  version?: string;
}

export interface ExternalStoreResponseIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface ExternalStoreResponseIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

/**
 * Store details for intune
*/
export interface ExternalStoreResponseIntuneDetails {
  targetAudience?: ExternalStoreResponseIntuneDetailsTargetAudience;
  appCategory?: ExternalStoreResponseIntuneDetailsAppCategory;
}

/**
 * ExternalStoreResponse
*/
export interface ExternalStoreResponse {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Store track. Possible values include: 'production', 'alpha', 'beta', 'testflight-internal',
   * 'testflight-external'
  */
  track?: string;
  /**
   * Store details for intune
  */
  intuneDetails?: ExternalStoreResponseIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple / GooglePlay stores, this connection
   * will be used to connect to the Apple / Google stores in App Center.
  */
  serviceConnectionId?: string;
  /**
   * The ID of the principal that created the store.
  */
  createdBy?: string;
  /**
   * The type of the principal that created the store.
  */
  createdByPrincipalType?: string;
}

/**
 * StoreSecretResponse
*/
export interface StoreSecretResponse {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Secret Json
  */
  secret?: string;
  /**
   * Tenant Id for Intune
  */
  tenantId?: string;
}

export interface IntuneStoreResponseTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface IntuneStoreResponseAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

export interface IntuneStoreResponse {
  targetAudience?: IntuneStoreResponseTargetAudience;
  appCategory?: IntuneStoreResponseAppCategory;
}

export interface IntuneStoreRequestSecretJson {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface IntuneStoreRequestTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface IntuneStoreRequestAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface IntuneStoreRequest {
  secretJson?: IntuneStoreRequestSecretJson;
  targetAudience?: IntuneStoreRequestTargetAudience;
  appCategory?: IntuneStoreRequestAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

export interface PrivateIntuneStoreRequestTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface PrivateIntuneStoreRequestAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface PrivateIntuneStoreRequest {
  targetAudience?: PrivateIntuneStoreRequestTargetAudience;
  appCategory?: PrivateIntuneStoreRequestAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

export interface IntuneTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface IntuneAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface IntuneTargetAudienceResponse {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface IntuneAppCategoryResponse {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

export interface PatchReleaseRequest {
  /**
   * updated status of release
  */
  status?: string;
  /**
   * Destination Publish Id
  */
  destPublishId?: string;
  /**
   * failure error details from store
  */
  errorDetails?: string;
  /**
   * contextId for failed error message
  */
  errorContextId?: string;
  /**
   * package url for wrapping request
  */
  wrapPackageUrl?: string;
  /**
   * request is for wrapping or not
  */
  isWrapperRequest?: boolean;
}

export interface StoresBasicReleaseDetailsDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * A type identifying the type of distribution store. Possible values include: 'googleplay',
   * 'intune', 'apple'
  */
  type?: string;
  /**
   * A status identifying the status of release in the distribution store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

/**
 * Basic information on a release
*/
export interface StoresBasicReleaseDetails {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * Destination for this release. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: StoresBasicReleaseDetailsDistributionStoresItem[];
}

export interface StoresDetails {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * A type identifying the type of distribution store. Possible values include: 'googleplay',
   * 'intune', 'apple'
  */
  type?: string;
  /**
   * A status identifying the status of release in the distribution store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface StoreDestinationDetails {
  /**
   * destination ID identifying a unique id in distribution store.
  */
  destPublishId?: string;
  /**
   * type of store. Possible values include: 'intune'
  */
  storeType?: string;
  /**
   * app id of application.
  */
  appId?: string;
}

export interface StoresBasicDetails {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune or googleplay. Possible
   * values include: 'intune', 'googleplay'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * IntuneAppsRequest
*/
export interface IntuneAppsRequest {
  /**
   * PartitionKey year-month
  */
  createdMonth?: string;
}

/**
 * IntuneAppsResponse
*/
export interface IntuneAppsResponse {
  /**
   * PartitionKey year-month
  */
  createdMonth?: string;
  /**
   * App id
  */
  appId?: string;
  /**
   * Refresh Status
  */
  refreshStatus?: string;
}

/**
 * org settings Request
*/
export interface OrgComplianceSettingsRequest {
  /**
   * certificate connection id to wrap and resign the app after wrapping
  */
  certificateConnectionId: string;
}

/**
 * org settings response
*/
export interface OrgComplianceSettingsResponse {
  /**
   * The internal unique id (UUID) of the organization compliance setting
  */
  id: string;
  /**
   * The internal unique id (UUID) of the organization.
  */
  orgId: string;
  /**
   * certificate connection id to wrap and resign the app after wrapping
  */
  certificateConnectionId: string;
  /**
   * flag to tell if mam warpping is enabled on the Org
  */
  isMamEnabled?: boolean;
}

export interface StoreNotification {
  service?: string;
  status?: string;
  validUntil?: number;
}

/**
 * The diagnostic id for the given publish action
*/
export interface DiagnosticIdResponse {
  /**
   * diagnostic id
  */
  diagnosticId?: string;
}

export interface Symbol {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

export interface SymbolsItem {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

/**
 * A response containing information pertaining to a symbol status
*/
export interface SymbolStatusResponse {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored', 'missing'
  */
  status: string;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface SymbolUploadUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface SymbolUploadSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface SymbolUpload {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: SymbolUploadUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: SymbolUploadSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface SymbolUploadsItemUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface SymbolUploadsItemSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface SymbolUploadsItem {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: SymbolUploadsItemUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: SymbolUploadsItemSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

/**
 * Location for downloading symbol
*/
export interface SymbolLocation {
  uri: string;
}

/**
 * Location for downloading symbol upload
*/
export interface SymbolUploadLocation {
  uri: string;
}

/**
 * A request containing information pertaining to starting a symbol upload process
*/
export interface SymbolUploadBeginRequest {
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The callback URL that the client can optionally provide to get status updates for the current
   * symbol upload
  */
  clientCallback?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
}

/**
 * A response containing information pertaining to starting a symbol upload process
*/
export interface SymbolUploadBeginResponse {
  /**
   * The id for the current upload
  */
  symbolUploadId: string;
  /**
   * The URL where the client needs to upload the symbol blob to
  */
  uploadUrl: string;
  /**
   * Describes how long the upload_url is valid
  */
  expirationDate: Date;
}

/**
 * A request containing information pertaining to completing a symbol upload process
*/
export interface SymbolUploadEndRequest {
  /**
   * The desired operation for the symbol upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

export interface SymbolUploadUserInfo {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface UploadedSymbolInfo {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A response represents information about symbol name group
*/
export interface SystemVersionNameGroup {
  /**
   * Name of version group
  */
  name?: string;
  versions?: string[];
}

/**
 * A response represents information about symbol name group
*/
export interface SystemVersionNameGroupsItem {
  /**
   * Name of version group
  */
  name?: string;
  versions?: string[];
}

export interface AppCrashesInfoFeatures {
  /**
   * App supports modification of crashgroup status
  */
  crashgroupModifyStatus?: boolean;
  /**
   * App supports modification of crashgroup annotation
  */
  crashgroupModifyAnnotation?: boolean;
  /**
   * App supports search API
  */
  search?: boolean;
  /**
   * App supports the 'crash free user' metric
  */
  crashgroupAnalyticsCrashfreeusers?: boolean;
  /**
   * App supports the 'impacted users' metric
  */
  crashgroupAnalyticsImpactedusers?: boolean;
  /**
   * App supports download of raw crashes
  */
  crashDownloadRaw?: boolean;
}

export interface AppCrashesInfo {
  hasCrashes: boolean;
  features: AppCrashesInfoFeatures;
}

export interface AppFeatures {
  /**
   * App supports modification of crashgroup status
  */
  crashgroupModifyStatus?: boolean;
  /**
   * App supports modification of crashgroup annotation
  */
  crashgroupModifyAnnotation?: boolean;
  /**
   * App supports search API
  */
  search?: boolean;
  /**
   * App supports the 'crash free user' metric
  */
  crashgroupAnalyticsCrashfreeusers?: boolean;
  /**
   * App supports the 'impacted users' metric
  */
  crashgroupAnalyticsImpactedusers?: boolean;
  /**
   * App supports download of raw crashes
  */
  crashDownloadRaw?: boolean;
}

export interface AppVersion {
  appVersionId: string;
  appId: string;
  displayName: string;
  appVersion: string;
  buildNumber?: string;
}

/**
 * a single frame of a stack trace
*/
export interface ExceptionFramesItem {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a exception
*/
export interface Exception {
  /**
   * Reason of the exception
  */
  reason?: string;
  /**
   * Type of the exception (NSSomethingException, NullPointerException)
  */
  type?: string;
  /**
   * frames of the excetpion
  */
  frames: ExceptionFramesItem[];
  /**
   * relevant exception (crashed)
  */
  relevant?: boolean;
  innerExceptions?: Exception[];
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
}

/**
 * a single frame of a stack trace
*/
export interface ThreadFramesItem {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a thread representation
*/
export interface Thread {
  /**
   * name of the thread
  */
  title: string;
  /**
   * frames of that thread
  */
  frames: ThreadFramesItem[];
  /**
   * potential additional exception happened in that thread (Last Exception Backtrace)
  */
  exception?: Exception;
  /**
   * Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
  */
  relevant?: boolean;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
  /**
   * True if this thread crashed
  */
  crashed?: boolean;
}

/**
 * a stacktrace in a processed and prettyfied way
*/
export interface Stacktrace {
  title?: string;
  reason?: string;
  threads?: Thread[];
  exception?: Exception;
}

/**
 * a single frame of a stack trace
*/
export interface StackFrame {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * frame belonging to the reason of the crash
*/
export interface ReasonStackFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface RetentionSettings {
  retentionInDays: number;
}

export interface CrashAttachment {
  appId: string;
  attachmentId: string;
  crashId: string;
  blobLocation: string;
  contentType: string;
  fileName: string;
  createdTime: Date;
  size: number;
}

/**
 * Location for downloading crash raw
*/
export interface CrashRawLocation {
  uri: string;
}

/**
 * Location for downloading crash attachment
*/
export interface CrashAttachmentLocation {
  uri: string;
}

/**
 * frame belonging to the reason of the crash
*/
export interface CrashGroupsContainerCrashGroupsItemReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface CrashGroupsContainerCrashGroupsItem {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  /**
   * frame belonging to the reason of the crash
  */
  reasonFrame?: CrashGroupsContainerCrashGroupsItemReasonFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface CrashGroupsContainer {
  limitedResultSet: boolean;
  /**
   * Cassandra request continuation token. The token is used for pagination.
  */
  continuationToken?: string;
  crashGroups: CrashGroupsContainerCrashGroupsItem[];
}

/**
 * frame belonging to the reason of the crash
*/
export interface CrashGroupReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface CrashGroup {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  /**
   * frame belonging to the reason of the crash
  */
  reasonFrame?: CrashGroupReasonFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface CrashGroupChange {
  status?: any;
  annotation?: string;
}

export interface CrashDetails {
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCountry?: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * Whether the device where the crash occurred is rooted or jailbroken

  */
  rooted: boolean;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize: string;
  /**
   * Application launch timestamp (example: 1985-04-12T23:20:50.52Z).

  */
  appStartTimestamp?: Date;
}

export interface Crash {
  details?: CrashDetails;
  newCrashGroupId: string;
  crashId: string;
  newCrashId: string;
  displayId?: string;
  timestamp: Date;
  version: string;
  build: string;
  device: string;
  deviceName?: string;
  osVersion: string;
  osType?: string;
  stacktrace?: Stacktrace;
  userName: string;
  userEmail?: string;
}

export interface CrashDetailsModel {
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCountry?: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * Whether the device where the crash occurred is rooted or jailbroken

  */
  rooted: boolean;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize: string;
  /**
   * Application launch timestamp (example: 1985-04-12T23:20:50.52Z).

  */
  appStartTimestamp?: Date;
}

export interface AlertingCrashGroup {
  url?: string;
  appDisplayName?: string;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  appPlatform?: string;
  appVersion?: string;
  id?: string;
  name?: string;
  reason?: string;
  stackTrace?: string[];
}

export interface CrashDeleteCounter {
  appId?: string;
  crashGroupId?: string;
  crashId?: string;
  crashesDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

/**
 * missing symbol
*/
export interface V2MissingSymbol {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol
*/
export interface V2MissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * symbol update message
*/
export interface V2SymbolUpdateInfo {
  /**
   * UUID of the symbol
  */
  symbolId: string;
  /**
   * application id
  */
  appId: string;
  /**
   * symbol upload status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol
*/
export interface V2MissingSymbolCrashGroupMissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface V2MissingSymbolCrashGroup {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * number of errors that belong to this group
  */
  errorCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: V2MissingSymbolCrashGroupMissingSymbolsItem[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * missing symbol
*/
export interface V2MissingSymbolCrashGroupsItemMissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface V2MissingSymbolCrashGroupsItem {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * number of errors that belong to this group
  */
  errorCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: V2MissingSymbolCrashGroupsItemMissingSymbolsItem[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * missing symbol
*/
export interface V2MissingSymbolCrashGroupsResponseGroupsItemMissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface V2MissingSymbolCrashGroupsResponseGroupsItem {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * number of errors that belong to this group
  */
  errorCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: V2MissingSymbolCrashGroupsResponseGroupsItemMissingSymbolsItem[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * grouped by missing symbols crashes response object
*/
export interface V2MissingSymbolCrashGroupsResponse {
  /**
   * total number of crashes for all the groups
  */
  totalCrashCount: number;
  /**
   * list of crash groups formed by missing symbols combination
  */
  groups: V2MissingSymbolCrashGroupsResponseGroupsItem[];
}

/**
 * missing symbol groups
*/
export interface V2MissingSymbolCrashGroupsInfoResponse {
  /**
   * total number of crashes for all missing symbol groups
  */
  totalCrashCount: number;
}

/**
 * status response object
*/
export interface V2StatusResponse {
  status: string;
}

/**
 * failure response object
*/
export interface V2FailureResponse {
  code: string;
  message: string;
}

export interface ActiveCrashingAppDetailsAppsWithCrashesItem {
  /**
   * application identifier
  */
  appId?: string;
  /**
   * application version
  */
  appVersion?: string;
  /**
   * crash group identifier
  */
  crashGroupId?: string;
}

export interface ActiveCrashingAppDetails {
  nextLink?: string;
  /**
   * details of the apps with crashes
  */
  appsWithCrashes?: ActiveCrashingAppDetailsAppsWithCrashesItem[];
}

export interface LogTraceDefinition {
  appSecret: string;
  installId?: string;
  expiration?: Date;
}

export interface CrashingAppDetail {
  /**
   * application identifier
  */
  appId?: string;
  /**
   * application version
  */
  appVersion?: string;
  /**
   * crash group identifier
  */
  crashGroupId?: string;
}

/**
 * Device characteristics.
*/
export interface LogContainerLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogContainerLogsItem {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogContainerLogsItemDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogContainerLogsItem[];
}

/**
 * Device characteristics.
*/
export interface GenericLogContainerLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLogContainerLogsItem {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: GenericLogContainerLogsItemDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

export interface GenericLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: GenericLogContainerLogsItem[];
}

/**
 * Device characteristics.
*/
export interface GenericLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: GenericLogDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

/**
 * Device characteristics.
*/
export interface LogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface Log {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Device characteristics.
*/
export interface LogWithPropertiesDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogWithProperties {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogWithPropertiesDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Device characteristics.
*/
export interface Device {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Device characteristics.
*/
export interface StartSessionLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface StartSessionLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: StartSessionLogDevice;
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Device characteristics.
*/
export interface DistributionStartSessionLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Log is used to update distribution group identifier for session (a marker event for analytics
 * service).
*/
export interface DistributionStartSessionLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: DistributionStartSessionLogDevice;
  /**
   * Distribution Group ID.

  */
  distributionGroupId: string;
}

/**
 * Device characteristics.
*/
export interface HandledErrorLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface HandledErrorLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: HandledErrorLogDevice;
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Device characteristics.
*/
export interface UnhandledErrorLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface UnhandledErrorLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: UnhandledErrorLogDevice;
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Device characteristics.
*/
export interface StartServiceLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface StartServiceLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: StartServiceLogDevice;
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

/**
 * Device characteristics.
*/
export interface CustomPropertyLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface CustomPropertyLogPropertiesItem {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface CustomPropertyLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: CustomPropertyLogDevice;
  /**
   * Custom property changes.
  */
  properties?: CustomPropertyLogPropertiesItem[];
}

export interface CustomProperty {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * String property.
*/
export interface StringProperty {
  type: string;
  name: string;
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface NumberProperty {
  type: string;
  name: string;
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface BooleanProperty {
  type: string;
  name: string;
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface DateTimeProperty {
  type: string;
  name: string;
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface ClearProperty {
  type: string;
  name: string;
}

/**
 * Device characteristics.
*/
export interface PageLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Page view log (as in screens or activities).
*/
export interface PageLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: PageLogDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface EventLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Event log.
*/
export interface EventLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: EventLogDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface PushInstallationLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Push installation Information.
*/
export interface PushInstallationLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: PushInstallationLogDevice;
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Device characteristics.
*/
export interface ErrorLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Error log.
*/
export interface ErrorLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: ErrorLogDevice;
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

/**
 * Audience definition.
*/
export interface AudienceListResultValuesItem {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
}

/**
 * List of audiences.
*/
export interface AudienceListResult {
  /**
   * List of audiences.
  */
  values: AudienceListResultValuesItem[];
  nextLink?: string;
}

/**
 * Audience definition.
*/
export interface AudienceSummary {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
}

/**
 * Audience with details.
*/
export interface Audience {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
  /**
   * Date the audience was last refreshed.
  */
  timestamp?: Date;
}

/**
 * Audience test result.
*/
export interface AudienceTestResult {
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
}

/**
 * Token query result.
*/
export interface TokenQueryResult {
  /**
   * List of tokens.
  */
  tokens?: string[];
}

/**
 * Audience definition.
*/
export interface AudienceDefinition {
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Audience definition in OData format.
  */
  definition: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
}

/**
 * Audience Query definition.
*/
export interface AudienceQueryDefinition {
  /**
   * Audience Query Type. Possible values include: 'broadcast', 'user_ids', 'account_ids',
   * 'install_ids'
  */
  queryType: string;
  /**
   * List of identifiers.
  */
  identifiers?: string[];
}

/**
 * Audience definition.
*/
export interface AudienceBlobResult {
  /**
   * Location of the audience blob.
  */
  url?: string;
}

/**
 * List of device properties.
*/
export interface AudienceDevicePropertiesListResult {
  /**
   * List of device properties.
  */
  values: { [propertyName: string]: string };
}

/**
 * List of device property values.
*/
export interface AudienceDevicePropertyValuesListResult {
  /**
   * List of device property values.
  */
  values: string[];
}

export interface CrashCountsCrashesItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface CrashCounts {
  /**
   * Total crash count.
  */
  count?: number;
  /**
   * The total crash count for day.
  */
  crashes?: CrashCountsCrashesItem[];
}

export interface ActiveDeviceCountsDailyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface ActiveDeviceCountsWeeklyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface ActiveDeviceCountsMonthlyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface ActiveDeviceCounts {
  /**
   * The active device count for each interval.
  */
  daily?: ActiveDeviceCountsDailyItem[];
  /**
   * The active device count for each interval with a week's retention.
  */
  weekly?: ActiveDeviceCountsWeeklyItem[];
  /**
   * The active device count for each interval with a month's retention.
  */
  monthly?: ActiveDeviceCountsMonthlyItem[];
}

/**
 * The place code and the count.
*/
export interface PlacesPlacesItem {
  /**
   * The place code.
  */
  code?: string;
  /**
   * The count of the this place.
  */
  count?: number;
  /**
   * The count of previous time range of the place.
  */
  previousCount?: number;
}

/**
 * Places and count during the time range in descending order.
*/
export interface Places {
  total?: number;
  places?: PlacesPlacesItem[];
}

/**
 * The place code and the count.
*/
export interface Place {
  /**
   * The place code.
  */
  code?: string;
  /**
   * The count of the this place.
  */
  count?: number;
  /**
   * The count of previous time range of the place.
  */
  previousCount?: number;
}

export interface ErrorError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface ErrorModel {
  error?: ErrorError;
}

export interface SessionDurationsDistributionDistributionItem {
  /**
   * The bucket name.
  */
  bucket?: string;
  /**
   * The count of sessions in current bucket.
  */
  count?: number;
}

export interface SessionDurationsDistribution {
  /**
   * The count of sessions in these buckets.
  */
  distribution?: SessionDurationsDistributionDistributionItem[];
  /**
   * The previous average session duration for previous time range.
  */
  previousAverageDuration?: string;
  /**
   * The average session duration for current time range.
  */
  averageDuration?: string;
}

export interface VersionsVersionsItem {
  /**
   * Version.
  */
  version?: string;
  /**
   * Version count.
  */
  count?: number;
  /**
   * The count of previous time range of the version.
  */
  previousCount?: number;
}

export interface Versions {
  /**
   * List of version count.
  */
  versions?: VersionsVersionsItem[];
  /**
   * The total count of versions.
  */
  total?: number;
}

export interface Version {
  /**
   * Version.
  */
  version?: string;
  /**
   * Version count.
  */
  count?: number;
  /**
   * The count of previous time range of the version.
  */
  previousCount?: number;
}

export interface SessionCountsItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface SessionsPerDeviceSessionsPerUserItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count.
  */
  count?: number;
}

export interface SessionsPerDevice {
  /**
   * Average seesion per user.
  */
  averageSessionsPerUser?: number;
  /**
   * Previous average session per user.
  */
  previousAverageSessionsPerUser?: number;
  /**
   * Total session per device count.
  */
  totalCount?: number;
  /**
   * Previous total count.
  */
  previousTotalCount?: number;
  /**
   * The session count for each interval per device.
  */
  sessionsPerUser?: SessionsPerDeviceSessionsPerUserItem[];
}

export interface AnalyticsModelsModelsItem {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count current of model.
  */
  count?: number;
  /**
   * Count of previous model.
  */
  previousCount?: number;
}

export interface AnalyticsModels {
  total?: number;
  modelsProperty?: AnalyticsModelsModelsItem[];
}

export interface Model {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count current of model.
  */
  count?: number;
  /**
   * Count of previous model.
  */
  previousCount?: number;
}

export interface LanguagesLanguagesItem {
  /**
   * Language's name.
  */
  languageName?: string;
  /**
   * Count current of language.
  */
  count?: number;
  /**
   * Count of previous lanugage.
  */
  previousCount?: number;
}

export interface Languages {
  total?: number;
  languages?: LanguagesLanguagesItem[];
}

export interface Language {
  /**
   * Language's name.
  */
  languageName?: string;
  /**
   * Count current of language.
  */
  count?: number;
  /**
   * Count of previous lanugage.
  */
  previousCount?: number;
}

export interface OSesOsesItem {
  /**
   * OS name.
  */
  osName?: string;
  /**
   * Count current of OS.
  */
  count?: number;
  /**
   * Count of previous OS.
  */
  previousCount?: number;
}

export interface OSes {
  total?: number;
  oses?: OSesOsesItem[];
}

export interface OS {
  /**
   * OS name.
  */
  osName?: string;
  /**
   * Count current of OS.
  */
  count?: number;
  /**
   * Count of previous OS.
  */
  previousCount?: number;
}

export interface DateTimeCounts {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface DateTimeDecimalCounts {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Decimal count of the object.
  */
  count?: number;
}

export interface AvailableVersions {
  /**
   * List of available versions.
  */
  versions?: string[];
  /**
   * The full number of versions across all pages.
  */
  totalCount?: number;
}

export interface AvailableAppBuilds {
  /**
   * List of available app builds.
  */
  appBuilds?: string[];
}

export interface CrashFreeDevicePercentagesDailyPercentagesItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Percentage of the object.
  */
  percentage?: number;
}

export interface CrashFreeDevicePercentages {
  /**
   * Average percentage.
  */
  averagePercentage?: number;
  /**
   * The crash-free percentage per day.
  */
  dailyPercentages?: CrashFreeDevicePercentagesDailyPercentagesItem[];
}

export interface Modules {
  modules?: { [propertyName: string]: { [propertyName: string]: boolean } };
}

export interface DateTimePercentages {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Percentage of the object.
  */
  percentage?: number;
}

export interface CrashesOverallItemOverall {
  crashCount?: number;
  deviceCount?: number;
}

export interface CrashesOverallItem {
  crashGroupId?: string;
  appVersion?: string;
  overall?: CrashesOverallItemOverall;
}

export interface CrashOverall {
  crashCount?: number;
  deviceCount?: number;
}

export interface CrashGroupModelsModelsItem {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count of model.
  */
  crashCount?: number;
}

export interface CrashGroupModels {
  crashCount?: number;
  modelsProperty?: CrashGroupModelsModelsItem[];
}

export interface CrashGroupModel {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count of model.
  */
  crashCount?: number;
}

export interface CrashGroupOperatingSystemsOperatingSystemsItem {
  /**
   * OS name.
  */
  operatingSystemName?: string;
  /**
   * Count of OS.
  */
  crashCount?: number;
}

export interface CrashGroupOperatingSystems {
  crashCount?: number;
  operatingSystems?: CrashGroupOperatingSystemsOperatingSystemsItem[];
}

export interface CrashGroupOperatingSystem {
  /**
   * OS name.
  */
  operatingSystemName?: string;
  /**
   * Count of OS.
  */
  crashCount?: number;
}

export interface CrashGroupPlacesPlacesItem {
  /**
   * Place name.
  */
  placeName?: string;
  /**
   * Count of places.
  */
  crashCount?: number;
}

export interface CrashGroupPlaces {
  crashCount?: number;
  places?: CrashGroupPlacesPlacesItem[];
}

export interface CrashGroupPlace {
  /**
   * Place name.
  */
  placeName?: string;
  /**
   * Count of places.
  */
  crashCount?: number;
}

export interface CrashGroupLanguagesLanguagesItem {
  /**
   * Language name.
  */
  languageName?: string;
  /**
   * Count of languages.
  */
  crashCount?: number;
}

export interface CrashGroupLanguages {
  crashCount?: number;
  languages?: CrashGroupLanguagesLanguagesItem[];
}

export interface CrashGroupLanguage {
  /**
   * Language name.
  */
  languageName?: string;
  /**
   * Count of languages.
  */
  crashCount?: number;
}

export interface CrashGroupCarriersCarriersItem {
  /**
   * Carrier name.
  */
  carrierName?: string;
  /**
   * Crash count of carrier.
  */
  crashCount?: number;
}

export interface CrashGroupCarriers {
  crashCount?: number;
  carriers?: CrashGroupCarriersCarriersItem[];
}

export interface CrashGroupCarrier {
  /**
   * Carrier name.
  */
  carrierName?: string;
  /**
   * Crash count of carrier.
  */
  crashCount?: number;
}

export interface CrashGroupContainerCrashGroupsItem {
  crashGroupId?: string;
  appVersion?: string;
}

export interface CrashGroupContainer {
  crashGroups: CrashGroupContainerCrashGroupsItem[];
}

export interface CrashGroupAndVersion {
  crashGroupId?: string;
  appVersion?: string;
}

export interface EventsEventsItem {
  id?: string;
  name?: string;
  deviceCount?: number;
  /**
   * The device count of previous time range of the event.
  */
  previousDeviceCount?: number;
  count?: number;
  /**
   * The event count of previous time range of the event.
  */
  previousCount?: number;
  countPerDevice?: number;
  countPerSession?: number;
}

export interface Events {
  events?: EventsEventsItem[];
  /**
   * The total count of events.
  */
  total?: number;
  /**
   * The active device over this period.
  */
  totalDevices?: number;
}

export interface Event {
  id?: string;
  name?: string;
  deviceCount?: number;
  /**
   * The device count of previous time range of the event.
  */
  previousDeviceCount?: number;
  count?: number;
  /**
   * The event count of previous time range of the event.
  */
  previousCount?: number;
  countPerDevice?: number;
  countPerSession?: number;
}

export interface EventCountCountItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface EventCount {
  totalCount?: number;
  previousTotalCount?: number;
  count?: EventCountCountItem[];
}

export interface EventDeviceCountDevicesCountItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface EventDeviceCount {
  totalDevices?: number;
  totalDevicesWithEvent?: number;
  previousTotalDevicesWithEvent?: number;
  devicesCount?: EventDeviceCountDevicesCountItem[];
}

export interface EventCountPerDeviceCountPerDeviceItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Decimal count of the object.
  */
  count?: number;
}

export interface EventCountPerDevice {
  avgCountPerDevice?: number;
  previousAvgCountPerDevice?: number;
  countPerDevice?: EventCountPerDeviceCountPerDeviceItem[];
}

export interface EventCountPerSessionCountPerSessionItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Decimal count of the object.
  */
  count?: number;
}

export interface EventCountPerSession {
  avgCountPerSession?: number;
  previousAvgCountPerSession?: number;
  countPerSession?: EventCountPerSessionCountPerSessionItem[];
}

/**
 * Event properties during the time range.
*/
export interface EventProperties {
  eventProperties?: string[];
}

/**
 * An event property value with counts.
*/
export interface EventPropertyValuesValuesItem {
  /**
   * The event property value name.
  */
  name?: string;
  /**
   * The count of the the event property value.
  */
  count?: number;
  /**
   * The count of previous time range of the event property value.
  */
  previousCount?: number;
}

/**
 * Event property value counts during the time range in descending order.
*/
export interface EventPropertyValues {
  /**
   * The total property value counts.
  */
  total?: number;
  /**
   * The event property values.
  */
  values?: EventPropertyValuesValuesItem[];
}

/**
 * An event property value with counts.
*/
export interface EventPropertyValue {
  /**
   * The event property value name.
  */
  name?: string;
  /**
   * The count of the the event property value.
  */
  count?: number;
  /**
   * The count of previous time range of the event property value.
  */
  previousCount?: number;
}

export interface NotifyReleasesContainerReleasesItem {
  /**
   * Release Id.

  */
  release: string;
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
  /**
   * Unique user Id.  Will generate a new user Id if not provided.

  */
  userId?: string;
}

export interface NotifyReleasesContainer {
  releases: NotifyReleasesContainerReleasesItem[];
}

export interface DeleteReleasesContainerReleasesItem {
  /**
   * Release Id.

  */
  release: string;
}

export interface DeleteReleasesContainer {
  releases: DeleteReleasesContainerReleasesItem[];
}

export interface GetReleasesContainerReleasesItem {
  /**
   * Release Id.

  */
  release: string;
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
}

export interface GetReleasesContainer {
  releases: GetReleasesContainerReleasesItem[];
}

export interface FilterReleasesContainerReleasesItem {
  /**
   * Release Id.

  */
  release: string;
}

export interface FilterReleasesContainer {
  releases?: FilterReleasesContainerReleasesItem[];
}

export interface FilterVersionsContainerVersionsItem {
  /**
   * App version.

  */
  version: string;
  /**
   * App build number.

  */
  build: string;
}

export interface FilterVersionsContainer {
  versions?: FilterVersionsContainerVersionsItem[];
}

export interface Release {
  /**
   * Release Id.

  */
  release: string;
}

export interface ReleaseWithDistributionGroup {
  /**
   * Release Id.

  */
  release: string;
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
}

export interface ReleaseWithDistributionGroupAndUserId {
  /**
   * Release Id.

  */
  release: string;
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
  /**
   * Unique user Id.  Will generate a new user Id if not provided.

  */
  userId?: string;
}

export interface ReleaseCountsCountsItem {
  releaseId: string;
  /**
   * Distribution group queried.

  */
  distributionGroup?: string;
  /**
   * Count of unique downloads against user id.

  */
  uniqueCount: number;
  /**
   * Total count of downloads.

  */
  totalCount: number;
}

export interface ReleaseCounts {
  total?: number;
  counts: ReleaseCountsCountsItem[];
}

export interface ReleaseDailySessionsSessionsItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  count?: number;
}

export interface ReleaseDailySessions {
  totalSessionCounts?: number;
  avgSessionsPerDay?: number;
  /**
   * Sessions per day.
  */
  sessions?: ReleaseDailySessionsSessionsItem[];
}

export interface DailySession {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  count?: number;
}

export interface DateTimeDownloadReleaseCountsCountsItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  total?: number;
  unique?: number;
}

export interface DateTimeDownloadReleaseCounts {
  total?: number;
  unique?: number;
  /**
   * Release counts per day.
  */
  counts?: DateTimeDownloadReleaseCountsCountsItem[];
}

export interface DateTimeDownloadReleaseCount {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  total?: number;
  unique?: number;
}

export interface ReleaseCount {
  releaseId: string;
  /**
   * Distribution group queried.

  */
  distributionGroup?: string;
  /**
   * Count of unique downloads against user id.

  */
  uniqueCount: number;
  /**
   * Total count of downloads.

  */
  totalCount: number;
}

/**
 * Device characteristics.
*/
export interface LogFlowLogContainerLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowLogContainerLogsItem {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowLogContainerLogsItemDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogFlowLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogFlowLogContainerLogsItem[];
}

/**
 * Device characteristics.
*/
export interface LogFlowGenericLogContainerLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface LogFlowGenericLogContainerLogsItem {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: LogFlowGenericLogContainerLogsItemDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

export interface LogFlowGenericLogContainer {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogFlowGenericLogContainerLogsItem[];
}

/**
 * Device characteristics.
*/
export interface LogFlowGenericLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface LogFlowGenericLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: LogFlowGenericLogDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowLog {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowLogDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowLogWithPropertiesDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowLogWithProperties {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowLogWithPropertiesDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Device characteristics.
*/
export interface LogFlowDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowStartSessionLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface LogFlowStartSessionLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowStartSessionLogDevice;
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowStartServiceLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface LogFlowStartServiceLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowStartServiceLogDevice;
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

/**
 * Device characteristics.
*/
export interface LogFlowCustomPropertyLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowCustomPropertyLogPropertiesItem {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface LogFlowCustomPropertyLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowCustomPropertyLogDevice;
  /**
   * Custom property changes.
  */
  properties?: LogFlowCustomPropertyLogPropertiesItem[];
}

export interface LogFlowCustomProperty {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * String property.
*/
export interface LogFlowStringProperty {
  type: string;
  name: string;
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface LogFlowNumberProperty {
  type: string;
  name: string;
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface LogFlowBooleanProperty {
  type: string;
  name: string;
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface LogFlowDateTimeProperty {
  type: string;
  name: string;
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface LogFlowClearProperty {
  type: string;
  name: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowPageLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Page view log (as in screens or activities).
*/
export interface LogFlowPageLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowPageLogDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowEventLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Event log.
*/
export interface LogFlowEventLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowEventLogDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowPushInstallationLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Push installation Information.
*/
export interface LogFlowPushInstallationLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowPushInstallationLogDevice;
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Device characteristics.
*/
export interface LogFlowErrorLogDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Error log.
*/
export interface LogFlowErrorLog {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowErrorLogDevice;
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

export interface ErrorGroupsErrorGroupsItemReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorGroupsErrorGroupsItem {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: ErrorGroupsErrorGroupsItemReasonFramesItem[];
  hidden?: boolean;
}

export interface ErrorGroups {
  nextLink?: string;
  errorGroups?: ErrorGroupsErrorGroupsItem[];
}

export interface ErrorGroupsSearchResultErrorGroupsItemReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorGroupsSearchResultErrorGroupsItem {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: ErrorGroupsSearchResultErrorGroupsItemReasonFramesItem[];
  hidden?: boolean;
}

export interface ErrorGroupsSearchResult {
  hasMoreResults?: boolean;
  errorGroups?: ErrorGroupsSearchResultErrorGroupsItem[];
}

export interface ErrorCountsErrorsItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface ErrorCounts {
  /**
   * total error count
  */
  count?: number;
  /**
   * the total error count for day
  */
  errors?: ErrorCountsErrorsItem[];
}

export interface ErrorGroupListItemReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorGroupListItem {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: ErrorGroupListItemReasonFramesItem[];
  hidden?: boolean;
}

export interface ErrorGroupReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorGroup {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: ErrorGroupReasonFramesItem[];
  hidden?: boolean;
}

export interface ErrorDateTimePercentages {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface ErrorDateTimeCounts {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface ErrorGroupState {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
}

export interface ErrorDownloadLink {
  link: string;
}

/**
 * a single frame of a stack trace
*/
export interface DiagnosticsExceptionFramesItem {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a exception
*/
export interface DiagnosticsException {
  /**
   * Reason of the exception
  */
  reason?: string;
  /**
   * Type of the exception (NSSomethingException, NullPointerException)
  */
  type?: string;
  /**
   * frames of the excetpion
  */
  frames: DiagnosticsExceptionFramesItem[];
  /**
   * relevant exception (crashed)
  */
  relevant?: boolean;
  innerExceptions?: DiagnosticsException[];
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
}

/**
 * a single frame of a stack trace
*/
export interface DiagnosticsThreadFramesItem {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

/**
 * a thread representation
*/
export interface DiagnosticsThread {
  /**
   * name of the thread
  */
  title: string;
  /**
   * frames of that thread
  */
  frames: DiagnosticsThreadFramesItem[];
  /**
   * potential additional exception happened in that thread (Last Exception Backtrace)
  */
  exception?: DiagnosticsException;
  /**
   * Shows if a thread is relevant or not. Is false if all frames are non relevant, otherwise true
  */
  relevant?: boolean;
  /**
   * SDK/Platform this thread is beeing generated from. Possible values include: 'ios', 'android',
   * 'xamarin', 'react-native', 'ndk', 'unity', 'other'
  */
  platform?: string;
  /**
   * True if this thread crashed
  */
  crashed?: boolean;
}

/**
 * a stacktrace in a processed and prettyfied way
*/
export interface DiagnosticsStackTrace {
  title?: string;
  reason?: string;
  threads?: DiagnosticsThread[];
  exception?: DiagnosticsException;
}

/**
 * a single frame of a stack trace
*/
export interface DiagnosticsStackFrame {
  /**
   * address of the frame
  */
  address?: string;
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Raw frame string
  */
  codeRaw: string;
  /**
   * Formatted frame string
  */
  codeFormatted: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * frame should be shown always
  */
  relevant?: boolean;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
}

export interface HandledErrorReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorFreeDevicePercentagesDailyPercentagesItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface ErrorFreeDevicePercentages {
  /**
   * Average percentage
  */
  averagePercentage?: number;
  /**
   * The error-free percentage per day.
  */
  dailyPercentages?: ErrorFreeDevicePercentagesDailyPercentagesItem[];
}

export interface HandledErrorsErrorsItem {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
}

export interface HandledErrors {
  nextLink?: string;
  /**
   * Errors list.
  */
  errors?: HandledErrorsErrorsItem[];
}

export interface ErrorsSearchResultErrorsItem {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
}

export interface ErrorsSearchResult {
  hasMoreResults?: boolean;
  errors?: ErrorsSearchResultErrorsItem[];
}

export interface HandledError {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
}

export interface HandledErrorDetailsReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface HandledErrorDetails {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
  name?: string;
  reasonFrames?: HandledErrorDetailsReasonFramesItem[];
  /**
   * Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.

  */
  appLaunchTimestamp?: Date;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Flag indicating if device is jailbroken

  */
  jailbreak?: boolean;
  properties?: { [propertyName: string]: string };
}

export interface ErrorDeleteCounter {
  appId?: string;
  errorGroupId?: string;
  errorId?: string;
  errorsDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

export interface ErrorLocation {
  uri?: string;
}

export interface ErrorAttachmentsItem {
  appId?: string;
  attachmentId?: string;
  crashId?: string;
  blobLocation?: string;
  contentType?: string;
  fileName?: string;
  createdTime?: Date;
  size?: number;
}

export interface ErrorAttachment {
  appId?: string;
  attachmentId?: string;
  crashId?: string;
  blobLocation?: string;
  contentType?: string;
  fileName?: string;
  createdTime?: Date;
  size?: number;
}

export interface ErrorAppBuilds {
  appBuilds?: string[];
}

export interface ErrorAttachmentText {
  content?: string;
}

export interface ErrorAttachmentLocation {
  uri?: string;
}

export interface ErrorGroupModelsModelsItem {
  /**
   * model name
  */
  modelName?: string;
  /**
   * model code
  */
  modelCode?: string;
  /**
   * count of errors in a model
  */
  errorCount?: number;
}

export interface ErrorGroupModels {
  errorCount?: number;
  modelsProperty?: ErrorGroupModelsModelsItem[];
}

export interface ErrorGroupModel {
  /**
   * model name
  */
  modelName?: string;
  /**
   * model code
  */
  modelCode?: string;
  /**
   * count of errors in a model
  */
  errorCount?: number;
}

export interface ErrorGroupOperatingSystemsOperatingSystemsItem {
  /**
   * OS name
  */
  operatingSystemName?: string;
  /**
   * count of OS
  */
  errorCount?: number;
}

export interface ErrorGroupOperatingSystems {
  errorCount?: number;
  operatingSystems?: ErrorGroupOperatingSystemsOperatingSystemsItem[];
}

export interface ErrorGroupOperatingSystem {
  /**
   * OS name
  */
  operatingSystemName?: string;
  /**
   * count of OS
  */
  errorCount?: number;
}

/**
 * Device characteristics.
*/
export interface GenericLogContainerDiagnosticsLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLogContainerDiagnosticsLogsItem {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: GenericLogContainerDiagnosticsLogsItemDevice;
}

export interface GenericLogContainerDiagnostics {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: GenericLogContainerDiagnosticsLogsItem[];
}

/**
 * Device characteristics.
*/
export interface GenericLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: GenericLogDiagnosticsDevice;
}

/**
 * Device characteristics.
*/
export interface LogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogDiagnostics {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogDiagnosticsDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Device characteristics.
*/
export interface LogWithPropertiesDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogWithPropertiesDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogWithPropertiesDiagnosticsDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
}

/**
 * Device characteristics.
*/
export interface DeviceDiagnostics {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Device characteristics.
*/
export interface StartSessionLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface StartSessionLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: StartSessionLogDiagnosticsDevice;
  /**
   * Session ID.

  */
  sessionId: string;
}

/**
 * Device characteristics.
*/
export interface HanledErrorLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Required explicit begin session log (a marker event for analytics service).
*/
export interface HanledErrorLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: HanledErrorLogDiagnosticsDevice;
  /**
   * Error ID.

  */
  errorId: string;
}

/**
 * Device characteristics.
*/
export interface StartServiceLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Describe a AppCenter.Start API call from the SDK.
*/
export interface StartServiceLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: StartServiceLogDiagnosticsDevice;
  /**
   * The list of services of the AppCenter Start API call.
  */
  services?: string[];
}

/**
 * Device characteristics.
*/
export interface CustomPropertyLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface CustomPropertyLogDiagnosticsPropertiesItem {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Set or remove custom properties.
*/
export interface CustomPropertyLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: CustomPropertyLogDiagnosticsDevice;
  /**
   * Custom property changes.
  */
  properties?: CustomPropertyLogDiagnosticsPropertiesItem[];
}

export interface CustomPropertyDiagnostics {
  name: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * String property.
*/
export interface StringPropertyDiagnostics {
  type: string;
  name: string;
  /**
   * String property value.
  */
  value: string;
}

/**
 * Number property.
*/
export interface NumberPropertyDiagnostics {
  type: string;
  name: string;
  /**
   * Number property value.
  */
  value: number;
}

/**
 * Boolean property.
*/
export interface BooleanPropertyDiagnostics {
  type: string;
  name: string;
  /**
   * Boolean property value.
  */
  value: boolean;
}

/**
 * Date and time property.
*/
export interface DateTimePropertyDiagnostics {
  type: string;
  name: string;
  /**
   * Date time property value.
  */
  value: Date;
}

/**
 * Clear an existing property.
*/
export interface ClearPropertyDiagnostics {
  type: string;
  name: string;
}

/**
 * Device characteristics.
*/
export interface PageLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Page view log (as in screens or activities).
*/
export interface PageLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: PageLogDiagnosticsDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Name of the page.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface EventLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Event log.
*/
export interface EventLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: EventLogDiagnosticsDevice;
  /**
   * Additional key/value pair parameters.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Unique identifier for this event.

  */
  id: string;
  /**
   * Name of the event.

  */
  name: string;
}

/**
 * Device characteristics.
*/
export interface PushInstallationLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Push installation Information.
*/
export interface PushInstallationLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: PushInstallationLogDiagnosticsDevice;
  /**
   * The PNS handle for this installation.

  */
  pushToken: string;
}

/**
 * Device characteristics.
*/
export interface ErrorLogDiagnosticsDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Error log.
*/
export interface ErrorLogDiagnostics {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: ErrorLogDiagnosticsDevice;
  /**
   * Session ID.

  */
  sessionId: string;
  /**
   * Error identifier.
  */
  id: string;
  /**
   * Corresponds to the number of milliseconds elapsed between the time the error occurred and the
   * app was launched.

  */
  appLaunchToffset?: number;
}

export interface VersionsDiagnosticsVersionsItem {
  /**
   * version
  */
  version?: string;
  /**
   * version count
  */
  count?: number;
  /**
   * the count of previous time range of the version
  */
  previousCount?: number;
}

export interface VersionsDiagnostics {
  /**
   * list of version count
  */
  versions?: VersionsDiagnosticsVersionsItem[];
  /**
   * the total count of versions
  */
  total?: number;
}

export interface VersionDiagnostics {
  /**
   * version
  */
  version?: string;
  /**
   * version count
  */
  count?: number;
  /**
   * the count of previous time range of the version
  */
  previousCount?: number;
}

export interface AvailableVersionsDiagnostics {
  /**
   * List of available versions.
  */
  versions?: string[];
  /**
   * The full number of versions across all pages.
  */
  totalCount?: number;
}

export interface ErrorRetentionSettings {
  retentionInDays: number;
}

/**
 * Export configuration
*/
export interface ExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Configuration for export to Blob Storage with blob format
*/
export interface ExportBlobConfiguration {
  /**
   * Type of export configuration. Possible values include: 'blob_storage_connection_string',
   * 'application_insights_instrumentation_key', 'blob_storage_linked_subscription',
   * 'application_insights_linked_subscription'
  */
  type: string;
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when
   * set to 'WithAppId' is 'appId/year/month/day/hour/minute'. Possible values include:
   * 'WithoutAppId', 'WithAppId'
  */
  blobPathFormatKind?: string;
}

/**
 * Configuration for export to Blob Storage with customer provided connection string
*/
export interface ExportConfigurationBlobStorageConnectionString {
  /**
   * Type of export configuration. Possible values include: 'blob_storage_connection_string',
   * 'application_insights_instrumentation_key', 'blob_storage_linked_subscription',
   * 'application_insights_linked_subscription'
  */
  type: string;
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when
   * set to 'WithAppId' is 'appId/year/month/day/hour/minute'. Possible values include:
   * 'WithoutAppId', 'WithAppId'
  */
  blobPathFormatKind?: string;
  /**
   * Connection string for blob storage account
  */
  connectionString: string;
}

/**
 * Configuration for export to Application Insights resource with customer provided intrumentation
 * key
*/
export interface ExportConfigurationAppInsightsKey {
  /**
   * Type of export configuration. Possible values include: 'blob_storage_connection_string',
   * 'application_insights_instrumentation_key', 'blob_storage_linked_subscription',
   * 'application_insights_linked_subscription'
  */
  type: string;
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Instrumentation key for Application Insights resource
  */
  instrumentationKey: string;
}

/**
 * Configuration for export to Blob Storage with customer linked subscription.
*/
export interface ExportConfigurationBlobStorageLinkedSubscription {
  /**
   * Type of export configuration. Possible values include: 'blob_storage_connection_string',
   * 'application_insights_instrumentation_key', 'blob_storage_linked_subscription',
   * 'application_insights_linked_subscription'
  */
  type: string;
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * The path to the blob when enum set to 'WithoutAppId' is 'year/month/day/hour/minute' and when
   * set to 'WithAppId' is 'appId/year/month/day/hour/minute'. Possible values include:
   * 'WithoutAppId', 'WithAppId'
  */
  blobPathFormatKind?: string;
  /**
   * Id of customer subscription linked in App Center
  */
  subscriptionId: string;
}

/**
 * Configuration for export to Application Insights resource with customer linked subscription.
*/
export interface ExportConfigurationAppInsightsLinkedSubscription {
  /**
   * Type of export configuration. Possible values include: 'blob_storage_connection_string',
   * 'application_insights_instrumentation_key', 'blob_storage_linked_subscription',
   * 'application_insights_linked_subscription'
  */
  type: string;
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Id of customer subscription linked in App Center
  */
  subscriptionId: string;
}

/**
 * Export configuration
*/
export interface ExportConfigurationResultExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface ExportConfigurationResult {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: ExportConfigurationResultExportConfiguration;
}

/**
 * Export configuration
*/
export interface ExportConfigurationListResultValuesItemExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface ExportConfigurationListResultValuesItem {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: ExportConfigurationListResultValuesItemExportConfiguration;
}

/**
 * List of export configurations
*/
export interface ExportConfigurationListResult {
  values: ExportConfigurationListResultValuesItem[];
  /**
   * the total count of exports
  */
  total?: number;
  nextLink?: string;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface NotificationsListResultValuesItemNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification statistics
*/
export interface NotificationsListResultValuesItem {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: NotificationsListResultValuesItemNotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
}

/**
 * List of notifications
*/
export interface NotificationsListResult {
  values: NotificationsListResultValuesItem[];
  /**
   * the total count of notifications
  */
  total?: number;
  nextLink?: string;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface NotificationOverviewResultNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification statistics
*/
export interface NotificationOverviewResult {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: NotificationOverviewResultNotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface NotificationDetailsResultNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification definition object
*/
export interface NotificationDetailsResultNotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body?: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification failure outcome count
*/
export interface NotificationDetailsResultFailureOutcomesItem {
  /**
   * The reason of the notification failure
  */
  failureReason?: string;
  /**
   * count of this type of failure
  */
  count?: number;
}

/**
 * Notification statistics
*/
export interface NotificationDetailsResult {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: NotificationDetailsResultNotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
  /**
   * Notification definition object
  */
  notificationContent: NotificationDetailsResultNotificationContent;
  /**
   * Failture outcome counts
  */
  failureOutcomes?: NotificationDetailsResultFailureOutcomesItem[];
}

/**
 * List of notification Ids
*/
export interface NotificationIdList {
  /**
   * List of notification Ids.
  */
  values: string[];
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface NotificationDefinitionNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification definition object
*/
export interface NotificationDefinitionNotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body?: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification definition object
*/
export interface NotificationDefinition {
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: NotificationDefinitionNotificationTarget;
  /**
   * Notification definition object
  */
  notificationContent: NotificationDefinitionNotificationContent;
}

/**
 * Notification definition object
*/
export interface NotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body?: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification send succeeded.
*/
export interface NotificationSendSucceededResult {
  /**
   * The unique notification identifier.
  */
  notificationId: string;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface NotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Broadcast notification to all the devices
*/
export interface NotificationTargetBroadcast {
  /**
   * Possible values include: 'audiences_target', 'devices_target', 'user_ids_target',
   * 'account_ids_target', 'broadcast_target'
  */
  type: string;
}

/**
 * Notification per User IDs
*/
export interface NotificationTargetUserIds {
  /**
   * Possible values include: 'audiences_target', 'devices_target', 'user_ids_target',
   * 'account_ids_target', 'broadcast_target'
  */
  type: string;
  /**
   * List of user IDs to target
  */
  userIds: string[];
}

/**
 * Notification per Account IDs
*/
export interface NotificationTargetAccountIds {
  /**
   * Possible values include: 'audiences_target', 'devices_target', 'user_ids_target',
   * 'account_ids_target', 'broadcast_target'
  */
  type: string;
  /**
   * List of account IDs to target
  */
  accountIds: string[];
}

/**
 * Notification target audiences.
*/
export interface NotificationTargetAudiences {
  /**
   * Possible values include: 'audiences_target', 'devices_target', 'user_ids_target',
   * 'account_ids_target', 'broadcast_target'
  */
  type: string;
  /**
   * List of target audiences.
  */
  audiences: string[];
}

/**
 * Notification target devices. If null, all devices will be targeted(broadcast).
*/
export interface NotificationTargetDevices {
  /**
   * Possible values include: 'audiences_target', 'devices_target', 'user_ids_target',
   * 'account_ids_target', 'broadcast_target'
  */
  type: string;
  /**
   * List of target devices.
  */
  devices: string[];
}

/**
 * Type of notification config (NotificationConfigAppleToken, NotificationConfigGoogle,
 * NotificationConfigWindows). The 'type' property must be set to a valid value and the object must
 * include the correct properties for the specified type.
*/
export interface NotificationConfig {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Apple notification certificate configuration.
*/
export interface NotificationConfigApple {
  /**
   * Possible values include: 'apns_token_config', 'gcm_config', 'wns_config'
  */
  type: string;
  /**
   * Type of endpoint the certificate or token are associated with. Possible values include:
   * 'production', 'sandbox'
  */
  endpointType: string;
  /**
   * Base64 encoded certificate string.
  */
  certEncoded: string;
  /**
   * Certificate file name
  */
  certFilename: string;
  /**
   * Certificate password
  */
  certKey: string;
}

/**
 * Apple notification auth token configuration. The 'type' property must be set to
 * 'apns_token_config'.
*/
export interface NotificationConfigAppleToken {
  /**
   * Possible values include: 'apns_token_config', 'gcm_config', 'wns_config'
  */
  type: string;
  /**
   * A 10-character key identifier (kid).
  */
  keyId: string;
  /**
   * Application ID.
  */
  id: string;
  /**
   * Application prefix.
  */
  prefix: string;
  /**
   * Provider Authentication Token.
  */
  token: string;
  /**
   * Type of endpoint the certificate or token are associated with. Possible values include:
   * 'production', 'sandbox'
  */
  endpointType: string;
}

/**
 * Google notification configuration. The 'type' property must be set to 'gcm_config'
*/
export interface NotificationConfigGoogle {
  /**
   * Possible values include: 'apns_token_config', 'gcm_config', 'wns_config'
  */
  type: string;
  /**
   * GCM API key.
  */
  googleApiKey: string;
}

/**
 * WNS notification configuration. The 'type' property must be set to 'wns_config'
*/
export interface NotificationConfigWindows {
  /**
   * Possible values include: 'apns_token_config', 'gcm_config', 'wns_config'
  */
  type: string;
  /**
   * Package security identifier (SID).
  */
  packageSid: string;
  /**
   * Secret key.
  */
  secretKey: string;
}

/**
 * Generic notification configuration result.
*/
export interface NotificationConfigResult {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Apple notification certificate configuration result.
*/
export interface NotificationConfigAppleResult {
  type: string;
  /**
   * Type of endpoint the certificate or token are associated with. Possible values include:
   * 'production', 'sandbox'
  */
  endpointType: string;
  /**
   * Certificate expiration date.
  */
  certExpiration: Date;
  /**
   * Certificate file name
  */
  certFilename: string;
}

/**
 * Apple notification auth token configuration result.
*/
export interface NotificationConfigAppleTokenResult {
  type: string;
  /**
   * A 10-character key identifier (kid).
  */
  keyId: string;
  /**
   * Application ID.
  */
  id: string;
  /**
   * Application Prefix.
  */
  prefix: string;
  /**
   * Type of endpoint the certificate or token are associated with. Possible values include:
   * 'production', 'sandbox'
  */
  endpointType: string;
}

/**
 * Google notification configuration result.
*/
export interface NotificationConfigGoogleResult {
  type: string;
  /**
   * GCM API key.
  */
  googleApiKey: string;
}

/**
 * WNS notification configuration result.
*/
export interface NotificationConfigWindowsResult {
  type: string;
  /**
   * Package security identifier (SID).
  */
  packageSid: string;
  /**
   * windows push configuration secret key.
  */
  secretKey?: string;
}

/**
 * Notification failure outcome count
*/
export interface NotificationFailureOutcomeCount {
  /**
   * The reason of the notification failure
  */
  failureReason?: string;
  /**
   * count of this type of failure
  */
  count?: number;
}

/**
 * Generic export configuration.
*/
export interface ExportConfig {
  /**
   * A shared access signature (SAS) URI with Read, Write and Delete permissions on a container.
  */
  blobContainerSasUri: string;
}

/**
 * Export started.
*/
export interface ExportStartedResult {
  /**
   * The unique export identifier.
  */
  exportId: string;
}

/**
 * Export status
*/
export interface ExportStatusResult {
  /**
   * The unique export identifier.
  */
  exportId: string;
  /**
   * Status of the export. Possible values include: 'InProgress', 'Completed', 'Failed'
  */
  status: string;
}

export interface AppId {
  /**
   * the id of the app
  */
  id?: string;
}

export interface DeviceConfigurationImage {
  full?: string;
  thumb?: string;
}

/**
 * Physical device dimensions
*/
export interface DeviceConfigurationModelDimensions {
  depth?: any;
  height?: any;
  width?: any;
}

/**
 * Device screen resolution
*/
export interface DeviceConfigurationModelResolution {
  height?: string;
  width?: string;
  ppi?: string;
}

/**
 * Physical device screen dimensions
*/
export interface DeviceConfigurationModelScreenSize {
  cm?: string;
  inProperty?: string;
}

/**
 * CPU data for device
*/
export interface DeviceConfigurationModelCpu {
  frequency?: string;
  core?: string;
  text?: string;
}

/**
 * Memory data for device
*/
export interface DeviceConfigurationModelMemory {
  formattedSize?: string;
}

export interface DeviceConfigurationModelDeviceFrameGrid {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceConfigurationModelDeviceFrameFull {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceConfigurationModelDeviceFrame {
  grid?: DeviceConfigurationModelDeviceFrameGrid;
  full?: DeviceConfigurationModelDeviceFrameFull;
}

export interface DeviceConfigurationModel {
  name?: string;
  manufacturer?: string;
  model?: string;
  platform?: string;
  /**
   * Physical device dimensions
  */
  dimensions?: DeviceConfigurationModelDimensions;
  /**
   * Device screen resolution
  */
  resolution?: DeviceConfigurationModelResolution;
  releaseDate?: string;
  formFactor?: string;
  /**
   * Physical device screen dimensions
  */
  screenSize?: DeviceConfigurationModelScreenSize;
  /**
   * CPU data for device
  */
  cpu?: DeviceConfigurationModelCpu;
  /**
   * Memory data for device
  */
  memory?: DeviceConfigurationModelMemory;
  screenRotation?: number;
  deviceFrame?: DeviceConfigurationModelDeviceFrame;
  availabilityCount?: number;
}

export interface DeviceConfiguration {
  /**
   * The name of the device model and OS version
  */
  name?: string;
  /**
   * The unique id of the device configuration
  */
  id?: string;
  /**
   * The tier
  */
  tier?: number;
  image?: DeviceConfigurationImage;
  model?: DeviceConfigurationModel;
  os?: string;
  osName?: string;
  marketShare?: number;
}

export interface DeviceSetConfigurationImage {
  thumb?: string;
}

export interface DeviceSetConfigurationModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface DeviceSetConfiguration {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: DeviceSetConfigurationImage;
  model?: DeviceSetConfigurationModel;
  os?: string;
  osName?: string;
}

/**
 * Physical device dimensions
*/
export interface DeviceModelDimensions {
  depth?: any;
  height?: any;
  width?: any;
}

/**
 * Device screen resolution
*/
export interface DeviceModelResolution {
  height?: string;
  width?: string;
  ppi?: string;
}

/**
 * Physical device screen dimensions
*/
export interface DeviceModelScreenSize {
  cm?: string;
  inProperty?: string;
}

/**
 * CPU data for device
*/
export interface DeviceModelCpu {
  frequency?: string;
  core?: string;
  text?: string;
}

/**
 * Memory data for device
*/
export interface DeviceModelMemory {
  formattedSize?: string;
}

export interface DeviceModelDeviceFrameGrid {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceModelDeviceFrameFull {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceModelDeviceFrame {
  grid?: DeviceModelDeviceFrameGrid;
  full?: DeviceModelDeviceFrameFull;
}

export interface DeviceModel {
  name?: string;
  manufacturer?: string;
  model?: string;
  platform?: string;
  /**
   * Physical device dimensions
  */
  dimensions?: DeviceModelDimensions;
  /**
   * Device screen resolution
  */
  resolution?: DeviceModelResolution;
  releaseDate?: string;
  formFactor?: string;
  /**
   * Physical device screen dimensions
  */
  screenSize?: DeviceModelScreenSize;
  /**
   * CPU data for device
  */
  cpu?: DeviceModelCpu;
  /**
   * Memory data for device
  */
  memory?: DeviceModelMemory;
  screenRotation?: number;
  deviceFrame?: DeviceModelDeviceFrame;
  availabilityCount?: number;
}

export interface DeviceSetModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

/**
 * Physical device screen dimensions
*/
export interface DeviceScreenSize {
  cm?: string;
  inProperty?: string;
}

/**
 * Device screen resolution
*/
export interface DeviceResolution {
  height?: string;
  width?: string;
  ppi?: string;
}

/**
 * Physical device dimensions
*/
export interface DeviceDimensions {
  depth?: any;
  height?: any;
  width?: any;
}

/**
 * CPU data for device
*/
export interface DeviceCpu {
  frequency?: string;
  core?: string;
  text?: string;
}

/**
 * Memory data for device
*/
export interface DeviceMemory {
  formattedSize?: string;
}

export interface DeviceFrameGrid {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceFrameFull {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface DeviceFrame {
  grid?: DeviceFrameGrid;
  full?: DeviceFrameFull;
}

export interface DeviceFrameDefinition {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface TestRunStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface TestRun {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: TestRunStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface TestRunStatistics {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface TestSeriesTestRunsItem {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Test Series
 * @description Summary of a single test series
*/
export interface TestSeries {
  /**
   * Unique, human-readable identifier of the test series
  */
  slug: string;
  /**
   * Name of the test series
  */
  name: string;
  /**
   * Date of the latest test run that used this test series
  */
  mostRecentActivity?: string;
  /**
   * Most recent test runs
  */
  testRuns?: TestSeriesTestRunsItem[];
}

/**
 * @summary Name of the test series
*/
export interface TestSeriesName {
  /**
   * Name of the new test series
  */
  name: string;
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface TestRunSummary {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Device List
 * @description A list of device IDs
*/
export interface DeviceList {
  devices: string[];
}

/**
 * @summary Device Selection
 * @description Short ID for a list of device IDs
*/
export interface DeviceSelection {
  /**
   * Identifier of the device selection
  */
  shortId: string;
}

/**
 * @summary Device Set update information
 * @description The name of the device set and the list of device IDs
*/
export interface DeviceSetUpdate {
  /**
   * List of device IDs
  */
  devices: string[];
  /**
   * The name of the device set
  */
  name: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface DeviceSetOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface DeviceSetDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface DeviceSetDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface DeviceSetDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: DeviceSetDeviceConfigurationsItemImage;
  model?: DeviceSetDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface DeviceSet {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: DeviceSetOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: DeviceSetDeviceConfigurationsItem[];
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface DeviceSetOwnerModel {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

/**
 * @summary Subscription Tier
*/
export interface SubscriptionTier {
  /**
   * The name of the tier
  */
  name?: string;
}

/**
 * @summary Subscription
 * @description Subscription information
*/
export interface Subscription {
  /**
   * The date the subscription began
  */
  startsAt?: string;
  /**
   * The date the subscription will end or ended
  */
  endsAt?: string;
  /**
   * The number of days left in the subscription
  */
  daysLeft?: number;
  /**
   * @summary Subscription Tier
  */
  tier?: SubscriptionTier;
  /**
   * Is the subscription currently active?
  */
  active?: boolean;
  /**
   * Id of the subscription
  */
  id?: string;
}

/**
 * @summary Subscription Tier
*/
export interface Tier {
  /**
   * The name of the tier
  */
  name?: string;
}

export interface TestReportStats {
  os: number;
  devices: number;
  filesize: number;
  totalDeviceMinutes: number;
  devicesNotRunned: number;
  failed: number;
  skipped: number;
  passed: number;
  total: number;
  devicesFinished: number;
  devicesFailed: number;
  devicesSkipped: number;
  stepCount: number;
  artifacts?: { [propertyName: string]: string };
}

export interface TestReportFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem {
  deviceSnapshotId?: string;
  status?: string;
  timestamp?: number;
}

export interface TestReportFeaturesItemTestsItemRunsItemStepsItem {
  stepName?: string;
  id?: string;
  stepExecutions?: TestReportFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem[];
  failed?: number;
  skipped?: number;
  stepReportUrl?: string;
}

export interface TestReportFeaturesItemTestsItemRunsItem {
  number?: number;
  steps?: TestReportFeaturesItemTestsItemRunsItemStepsItem[];
  failed?: number;
  skipped?: number;
  reportUrl?: string;
  id?: string;
}

export interface TestReportFeaturesItemTestsItem {
  testName?: string;
  runs?: TestReportFeaturesItemTestsItemRunsItem[];
  peakMemory?: number;
  peakDuration?: number;
}

export interface TestReportFeaturesItem {
  name?: string;
  tests?: TestReportFeaturesItemTestsItem[];
  failed?: number;
  skipped?: number;
  peakMemory?: number;
  peakDuration?: number;
}

export interface TestReportDeviceLogsItem {
  deviceSnapshotId?: string;
  deviceLog?: string;
  testLog?: string;
  appiumLog?: string;
}

export interface TestReportSnapshotFatalErrorsItem {
  deviceSnapshotId?: string;
  errorMessage?: string;
  errorTitle?: string;
}

export interface TestReport {
  appUploadId: string;
  date: string;
  testType: string;
  platform: string;
  stats: TestReportStats;
  id: string;
  schemaVersion: number;
  revision: number;
  features: TestReportFeaturesItem[];
  finishedDeviceSnapshots: string[];
  deviceLogs: TestReportDeviceLogsItem[];
  dateFinished: string;
  errorMessage?: string;
  snapshotFatalErrors?: TestReportSnapshotFatalErrorsItem[];
}

export interface StepReportDeviceScreenshotsItemScreenshotUrls {
  original: string;
  small: string;
  medium: string;
  large: string;
}

export interface StepReportDeviceScreenshotsItemScreenshot {
  urls: StepReportDeviceScreenshotsItemScreenshotUrls;
  rotation: number;
  landscape: boolean;
}

export interface StepReportDeviceScreenshotsItem {
  id?: string;
  deviceSnapshotId?: string;
  stacktrace?: string[];
  crashData?: string[];
  status?: string;
  title?: string;
  screenshot?: StepReportDeviceScreenshotsItemScreenshot;
  logFile?: string;
  appiumLogFile?: string;
  rawCrashData?: string[];
}

export interface StepReport {
  finishedSnapshots: string[];
  deviceScreenshots: StepReportDeviceScreenshotsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface TestCloudErrorDetails {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface TestCloudFileHashDeprecated {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
  /**
   * Range of bytes required to verify ownership of the file
  */
  byteRange?: string;
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface TestCloudFileHash {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
}

/**
 * @summary Test Cloud Hash Upload Status
 * @description Status of the upload
*/
export interface TestCloudFileHashResponseUploadStatus {
  /**
   * HTTP status code that represent result of upload
  */
  statusCode: number;
  /**
   * URI that should be used to make POST request if file with given hash doesn't exist. This is
   * set when status_code is equal to 412
  */
  location?: string;
}

/**
 * @summary Test Cloud File Hash Response
 * @description Response message for single uploaded file hash
*/
export interface TestCloudFileHashResponse {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath?: string;
  /**
   * @summary Test Cloud Hash Upload Status
   * @description Status of the upload
  */
  uploadStatus: TestCloudFileHashResponseUploadStatus;
}

/**
 * @summary Test Cloud Hash Upload Status
 * @description Result of uploading a single file hash
*/
export interface TestCloudHashUploadStatus {
  /**
   * HTTP status code that represent result of upload
  */
  statusCode: number;
  /**
   * URI that should be used to make POST request if file with given hash doesn't exist. This is
   * set when status_code is equal to 412
  */
  location?: string;
}

/**
 * @summary Test Cloud Start Test Run Options
 * @description Options required to start the test run
*/
export interface TestCloudStartTestRunOptions {
  /**
   * Test framework used by tests.
  */
  testFramework: string;
  /**
   * Device selection string.
  */
  deviceSelection: string;
  /**
   * Language that should be used to run tests.
  */
  language?: string;
  /**
   * Locale that should be used to run tests.
  */
  locale?: string;
  /**
   * Name of the test series.
  */
  testSeries?: string;
  /**
   * A JSON dictionary with additional test parameters
  */
  testParameters?: any;
}

/**
 * @summary Test Cloud Test Run Start Result
 * @description Result of starting a test run
*/
export interface TestCloudStartTestRunResult {
  /**
   * List with names of accepted devices
  */
  acceptedDevices?: string[];
  /**
   * List with names and descriptions of rejected devices
  */
  rejectedDevices?: string[];
}

/**
 * @summary Test Run State
 * @description Current status of a test run
*/
export interface TestRunState {
  /**
   * Multi-line message that describes the status
  */
  message?: string[];
  /**
   * Time (in seconds) that the client should wait for before checking the status again
  */
  waitTime?: number;
  /**
   * The exit code that the client should use when exiting. Used for indicating status to the
   * caller of the client.
   * 0: test run completes with no failing tests
   * 1: test run completes with at least one failing test
   * 2: test run failed to complete. Status for test run is unknown

  */
  exitCode?: number;
}

export interface PerformanceReportPerformanceDataStepsItemSamplesItem {
  cpu?: number;
  mem?: number;
  elapsedSecs?: number;
}

export interface PerformanceReportPerformanceDataStepsItem {
  avgCpu?: number;
  avgMem?: number;
  samples?: PerformanceReportPerformanceDataStepsItemSamplesItem[];
  elapsedSecsEnd?: number;
  elapsedSecsStart?: number;
  elapsedSecs?: number;
  name?: string;
  id?: string;
}

export interface PerformanceReportPerformanceData {
  steps: PerformanceReportPerformanceDataStepsItem[];
  elapsedSecsEnd: number;
  elapsedSecsStart: number;
  elapsedSecs: number;
  id: string;
}

export interface PerformanceReportVideoVideoMetadataEventsItem {
  id?: string;
  millis?: number;
  name?: string;
  type?: string;
}

export interface PerformanceReportVideoVideoMetadata {
  events?: PerformanceReportVideoVideoMetadataEventsItem[];
}

export interface PerformanceReportVideo {
  videoMetadata: PerformanceReportVideoVideoMetadata;
  videoUrl: string;
}

/**
 * @summary Performance Report
 * @description Report data for a single test (a.k.a. scenario)
*/
export interface PerformanceReport {
  deviceSnapshotId?: string;
  performanceData?: PerformanceReportPerformanceData;
  video?: PerformanceReportVideo;
}

export interface SubmitDsrOperationRequest {
  /**
   * Possible values include: 'Delete', 'Purge', 'UndoDelete', 'Export'
  */
  request?: string;
  accountId?: string;
  appId?: string;
  /**
   * The DSR operation ID provided by the GDPR coordinator. Used for tracking only.
  */
  operationId?: string;
  /**
   * Request ID provided by the GDPR coordinator. Used for tracking.
  */
  requestId?: string;
}

export interface SubmitDsrOperationResponse {
  /**
   * The status of the DSR operation. Possible values include: 'NotStarted', 'InProgress',
   * 'Completed', 'Failure'
  */
  status?: string;
}

export interface CreateGdprTestData {
  appId?: string;
  accountId?: string;
  userName?: string;
  userEmail?: string;
  appName?: string;
}

export interface TestGDPRAccount {
  id?: string;
}

export interface TestGDPRFeatureFlag {
  name?: string;
  targetId?: string;
}

export interface TestGDPRResourceListResourcesItem {
  rel?: string;
  path?: string;
}

export interface TestGDPRResourceList {
  resources?: TestGDPRResourceListResourcesItem[];
}

export interface TestGDPRApp {
  hashFilesUrl?: string;
}

export interface TestGDPRHashFile {
  id?: string;
  filename?: string;
}

export interface TestGDPRTestRun {
  id?: string;
  appHashFileId?: string;
  locale?: string;
  dsymHashFileId?: string;
  appHashFileUrl?: string;
  dsymHashFileUrl?: string;
  appIconUrl?: string;
}

export interface TestGDPRPipelineTest {
  appUploadId?: string;
  testParameters?: any;
}

export interface TestGDPRFileSetFile {
  path?: string;
  hashFileId?: string;
  appUploadId?: string;
  hashFileUrl?: string;
}

/**
 * The upload metadata from the release initialization step.
*/
export interface CodePushUploadedReleaseReleaseUpload {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The URL encoded token used for upload permissions.
  */
  token: string;
}

export interface CodePushUploadedRelease {
  /**
   * The upload metadata from the release initialization step.
  */
  releaseUpload: CodePushUploadedReleaseReleaseUpload;
  /**
   * the binary version of the application
  */
  targetBinaryVersion: string;
  /**
   * This specifies which deployment you want to release the update to. Default is Staging.
  */
  deploymentName?: string;
  /**
   * This provides an optional "change log" for the deployment.
  */
  description?: string;
  /**
   * This specifies whether an update should be downloadable by end users or not.
  */
  disabled?: boolean;
  /**
   * This specifies whether the update should be considered mandatory or not (e.g. it includes a
   * critical security fix).
  */
  mandatory?: boolean;
  /**
   * This specifies that if the update is identical to the latest release on the deployment, the
   * CLI should generate a warning instead of an error.
  */
  noDuplicateReleaseError?: boolean;
  /**
   * This specifies the percentage of users (as an integer between 1 and 100) that should be
   * eligible to receive this update.
  */
  rollout?: number;
}

export interface CodePushReleaseUpload {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The URL encoded token used for upload permissions.
  */
  token: string;
}

export interface DeploymentLatestReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface DeploymentLatestRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: DeploymentLatestReleaseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface Deployment {
  key?: string;
  name: string;
  latestRelease?: DeploymentLatestRelease;
}

export interface DeploymentInternalLatestReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface DeploymentInternalLatestRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: DeploymentInternalLatestReleaseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface DeploymentInternal {
  key?: string;
  name: string;
  latestRelease?: DeploymentInternalLatestRelease;
  id?: string;
}

export interface DeploymentModification {
  name: string;
}

export interface CodePushReleaseLabel {
  label?: string;
}

export interface BlobInfo {
  size: number;
  url: string;
}

export interface PackageHashToBlobInfoMapValue {
  size: number;
  url: string;
}

export interface CodePushReleaseInfo {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
}

export interface LegacyCodePushReleaseInfo {
  appVersion?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
}

export interface CodePushReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface CodePushRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: CodePushReleaseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface CodePushReleaseModification {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
}

export interface CodePushReleasePromote {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
}

export interface CodePushReleaseMetric {
  label: string;
  active: number;
  downloaded?: number;
  failed?: number;
  installed?: number;
}

export interface CodePushStatusMetricMetadata {
  deploymentKey: string;
  label?: string;
  appVersion?: string;
  previousDeploymentKey?: string;
  previousLabelOrAppVersion?: string;
  status?: string;
  clientUniqueId?: string;
}

export interface LegacyCodePushStatusMetricMetadata {
  deploymentKey?: string;
  label?: string;
  appVersion?: string;
  previousDeploymentKey?: string;
  previousLabelOrAppVersion?: string;
  status?: string;
  clientUniqueId?: string;
}

export interface UpdateCheckResponseUpdateInfo {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  downloadUrl?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface UpdateCheckResponse {
  updateInfo: UpdateCheckResponseUpdateInfo;
}

export interface LegacyUpdateCheckResponseUpdateInfo {
  appVersion?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  downloadURL?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface LegacyUpdateCheckResponse {
  updateInfo: LegacyUpdateCheckResponseUpdateInfo;
}

export interface UpdateInfoData {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  downloadUrl?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface LegacyUpdateInfoData {
  appVersion?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  downloadURL?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface AppName {
  name: string;
}

export interface AcquisitionStatusSuccessResponse {
  /**
   * The code indicating the status
  */
  code: string;
  /**
   * The message indicating the status
  */
  message: string;
}

export interface GDPRPurgeVerifyRequest {
  /**
   * deployment id
  */
  id: string;
  /**
   * deployment key
  */
  key: string;
}

export interface GDPRPurgeVerifyResponse {
  /**
   * indicate whether GDPR purge operation succeeds or not
  */
  success: boolean;
}

export interface LegacyDeploymentsResponseDeploymentsItemPackage {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

export interface LegacyDeploymentsResponseDeploymentsItem {
  /**
   * Time at which the deployment was created as a Unix timestamp.
  */
  createdTime?: number;
  /**
   * The ID of the deployment (internal use only).
  */
  id?: string;
  /**
   * Deployment key (aka Deployment Id)
  */
  key?: string;
  /**
   * Updated deployment name
  */
  name: string;
  packageProperty?: LegacyDeploymentsResponseDeploymentsItemPackage;
}

export interface LegacyDeploymentsResponse {
  deployments?: LegacyDeploymentsResponseDeploymentsItem[];
}

export interface LegacyDeploymentResponseDeploymentValuePackage {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

export interface LegacyDeploymentResponseDeploymentValue {
  /**
   * Time at which the deployment was created as a Unix timestamp.
  */
  createdTime?: number;
  /**
   * The ID of the deployment (internal use only).
  */
  id?: string;
  /**
   * Deployment key (aka Deployment Id)
  */
  key?: string;
  /**
   * Updated deployment name
  */
  name: string;
  packageProperty?: LegacyDeploymentResponseDeploymentValuePackage;
}

export interface LegacyDeploymentResponse {
  deployment?: { [propertyName: string]: LegacyDeploymentResponseDeploymentValue };
}

export interface LegacyDeploymentPackage {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

export interface LegacyDeployment {
  /**
   * Time at which the deployment was created as a Unix timestamp.
  */
  createdTime?: number;
  /**
   * The ID of the deployment (internal use only).
  */
  id?: string;
  /**
   * Deployment key (aka Deployment Id)
  */
  key?: string;
  /**
   * Updated deployment name
  */
  name: string;
  packageProperty?: LegacyDeploymentPackage;
}

export interface LegacyDeploymentHistoryResponseHistoryItemAllOf {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

/**
 * Information about a specific release.
*/
export interface LegacyDeploymentHistoryResponseHistoryItem {
  allOf?: LegacyDeploymentHistoryResponseHistoryItemAllOf;
  /**
   * The description of the release.
  */
  description?: string;
  /**
   * The original deployment of the release, if it's ever been promoted.
  */
  originalDeployment?: string;
  /**
   * The original label of the release, if it's ever been updated.
  */
  originalLabel?: string;
  /**
   * The package's hash value (internal use).
  */
  packageHash?: string;
}

export interface LegacyDeploymentHistoryResponse {
  /**
   * Array containing the deployment's package history.
  */
  history?: LegacyDeploymentHistoryResponseHistoryItem[];
}

export interface LegacyDeploymentHistoryAllOf {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

/**
 * Information about a specific release.
*/
export interface LegacyDeploymentHistory {
  allOf?: LegacyDeploymentHistoryAllOf;
  /**
   * The description of the release.
  */
  description?: string;
  /**
   * The original deployment of the release, if it's ever been promoted.
  */
  originalDeployment?: string;
  /**
   * The original label of the release, if it's ever been updated.
  */
  originalLabel?: string;
  /**
   * The package's hash value (internal use).
  */
  packageHash?: string;
}

export interface LegacyDeploymentMetricsResponseMetricsValue {
  /**
   * The number of devices that have this release installed currently
  */
  active: number;
  /**
   * The number of times this release has been installed on a device
  */
  installed?: number;
  /**
   * The number of times this release has been downloaded
  */
  downloaded?: number;
  /**
   * The number of times this release has failed to be installed on a device
  */
  failed?: number;
}

export interface LegacyDeploymentMetricsResponse {
  /**
   * Object containing a property named after each release label, which contains an object that
   * contains that release's metrics.
  */
  metrics?: { [propertyName: string]: LegacyDeploymentMetricsResponseMetricsValue };
}

export interface LegacyDeploymentMetric {
  /**
   * The number of devices that have this release installed currently
  */
  active: number;
  /**
   * The number of times this release has been installed on a device
  */
  installed?: number;
  /**
   * The number of times this release has been downloaded
  */
  downloaded?: number;
  /**
   * The number of times this release has failed to be installed on a device
  */
  failed?: number;
}

export interface LegacyCodePushRelease {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

export interface LegacyCodePushReleaseModification {
  /**
   * The release package information
  */
  packageInfo: any;
}

export interface LegacyCodePushReleaseResponsePackage {
  /**
   * The version of the release
  */
  appVersion?: string;
  /**
   * Flag used to determine if release is disabled
  */
  isDisabled?: boolean;
  /**
   * Flag used to determine if release is mandatory
  */
  isMandatory?: boolean;
  /**
   * Percentage (out of 100) that release is deployed to
  */
  rollout?: number;
  /**
   * Location (URL) of release package
  */
  blobUrl?: string;
  /**
   * Size of release package
  */
  size?: number;
  /**
   * Method used to deploy release
  */
  releaseMethod?: string;
  /**
   * Release upload time as epoch Unix timestamp
  */
  uploadTime?: number;
  /**
   * Release label (aka release name)
  */
  label?: string;
  /**
   * User ID that triggered most recent release
  */
  releasedByUserId?: string;
  /**
   * The URL location of the package's manifest file.
  */
  manifestBlobUrl?: string;
  /**
   * Object containing URL and size of changed package hashes contained in the release
  */
  diffPackageMap?: any;
}

export interface LegacyCodePushReleaseResponse {
  packageProperty: LegacyCodePushReleaseResponsePackage;
}

export interface LegacyAuthenticationResponse {
  /**
   * The authentication status of the user.
  */
  authenticated?: boolean;
}

export interface LegacyAccountResponseAccountValue {
  /**
   * The account name of the calling user.
  */
  name?: string;
  /**
   * The calling user's email.
  */
  email?: string;
  /**
   * Array of linked authentication providers associated with the account.
  */
  linkedProviders?: string[];
}

export interface LegacyAccountResponse {
  /**
   * Object containing the account information.
  */
  account?: { [propertyName: string]: LegacyAccountResponseAccountValue };
}

export interface LegacyAccount {
  /**
   * The account name of the calling user.
  */
  name?: string;
  /**
   * The calling user's email.
  */
  email?: string;
  /**
   * Array of linked authentication providers associated with the account.
  */
  linkedProviders?: string[];
}

export interface LegacyAppListResponseAppsItemCollaboratorsValue {
  /**
   * Is current collaborator the same as current account.
  */
  isCurrentAccount?: boolean;
  /**
   * Which permission does current account has.
  */
  permission?: string;
}

export interface LegacyAppListResponseAppsItem {
  /**
   * The app name.
  */
  name?: string;
  collaborators?: { [propertyName: string]: LegacyAppListResponseAppsItemCollaboratorsValue };
  deployments?: string[];
}

export interface LegacyAppListResponse {
  apps?: LegacyAppListResponseAppsItem[];
}

export interface LegacyAppResponseAppCollaboratorsValue {
  /**
   * Is current collaborator the same as current account.
  */
  isCurrentAccount?: boolean;
  /**
   * Which permission does current account has.
  */
  permission?: string;
}

export interface LegacyAppResponseApp {
  /**
   * The app name.
  */
  name?: string;
  collaborators?: { [propertyName: string]: LegacyAppResponseAppCollaboratorsValue };
  deployments?: string[];
}

export interface LegacyAppResponse {
  app?: LegacyAppResponseApp;
}

export interface LegacyAppCollaboratorsValue {
  /**
   * Is current collaborator the same as current account.
  */
  isCurrentAccount?: boolean;
  /**
   * Which permission does current account has.
  */
  permission?: string;
}

export interface LegacyApp {
  /**
   * The app name.
  */
  name?: string;
  collaborators?: { [propertyName: string]: LegacyAppCollaboratorsValue };
  deployments?: string[];
}

export interface LegacyCollaborator {
  /**
   * Is current collaborator the same as current account.
  */
  isCurrentAccount?: boolean;
  /**
   * Which permission does current account has.
  */
  permission?: string;
}

export interface LegacyCollaboratorsCollaboratorsValue {
  /**
   * Is current collaborator the same as current account.
  */
  isCurrentAccount?: boolean;
  /**
   * Which permission does current account has.
  */
  permission?: string;
}

export interface LegacyCollaborators {
  collaborators?: { [propertyName: string]: LegacyCollaboratorsCollaboratorsValue };
}

export interface LegacyCodePushApp {
  /**
   * The app name.
  */
  name: string;
  /**
   * The app os.
  */
  os?: string;
  /**
   * The app platform.
  */
  platform?: string;
  /**
   * Whether the user provided their own deployments. Not currently in use.
  */
  manuallyProvisionDeployments?: boolean;
}

export interface CreateAccessKeyRequest {
  /**
   * Name of creator current access key
  */
  createdBy?: string;
  /**
   * Friendly name of the access key
  */
  friendlyName?: string;
  /**
   * Time to live of the access key
  */
  ttl?: number;
}

export interface CreateAccessKeyResponseAccessKey {
  /**
   * Key of access key
  */
  name?: string;
  /**
   * Account name of creator.
  */
  createdBy?: string;
  /**
   * Description of access key
  */
  description?: string;
  /**
   * Friendly name of access key
  */
  friendlyName?: string;
  /**
   * Created time of access key
  */
  createdTime?: number;
  /**
   * Time of expiry of access key
  */
  expires?: number;
  /**
   * Id of accessKey
  */
  id?: string;
  /**
   * Legacy property which indicate if accessKey was created from session
  */
  isSession?: boolean;
}

export interface CreateAccessKeyResponse {
  accessKey?: CreateAccessKeyResponseAccessKey;
}

export interface AccessKey {
  /**
   * Key of access key
  */
  name?: string;
  /**
   * Account name of creator.
  */
  createdBy?: string;
  /**
   * Description of access key
  */
  description?: string;
  /**
   * Friendly name of access key
  */
  friendlyName?: string;
  /**
   * Created time of access key
  */
  createdTime?: number;
  /**
   * Time of expiry of access key
  */
  expires?: number;
  /**
   * Id of accessKey
  */
  id?: string;
  /**
   * Legacy property which indicate if accessKey was created from session
  */
  isSession?: boolean;
}

export interface AccessKeyListResponseAccessKeysItem {
  /**
   * Key of access key
  */
  name?: string;
  /**
   * Account name of creator.
  */
  createdBy?: string;
  /**
   * Description of access key
  */
  description?: string;
  /**
   * Friendly name of access key
  */
  friendlyName?: string;
  /**
   * Created time of access key
  */
  createdTime?: number;
  /**
   * Time of expiry of access key
  */
  expires?: number;
  /**
   * Id of accessKey
  */
  id?: string;
  /**
   * Legacy property which indicate if accessKey was created from session
  */
  isSession?: boolean;
}

export interface AccessKeyListResponse {
  /**
   * Array containing the list of existing AccessKeys
  */
  accessKeys?: AccessKeyListResponseAccessKeysItem[];
}

/**
 * Generic result for any alerting API operation
*/
export interface AlertOperationResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
}

/**
 * Alerting webhook
*/
export interface AlertWebhook {
  /**
   * The unique id (UUID) of the webhook
  */
  id?: string;
  /**
   * display name of the webhook
  */
  name: string;
  /**
   * target url of the webhook
  */
  url: string;
  /**
   * Allows eanble/disable webhook
  */
  enabled?: boolean;
  /**
   * Event types enabled for webhook
  */
  eventTypes: string[];
}

/**
 * Alerting webhook
*/
export interface AlertWebhookListResultValuesItem {
  /**
   * The unique id (UUID) of the webhook
  */
  id?: string;
  /**
   * display name of the webhook
  */
  name: string;
  /**
   * target url of the webhook
  */
  url: string;
  /**
   * Allows eanble/disable webhook
  */
  enabled?: boolean;
  /**
   * Event types enabled for webhook
  */
  eventTypes: string[];
}

/**
 * List of alerting webhooks wrapped as operation result
*/
export interface AlertWebhookListResult {
  values: AlertWebhookListResultValuesItem[];
}

/**
 * Alerting webhook ping operation result
*/
export interface AlertWebhookPingResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * HTTP status code returned in response from calling webhook
  */
  responseStatusCode: number;
  /**
   * Reason returned in response from calling webhook
  */
  responseReason?: string;
}

/**
 * Event Setting
*/
export interface AlertEmailSettingsSettingsItem {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Email Settings
*/
export interface AlertEmailSettings {
  /**
   * The settings the user has for the app
  */
  settings: AlertEmailSettingsSettingsItem[];
}

/**
 * Event Setting
*/
export interface AlertUserEmailSettingsResultSettingsItem {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Default Email Settings of the user
*/
export interface AlertUserEmailSettingsResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The ETag of the entity
  */
  eTag?: string;
  /**
   * Allows to forcefully disable emails on app or user level
  */
  enabled: boolean;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The settings the user has for the app
  */
  settings: AlertUserEmailSettingsResultSettingsItem[];
}

/**
 * Event Setting
*/
export interface AlertUserAppEmailSettingsResultSettingsItem {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Email Settings of the user for a particular app
*/
export interface AlertUserAppEmailSettingsResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The ETag of the entity
  */
  eTag?: string;
  /**
   * Allows to forcefully disable emails on app or user level
  */
  enabled: boolean;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The settings the user has for the app
  */
  settings: AlertUserAppEmailSettingsResultSettingsItem[];
  /**
   * Application ID
  */
  appId?: string;
  /**
   * A flag indicating if settings are enabled at user/global level
  */
  userEnabled: boolean;
}

/**
 * Bugtracker specific settings
*/
export interface AlertingBugtrackerSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * VSTS bugtracker specific settings
*/
export interface AlertingVstsBugtrackerSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type: string;
  vstsProjectId: string;
  vstsProjectUri: string;
  vstsProjectName?: string;
  vstsAccountName?: string;
  vstsAreaPath?: string;
  vstsDefaultPayload?: any;
}

/**
 * Github bugtracker specific settings
*/
export interface AlertingGithubBugtrackerSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type: string;
  githubRepoId: number;
  githubRepoName: string;
  githubLabel?: string;
}

/**
 * Jira bugtracker specific settings
*/
export interface AlertingJiraBugtrackerSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type: string;
  jiraProjectId: number;
  jiraProjectName: string;
}

/**
 * Bugtracker specific settings
*/
export interface AlertingBugtrackerSettingsModel {
  callbackUrl?: string;
  ownerName: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Alerting bugtracker resource
*/
export interface AlertingBugtracker {
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type?: string;
  /**
   * bugtracker state. Possible values include: 'enabled', 'disabled', 'unauthorized'
  */
  state?: string;
  /**
   * ID of OAuth token
  */
  tokenId?: string;
  /**
   * Event types enabled for bugtracker
  */
  eventTypes?: string[];
  /**
   * Bugtracker specific settings
  */
  settings?: AlertingBugtrackerSettingsModel;
}

/**
 * Contains the token ID for a bug tracker
*/
export interface BugTrackerTokenId {
  tokenId?: string;
}

/**
 * Repository owner object
*/
export interface AlertBugTrackerReposResultRepositoriesItemOwner {
  name?: string;
  id?: string;
  login?: string;
}

/**
 * Repostiory object
*/
export interface AlertBugTrackerReposResultRepositoriesItem {
  name: string;
  url: string;
  id: string;
  description?: string;
  privateProperty?: boolean;
  /**
   * Repository owner object
  */
  owner?: AlertBugTrackerReposResultRepositoriesItemOwner;
}

/**
 * List of bug tracker repositories
*/
export interface AlertBugTrackerReposResult {
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  repoType?: string;
  repositories: AlertBugTrackerReposResultRepositoriesItem[];
}

/**
 * Repository owner object
*/
export interface AlertBugTrackerRepoOwner {
  name?: string;
  id?: string;
  login?: string;
}

/**
 * Repostiory object
*/
export interface AlertBugTrackerRepo {
  name: string;
  url: string;
  id: string;
  description?: string;
  privateProperty?: boolean;
  /**
   * Repository owner object
  */
  owner?: AlertBugTrackerRepoOwner;
}

/**
 * Repository owner object
*/
export interface AlertBugTrackerRepoOwnerModel {
  name?: string;
  id?: string;
  login?: string;
}

/**
 * AlertCrashGroup patching parameter
*/
export interface AlertCrashGroupStateChange {
  /**
   * Possible values include: 'Open', 'Closed', 'Ignored'
  */
  state?: string;
}

/**
 * Access token details
*/
export interface AlertingAccessTokenResponse {
  /**
   * ID of the access token
  */
  accessTokenId: string;
  /**
   * External provider name. Possible values include: 'github', 'vsts', 'jira'
  */
  externalProviderName: string;
  /**
   * The email of external user that used to authenticate aginst the external oauth provider
  */
  externalUserEmail: string;
  /**
   * The account name of external user that used to authenticate against the external oauth
   * provider or basic auth
  */
  externalAccountName: string;
}

/**
 * Event Setting
*/
export interface EventSetting {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting event
*/
export interface AlertingEvent {
  /**
   * ISO 8601 date time when event was generated
  */
  eventTimestamp: string;
  /**
   * A unique identifier for this event instance. Useful for deduplication
  */
  eventId: string;
  /**
   * Obsolete. Use emailProperties.
  */
  properties?: any;
}

/**
 * Properties of new crash group
*/
export interface NewCrashGroupAlertingEventCrashGroupProperties {
  id: string;
  name: string;
  reason: string;
  url: string;
  appDisplayName: string;
  appPlatform: string;
  appVersion: string;
  stackTrace: string[];
}

/**
 * New crash group alerting event
*/
export interface NewCrashGroupAlertingEvent {
  /**
   * ISO 8601 date time when event was generated
  */
  eventTimestamp: string;
  /**
   * A unique identifier for this event instance. Useful for deduplication
  */
  eventId: string;
  /**
   * Obsolete. Use emailProperties.
  */
  properties?: any;
  /**
   * Properties of new crash group
  */
  crashGroupProperties?: NewCrashGroupAlertingEventCrashGroupProperties;
}

/**
 * Properties of new application release
*/
export interface NewAppReleaseAlertingEventAppReleaseProperties {
  appName: string;
  appDisplayName: string;
  releaseId: string;
  platform: string;
  /**
   * Date and time in ISO 8601 format
  */
  uploadedAt: string;
  fingerprint?: string;
  releaseNotes?: string;
  version: string;
  shortVersion: string;
  minOs?: string;
  mandatoryUpdate?: boolean;
  size: number;
  provisioningProfileName?: string;
  provisioningProfileType?: string;
  bundleIdentifier: string;
  installLink: string;
  iconLink?: string;
  distributionGroupId?: string;
  installable?: boolean;
}

/**
 * New app release alerting event
*/
export interface NewAppReleaseAlertingEvent {
  /**
   * ISO 8601 date time when event was generated
  */
  eventTimestamp: string;
  /**
   * A unique identifier for this event instance. Useful for deduplication
  */
  eventId: string;
  /**
   * Obsolete. Use emailProperties.
  */
  properties?: any;
  /**
   * List of users who need to receive an email notification. If this is not null, then only
   * sending emails will be triggered even if the event requires calling webhooks or doing other
   * actions.
  */
  userIds?: string[];
  /**
   * indicate whether notify via webhook or not
  */
  disableWebhook?: boolean;
  /**
   * Properties of new application release
  */
  appReleaseProperties?: NewAppReleaseAlertingEventAppReleaseProperties;
}

/**
 * Object returned in response to getting a bug tracker issue related to a crash group id
*/
export interface BugTrackerIssuesResultIssuesItem {
  id?: string;
  url?: string;
  title?: string;
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  bugTrackerType?: string;
  repoName?: string;
  mobileCenterId?: string;
  eventType?: string;
}

/**
 * Returns a list of all issues associated with a repo
*/
export interface BugTrackerIssuesResult {
  issues?: BugTrackerIssuesResultIssuesItem[];
}

/**
 * Object returned in response to getting a bug tracker issue related to a crash group id
*/
export interface BugTrackerIssueResult {
  id?: string;
  url?: string;
  title?: string;
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  bugTrackerType?: string;
  repoName?: string;
  mobileCenterId?: string;
  eventType?: string;
}

/**
 * Object returned in response to getting or updating the state of a bugtracker
*/
export interface BugTrackerStateResult {
  /**
   * bugtracker state. Possible values include: 'enabled', 'disabled', 'unauthorized'
  */
  state?: string;
}

/**
 * Object returned in response to accepting an event occurance
*/
export interface EventResponseResult {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
}

/**
 * Alerting service error
*/
export interface AlertingError {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Billing Plan
*/
export interface AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriodByAccount
{
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface AggregatedBillingInformationBillingPlansBuildService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: AggregatedBillingInformationBillingPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface AggregatedBillingInformationBillingPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: AggregatedBillingInformationBillingPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface AggregatedBillingInformationBillingPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: AggregatedBillingInformationBillingPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: AggregatedBillingInformationBillingPlansTestService;
}

/**
 * Usage for a single period
*/
export interface AggregatedBillingInformationUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface AggregatedBillingInformationUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: AggregatedBillingInformationUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface AggregatedBillingInformationUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface AggregatedBillingInformationUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: AggregatedBillingInformationUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface AggregatedBillingInformationUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: AggregatedBillingInformationUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: AggregatedBillingInformationUsageTestService;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface AggregatedBillingInformation {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  /**
   * Billing Plans section in the Billing Information
  */
  billingPlans?: AggregatedBillingInformationBillingPlans;
  /**
   * Usage section in the Billing Information
  */
  usage?: AggregatedBillingInformationUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

/**
 * Billing Plan
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan
{
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccount
{
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriod
{
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildService
{
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccountPlan
{
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccount
{
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriod
{
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlansTestService;
}

/**
 * Usage for a single period
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?:
  AllAccountsAggregatedBillingInformationAggregatedBillingsUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillingsUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: AllAccountsAggregatedBillingInformationAggregatedBillingsUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: AllAccountsAggregatedBillingInformationAggregatedBillingsUsageTestService;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface AllAccountsAggregatedBillingInformationAggregatedBillings {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  /**
   * Billing Plans section in the Billing Information
  */
  billingPlans?: AllAccountsAggregatedBillingInformationAggregatedBillingsBillingPlans;
  /**
   * Usage section in the Billing Information
  */
  usage?: AllAccountsAggregatedBillingInformationAggregatedBillingsUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

/**
 * Aggregated Billing Information for a user an the organizations in which the user is an admin.
*/
export interface AllAccountsAggregatedBillingInformation {
  /**
   * Aggregated Billing Information for a user or an organization
  */
  aggregatedBillings?: AllAccountsAggregatedBillingInformationAggregatedBillings;
}

export interface BillingErrorError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface BillingError {
  error?: BillingErrorError;
}

/**
 * Billing Plan
*/
export interface BillingInformationPlansBuildServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingInformationPlansBuildServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingInformationPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface BillingInformationPlansBuildServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: BillingInformationPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface BillingInformationPlansBuildService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: BillingInformationPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface BillingInformationPlansTestServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingInformationPlansTestServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingInformationPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface BillingInformationPlansTestServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: BillingInformationPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface BillingInformationPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: BillingInformationPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface BillingInformationPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: BillingInformationPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: BillingInformationPlansTestService;
}

export interface BillingInformationSearchResultsItem {
  /**
   * The Account ID
  */
  accountId?: string;
  /**
   * The Account Name
  */
  accountName?: string;
  /**
   * The Billing Internal Account ID
  */
  billingInternalAccountId?: string;
  /**
   * The ID of the Build Billing Plan
  */
  buildPlan?: string;
  /**
   * The ID of the Test Billing Plan
  */
  testPlan?: string;
}

/**
 * Billing Plan
*/
export interface BillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface BillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: BillingPeriodByAccount;
}

/**
 * Billing Plan
*/
export interface BillingPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Responses for requests that detect billing plans change type
*/
export interface BillingPlansChangeTypeResponse {
  /**
   * Possible values include: 'NoChange', 'Downgrade', 'Upgrade'
  */
  result?: string;
}

/**
 * Billing Plan
*/
export interface BillingPlanSelectionPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingPlanSelection {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingPlanSelectionPlan;
}

/**
 * Billing Plan
*/
export interface BillingPlansSelectionBuildServicePlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingPlansSelectionBuildService {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingPlansSelectionBuildServicePlan;
}

/**
 * Billing Plan
*/
export interface BillingPlansSelectionTestServicePlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface BillingPlansSelectionTestService {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: BillingPlansSelectionTestServicePlan;
}

/**
 * Selection of a billing plan for one or more services
*/
export interface BillingPlansSelection {
  /**
   * Selection of a billing plan
  */
  buildService?: BillingPlansSelectionBuildService;
  /**
   * Selection of a billing plan
  */
  testService?: BillingPlansSelectionTestService;
}

/**
 * Usage for a single period
*/
export interface BillingResourceUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface BillingResourceUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: BillingResourceUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface BillingResourceUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface BillingResourceUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: BillingResourceUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface BillingResourceUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: BillingResourceUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: BillingResourceUsageTestService;
}

/**
 * GDPR tests verification result
*/
export interface GdprVerificationResult {
  /**
   * Verification status. True means that the verification was successfull.
  */
  status?: boolean;
  /**
   * Optional error message if the verification failed.
  */
  message?: string;
}

/**
 * GitHub account information
*/
export interface GitHubAccount {
  /**
   * Id of GitHub account
  */
  id?: number;
  /**
   * Type of GitHub account. Possible values include: 'User', 'Organization'
  */
  accountType?: string;
}

/**
 * GitHub Marketplace plan
*/
export interface GitHubMarketplacePlan {
  /**
   * Id of the GitHub plan
  */
  id?: number;
}

/**
 * GitHub account information
*/
export interface GitHubMarketplacePurchaseAccount {
  /**
   * Id of GitHub account
  */
  id?: number;
  /**
   * Type of GitHub account. Possible values include: 'User', 'Organization'
  */
  accountType?: string;
}

/**
 * GitHub Marketplace plan
*/
export interface GitHubMarketplacePurchasePlan {
  /**
   * Id of the GitHub plan
  */
  id?: number;
}

/**
 * GitHub Marketplace purchase
*/
export interface GitHubMarketplacePurchase {
  /**
   * GitHub account information
  */
  account?: GitHubMarketplacePurchaseAccount;
  /**
   * GitHub Marketplace plan
  */
  plan?: GitHubMarketplacePurchasePlan;
}

/**
 * Billing Plan
*/
export interface ServiceBillingPlansCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface ServiceBillingPlansCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: ServiceBillingPlansCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface ServiceBillingPlansCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: ServiceBillingPlansCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface ServiceBillingPlans {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: ServiceBillingPlansCurrentBillingPeriod;
}

/**
 * Usage for a single period
*/
export interface ServiceResourceUsageCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface ServiceResourceUsage {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: ServiceResourceUsageCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface UsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Status of the usage record creation
*/
export interface UsageRecordStatus {
  /**
   * Is the age of the most recent Build service usage record within expected limits
  */
  expectedLatestBuildExists?: boolean;
  /**
   * Is the age of the most recent Test service usage record within expected limits
  */
  expectedLatestTestExists?: boolean;
  /**
   * The time of the most recent Build service usage record
  */
  latestBuildUsageRecordTime?: string;
  /**
   * The time of the most recent Test service usage record
  */
  latestTestUsageRecordTime?: string;
}

/**
 * Billing Plan
*/
export interface VersionedBillingPlanDocument {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Billing Plan with a version
*/
export interface VersionedBillingPlan {
  /**
   * Billing Plan
  */
  document?: VersionedBillingPlanDocument;
  /**
   * The version of the object
  */
  etag?: string;
}

/**
 * Envelope for messages sent to actors
*/
export interface MessageEnvelope {
  /**
   * Unique id of the message
  */
  messageId?: string;
  /**
   * Type of the message
  */
  messageType?: string;
  /**
   * Body of the message
  */
  message?: any;
}

export interface DataSubjectRightCustomerIdRequest {
  /**
   * customer account id (b2c identifier) / customer user id (free form text) depending on the
   * value of the fied `type`
  */
  dataSubjectIdentifier?: string;
  /**
   * type of the customer dataSubjectIdentifier. Possible values include: 'CustomerAccountId',
   * 'CustomerUserId'
  */
  type?: string;
}

export interface DataSubjectRightEmailRequest {
  /**
   * Email used for cancel delete with x-authz-bypass headers
  */
  email: string;
}

export interface DataSubjectRightResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface DataSubjectRightStatusResponse {
  /**
   * Azure Storage shared access signature (SAS) URL for exported user data.
  */
  sasUrl?: string;
  /**
   * Whether Azure Storage shared access signature (SAS) URL has expired or not.
  */
  sasUrlExpired?: boolean;
  /**
   * Status of data subject right request. Possible values include: 'None', 'Created', 'Queued',
   * 'InProgress', 'Completed', 'Failed'
  */
  status: string;
  /**
   * explanation message of the status
  */
  message: string;
}

export interface DataSubjectRightUpdateStatusOperation {
  /**
   * Request identifier of the operation
  */
  requestId: string;
  /**
   * Operation status. Possible values include: 'None', 'Created', 'Queued', 'InProgress',
   * 'Completed', 'Failed'
  */
  status: string;
  /**
   * String field to be used by participant for any intermediate statuses or data they need to save
  */
  participantData?: string;
}

export interface DataSubjectRightOperation {
  /**
   * Unique request identifier
  */
  requestId: string;
  /**
   * Unique operation identifier
  */
  operationId: string;
  /**
   * Request type. Possible values include: 'Unsupported', 'Delete', 'Purge', 'UndoDelete',
   * 'Scheduled', 'AppDelete', 'AppPurge', 'AppUndoDelete', 'Export', 'CustomerAccountDelete',
   * 'CustomerAccountExport', 'CustomerUserDelete', 'CustomerUserExport'
  */
  requestType: string;
  /**
   * Operation status. Possible values include: 'None', 'Created', 'Queued', 'InProgress',
   * 'Completed', 'Failed'
  */
  status: string;
  /**
   * Participant to execute the response
  */
  participant: string;
  /**
   * JSON object decribing what to delete (TODO - make separate definition?)
  */
  context: string;
  /**
   * Application identifier if applicable
  */
  appId?: string;
  /**
   * String field to be used by participant for any intermediate statuses or data they need to save
  */
  participantData?: string;
}

export interface DataSubjectRightQueueInfo {
  sasUri: string;
  queueName: string;
  expiresAt: Date;
}

export interface DataSubjectRighBlobContainerInfo {
  sasUri: string;
  blobPath: string;
}

/**
 * This response contains the Azure AD B2C client ID for an application.
*/
export interface ClientIdResponse {
  clientId?: string;
}

export interface InnerError {
  code?: string;
  innererror?: InnerError;
}

export interface AuthTenantsResponseValueItem {
  id: string;
  name: string;
}

export interface AuthTenantsResponse {
  value?: AuthTenantsResponseValueItem[];
}

export interface AuthTenant {
  id: string;
  name: string;
}

export interface ApplicationsResponseValueItem {
  id?: string;
  createdAt?: Date;
  name?: string;
  signInAudience?: string;
}

export interface ApplicationsResponse {
  value?: ApplicationsResponseValueItem[];
}

export interface ApplicationResponse {
  id?: string;
  createdAt?: Date;
  name?: string;
  signInAudience?: string;
}

export interface ScopesResponseValueItem {
  id?: string;
  appName?: string;
  scope?: string;
  url?: string;
}

export interface ScopesResponse {
  value?: ScopesResponseValueItem[];
}

export interface ScopeResponse {
  id?: string;
  appName?: string;
  scope?: string;
  url?: string;
}

export interface AuthApplicationResponse {
  id: string;
  /**
   * Possible values include: 'AADB2C', 'Auth0', 'Firebase', 'AAD'
  */
  provider: string;
  tenantId?: string;
  tenantName?: string;
  policyId?: string;
  scopeId?: string;
  scopeUrl?: string;
  signInAudience?: string;
}

export interface AuthApplicationPatchRequest {
  policyId?: string;
  scopeId?: string;
  scopeUrl?: string;
  id?: string;
  /**
   * Possible values include: 'AADB2C', 'Auth0', 'Firebase', 'AAD'
  */
  provider?: string;
}

export interface ExistingAuthApplicationPostRequest {
  tenantId?: string;
  tenantName?: string;
  /**
   * Possible values include: 'AADB2C', 'Auth0', 'Firebase', 'AAD'
  */
  provider?: string;
  id: string;
  policyId?: string;
  scopeId?: string;
  scopeUrl?: string;
  signInAudience?: string;
}

export interface TrustFrameworkPoliciesResponseValueItem {
  id?: string;
}

export interface TrustFrameworkPoliciesResponse {
  value?: TrustFrameworkPoliciesResponseValueItem[];
}

export interface TrustFrameworkPolicyResponse {
  id?: string;
}

export interface MetricsResponseMetricsLatencyMetricsReadLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface MetricsResponseMetricsLatencyMetricsReadLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: MetricsResponseMetricsLatencyMetricsReadLatencyMetricsMetricValuesItem[];
}

export interface MetricsResponseMetricsLatencyMetricsWriteLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface MetricsResponseMetricsLatencyMetricsWriteLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: MetricsResponseMetricsLatencyMetricsWriteLatencyMetricsMetricValuesItem[];
}

export interface MetricsResponseMetricsLatencyMetrics {
  readLatencyMetrics?: MetricsResponseMetricsLatencyMetricsReadLatencyMetrics;
  writeLatencyMetrics?: MetricsResponseMetricsLatencyMetricsWriteLatencyMetrics;
}

/**
 * Represents database usage metrics.
*/
export interface MetricsResponseMetrics {
  interval?: number;
  totalRequests?: number;
  totalRequestUnits?: number;
  dataUsage?: number;
  indexUsage?: number;
  latencyMetrics?: MetricsResponseMetricsLatencyMetrics;
}

export interface MetricsResponse {
  /**
   * Possible values include: 'East Asia', 'Southeast Asia', 'Australia Central', 'Australia
   * Central 2', 'Australia East', 'Australia Southeast', 'Brazil South', 'Canada Central', 'Canada
   * East', 'Central India', 'South India', 'West India', 'North Europe', 'West Europe', 'France
   * Central', 'France South', 'Germany Central', 'Germany Northeast', 'Japan East', 'Japan West',
   * 'Korea Central', 'Korea South', 'South Africa North', 'South Africa West', 'UK South', 'UK
   * West', 'Central US', 'East US', 'East US 2', 'US Gov Arizona', 'US Gov Texas', 'North Central
   * US', 'South Central US', 'West US', 'West US 2', 'West Central US'
  */
  databaseLocation?: string;
  accountName?: string;
  databaseId?: string;
  /**
   * Represents database usage metrics.
  */
  metrics?: MetricsResponseMetrics;
}

export interface DatabaseMetricsLatencyMetricsReadLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface DatabaseMetricsLatencyMetricsReadLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: DatabaseMetricsLatencyMetricsReadLatencyMetricsMetricValuesItem[];
}

export interface DatabaseMetricsLatencyMetricsWriteLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface DatabaseMetricsLatencyMetricsWriteLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: DatabaseMetricsLatencyMetricsWriteLatencyMetricsMetricValuesItem[];
}

export interface DatabaseMetricsLatencyMetrics {
  readLatencyMetrics?: DatabaseMetricsLatencyMetricsReadLatencyMetrics;
  writeLatencyMetrics?: DatabaseMetricsLatencyMetricsWriteLatencyMetrics;
}

/**
 * Represents database usage metrics.
*/
export interface DatabaseMetrics {
  interval?: number;
  totalRequests?: number;
  totalRequestUnits?: number;
  dataUsage?: number;
  indexUsage?: number;
  latencyMetrics?: DatabaseMetricsLatencyMetrics;
}

export interface LatencyMetricsReadLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface LatencyMetricsReadLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: LatencyMetricsReadLatencyMetricsMetricValuesItem[];
}

export interface LatencyMetricsWriteLatencyMetricsMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface LatencyMetricsWriteLatencyMetrics {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: LatencyMetricsWriteLatencyMetricsMetricValuesItem[];
}

export interface LatencyMetrics {
  readLatencyMetrics?: LatencyMetricsReadLatencyMetrics;
  writeLatencyMetrics?: LatencyMetricsWriteLatencyMetrics;
}

export interface LatencyDataMetricValuesItem {
  timestamp?: Date;
  average?: number;
}

export interface LatencyData {
  name?: string;
  unit?: string;
  startTime?: Date;
  endTime?: Date;
  metricValues?: LatencyDataMetricValuesItem[];
}

export interface MetricsData {
  timestamp?: Date;
  average?: number;
}

export interface OverviewResponse {
  /**
   * Possible values include: 'East Asia', 'Southeast Asia', 'Australia Central', 'Australia
   * Central 2', 'Australia East', 'Australia Southeast', 'Brazil South', 'Canada Central', 'Canada
   * East', 'Central India', 'South India', 'West India', 'North Europe', 'West Europe', 'France
   * Central', 'France South', 'Germany Central', 'Germany Northeast', 'Japan East', 'Japan West',
   * 'Korea Central', 'Korea South', 'South Africa North', 'South Africa West', 'UK South', 'UK
   * West', 'Central US', 'East US', 'East US 2', 'US Gov Arizona', 'US Gov Texas', 'North Central
   * US', 'South Central US', 'West US', 'West US 2', 'West Central US'
  */
  databaseLocation?: string;
  accountName?: string;
  databaseId?: string;
  throughput?: number;
}

/**
 * This response contains an estimated price-per-RU denominated in a given currency.
*/
export interface EstimatedPricingResponse {
  pricePerHour?: number;
  /**
   * Possible values include: 'USD', 'EUR', 'GBP', 'AUD', 'INR', 'CAD', 'ARS', 'BRL', 'DKK', 'HKD',
   * 'IDR', 'JPY', 'KRW', 'MYR', 'MXN', 'NZD', 'NOK', 'RUB', 'SAR', 'ZAR', 'SEK', 'CHF', 'TWD',
   * 'TRY'
  */
  currency?: string;
}

export interface DataInstancesResponseValueItem {
  id: string;
  name: string;
}

export interface DataInstancesResponse {
  value?: DataInstancesResponseValueItem[];
}

export interface DataInstance {
  id: string;
  name: string;
}

export interface InstanceDatabasesResponseValueItem {
  id: string;
  name: string;
}

export interface InstanceDatabasesResponse {
  value?: InstanceDatabasesResponseValueItem[];
}

export interface InstanceDatabase {
  id: string;
  name: string;
}

export interface DatabaseCollectionsResponseValueItem {
  id: string;
  name: string;
}

export interface DatabaseCollectionsResponse {
  value?: DatabaseCollectionsResponseValueItem[];
}

export interface DatabaseCollection {
  id: string;
  name: string;
}

export interface NotificationConfiguration {
  appId?: string;
  /**
   * Possible values include: 'Disabled', 'Disabling', 'Enabling', 'Enabled'
  */
  state?: string;
  /**
   * Possible values include: 'NotSetByUser', 'SetByUser', 'Error'
  */
  reason?: string;
}

export interface DataResourceTokenResponse {
  databaseId?: string;
  databaseName?: string;
  collectionName?: string;
  accountName?: string;
  token?: string;
  expiresOn?: Date;
  isReadOnlyToken?: boolean;
}

export interface UsersResponseValueItem {
  accountId: string;
  mail?: string;
  displayName: string;
}

export interface UsersResponse {
  value: UsersResponseValueItem[];
}

export interface UserResponse {
  accountId: string;
  mail?: string;
  displayName: string;
}

export interface DataProvisioningParameters {
  subscriptionId?: string;
  databaseConnectionString?: string;
  /**
   * Possible values include: 'East Asia', 'Southeast Asia', 'Australia Central', 'Australia
   * Central 2', 'Australia East', 'Australia Southeast', 'Brazil South', 'Canada Central', 'Canada
   * East', 'Central India', 'South India', 'West India', 'North Europe', 'West Europe', 'France
   * Central', 'France South', 'Germany Central', 'Germany Northeast', 'Japan East', 'Japan West',
   * 'Korea Central', 'Korea South', 'South Africa North', 'South Africa West', 'UK South', 'UK
   * West', 'Central US', 'East US', 'East US 2', 'US Gov Arizona', 'US Gov Texas', 'North Central
   * US', 'South Central US', 'West US', 'West US 2', 'West Central US'
  */
  resourceRegion?: string;
  database?: string;
  collection?: string;
  requestUnits?: number;
  accountName?: string;
}

export interface ProvisionStatusResponse {
  /**
   * Possible values include: 'Empty', 'Accepted', 'Creating', 'Connected', 'Invalid'
  */
  status: string;
  message?: string;
}

/**
 * The Api response model for Cosmos Db Cors status
*/
export interface CosmosDbCorsStatusResponse {
  /**
   * Possible values include: 'Appended', 'HostDbInProgress', 'HostDbNotFound', 'Queued',
   * 'InProgress', 'NotFound'
  */
  status: string;
  message?: string;
}

/**
 * The information for a single iOS device
*/
export interface Body {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The build number of the last known OS version running on the device
  */
  osBuild?: string;
  /**
   * The last known OS version running on the device
  */
  osVersion?: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
}

/**
 * The information for a single iOS device
*/
export interface RegisterUserForDeviceOKResponse {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

export interface RegisterUserForDeviceNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * Event Setting
*/
export interface GetUserEmailSettingsOKResponseSettingsItem {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Default Email Settings of the user
*/
export interface GetUserEmailSettingsOKResponse {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The ETag of the entity
  */
  eTag?: string;
  /**
   * Allows to forcefully disable emails on app or user level
  */
  enabled: boolean;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The settings the user has for the app
  */
  settings: GetUserEmailSettingsOKResponseSettingsItem[];
}

/**
 * Alerting service error
*/
export interface GetUserEmailSettingsErrorModel {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

export interface GetUserMetadataOKResponse {
  userId?: string;
  metadata?: any;
}

export interface GetUserMetadataErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized'
  */
  code: string;
  message: string;
}

export interface GetUserMetadataErrorModel {
  error: GetUserMetadataErrorModelError;
}

export interface RejectErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RejectErrorModel {
  error: RejectErrorModelError;
}

export interface AcceptErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AcceptErrorModel {
  error: AcceptErrorModelError;
}

export interface AcceptAllErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AcceptAllErrorModel {
  error: AcceptAllErrorModelError;
}

/**
 * SharedConnectionResponse
*/
export interface ConnectionsOKResponseItem {
  /**
   * id of the shared connection
  */
  id: string;
  /**
   * display name of shared connection
  */
  displayName?: string;
  /**
   * the type of the credential. Possible values include: 'credentials', 'certificate'
  */
  credentialType: string;
  /**
   * whether the credentials are valid or not
  */
  isValid?: boolean;
  /**
   * if the account is a 2FA account or not
  */
  is2FA?: boolean;
  /**
   * Polymorphic Discriminator
  */
  serviceType: string;
}

export interface ConnectionsErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CancelExportRequestAcceptedResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface CancelExportRequestServiceUnavailableResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CancelExportRequestServiceUnavailableResponse {
  error: CancelExportRequestServiceUnavailableResponseError;
}

export interface CancelExportRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CancelExportRequestErrorModel {
  error: CancelExportRequestErrorModelError;
}

export interface ExportStatusRequestOKResponse {
  /**
   * Azure Storage shared access signature (SAS) URL for exported user data.
  */
  sasUrl?: string;
  /**
   * Whether Azure Storage shared access signature (SAS) URL has expired or not.
  */
  sasUrlExpired?: boolean;
  /**
   * Status of data subject right request. Possible values include: 'None', 'Created', 'Queued',
   * 'InProgress', 'Completed', 'Failed'
  */
  status: string;
  /**
   * explanation message of the status
  */
  message: string;
}

export interface ExportStatusRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ExportStatusRequestErrorModel {
  error: ExportStatusRequestErrorModelError;
}

export interface ExportRequestAcceptedResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface ExportRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ExportRequestErrorModel {
  error: ExportRequestErrorModelError;
}

export interface Email {
  /**
   * Email used for cancel delete with x-authz-bypass headers
  */
  email: string;
}

export interface CancelDeleteRequestAcceptedResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface CancelDeleteRequestServiceUnavailableResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CancelDeleteRequestServiceUnavailableResponse {
  error: CancelDeleteRequestServiceUnavailableResponseError;
}

export interface CancelDeleteRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CancelDeleteRequestErrorModel {
  error: CancelDeleteRequestErrorModelError;
}

export interface DeleteStatusRequestOKResponse {
  /**
   * Azure Storage shared access signature (SAS) URL for exported user data.
  */
  sasUrl?: string;
  /**
   * Whether Azure Storage shared access signature (SAS) URL has expired or not.
  */
  sasUrlExpired?: boolean;
  /**
   * Status of data subject right request. Possible values include: 'None', 'Created', 'Queued',
   * 'InProgress', 'Completed', 'Failed'
  */
  status: string;
  /**
   * explanation message of the status
  */
  message: string;
}

export interface DeleteStatusRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteStatusRequestErrorModel {
  error: DeleteStatusRequestErrorModelError;
}

export interface DeleteRequestAcceptedResponse {
  /**
   * Unique request identifier
  */
  token: string;
  /**
   * ISO 8601 format timestamp of when request was created.
  */
  createdAt: Date;
}

export interface DeleteRequestErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteRequestErrorModel {
  error: DeleteRequestErrorModelError;
}

/**
 * The information for a single iOS device
*/
export interface DeviceDetailsOKResponse {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

export interface DeviceDetailsBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeviceDetailsForbiddenResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeviceDetailsNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveUserDeviceForbiddenResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveUserDeviceNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * The information for a single iOS device
*/
export interface UserDevicesListOKResponseItem {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

export interface UserDevicesListBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UserDevicesListForbiddenResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetOKResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface GetErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetErrorModel {
  error: GetErrorModelError;
}

export interface User {
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface UpdateOKResponse {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface UpdateErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdateErrorModel {
  error: UpdateErrorModelError;
}

export interface ListTesterAppsOKResponseItemRelease {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
  /**
   * The release's size in bytes.
  */
  size: number;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
}

/**
 * The information about the app's owner
*/
export interface ListTesterAppsOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id?: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName?: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name?: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type?: string;
}

export interface ListTesterAppsOKResponseItem {
  /**
   * The unique ID (UUID) of the app
  */
  id?: string;
  release?: ListTesterAppsOKResponseItemRelease;
  /**
   * The app's name.
  */
  name?: string;
  /**
   * The app's display name.
  */
  displayName?: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * A URL to the app's icon.
  */
  iconUrl?: string;
  /**
   * The app's os.
  */
  os?: string;
  /**
   * The information about the app's owner
  */
  owner?: ListTesterAppsOKResponseItemOwner;
}

export interface GetLatestByHashOKResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface GetLatestByHashOKResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface GetLatestByHashOKResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface GetLatestByHashOKResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetLatestByHashOKResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName: string;
  /**
   * The app's display name.
  */
  appDisplayName: string;
  /**
   * The app's OS.
  */
  appOs?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * Hashes for the packages.
  */
  packageHashes?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: GetLatestByHashOKResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: GetLatestByHashOKResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: GetLatestByHashOKResponseDestinationsItem[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: GetLatestByHashOKResponseBuild;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * Status of the release.
  */
  status?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface GetLatestByHashNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetLatestPrivateReleaseOKResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface GetLatestPrivateReleaseOKResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface GetLatestPrivateReleaseOKResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface GetLatestPrivateReleaseOKResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetLatestPrivateReleaseOKResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName: string;
  /**
   * The app's display name.
  */
  appDisplayName: string;
  /**
   * The app's OS.
  */
  appOs?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * Hashes for the packages.
  */
  packageHashes?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: GetLatestPrivateReleaseOKResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: GetLatestPrivateReleaseOKResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: GetLatestPrivateReleaseOKResponseDestinationsItem[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: GetLatestPrivateReleaseOKResponseBuild;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * Status of the release.
  */
  status?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface GetLatestPrivateReleaseNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * The information about the app's owner
*/
export interface GetForOrgUserOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface GetForOrgUserOKResponseItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface GetForOrgUserOKResponseItem {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: GetForOrgUserOKResponseItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: GetForOrgUserOKResponseItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface GetForOrgUserErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetForOrgUserErrorModel {
  error: GetForOrgUserErrorModelError;
}

export interface OrganizationUser {
  /**
   * The user's role in the organizatiion. Possible values include: 'admin', 'collaborator',
   * 'member'
  */
  role?: string;
}

export interface UpdateOrgRoleOKResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The date when the user joined the organization
  */
  joinedAt: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role the user has within the organization
  */
  role: string;
}

export interface UpdateOrgRoleErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdateOrgRoleErrorModel {
  error: UpdateOrgRoleErrorModelError;
}

export interface RemoveFromOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveFromOrgErrorModel {
  error: RemoveFromOrgErrorModelError;
}

export interface GetForOrgOKResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The date when the user joined the organization
  */
  joinedAt: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role the user has within the organization
  */
  role: string;
}

export interface GetForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetForOrgErrorModel {
  error: GetForOrgErrorModelError;
}

export interface ListForOrgOKResponseItem {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The date when the user joined the organization
  */
  joinedAt: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role the user has within the organization
  */
  role: string;
}

export interface ListForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListForOrgErrorModel {
  error: ListForOrgErrorModelError;
}

export interface ListAllTestersForOrgOKResponseItem {
  /**
   * The full name of the tester. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The unique name that is used to identify the tester.
  */
  name: string;
  /**
   * The email address of the tester
  */
  email: string;
}

export interface ListAllTestersForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListAllTestersForOrgErrorModel {
  error: ListAllTestersForOrgErrorModelError;
}

export interface RemoveUserErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveUserErrorModel {
  error: RemoveUserErrorModelError;
}

export interface GetUsersOKResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role of the user has within the team
  */
  role: any;
}

export interface GetUsersErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetUsersErrorModel {
  error: GetUsersErrorModelError;
}

export interface UserEmail {
  /**
   * The user's email address
  */
  userEmail: string;
}

export interface AddUserCreatedResponse {
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The role of the user has within the team
  */
  role: any;
}

export interface AddUserErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddUserErrorModel {
  error: AddUserErrorModelError;
}

export interface Team {
  /**
   * The permissions all members of the team have on the app
  */
  permissions: string[];
}

/**
 * The information about the app's owner
*/
export interface UpdatePermissionsOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface UpdatePermissionsOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface UpdatePermissionsOKResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: UpdatePermissionsOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: UpdatePermissionsOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
  /**
   * The permissions the team has for the app
  */
  teamPermissions?: string[];
}

export interface UpdatePermissionsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdatePermissionsErrorModel {
  error: UpdatePermissionsErrorModelError;
}

export interface RemoveAppErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveAppErrorModel {
  error: RemoveAppErrorModelError;
}

export interface App {
  /**
   * The name of the app to be added to the distribution group
  */
  name: string;
}

/**
 * The information about the app's owner
*/
export interface AddAppCreatedResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface AddAppCreatedResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface AddAppCreatedResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: AddAppCreatedResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: AddAppCreatedResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
  /**
   * The permissions the team has for the app
  */
  teamPermissions?: string[];
}

export interface AddAppErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddAppErrorModel {
  error: AddAppErrorModelError;
}

/**
 * The information about the app's owner
*/
export interface ListAppsOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface ListAppsOKResponseItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListAppsOKResponseItem {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: ListAppsOKResponseItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: ListAppsOKResponseItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
  /**
   * The permissions the team has for the app
  */
  teamPermissions?: string[];
}

export interface ListAppsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListAppsErrorModel {
  error: ListAppsErrorModelError;
}

export interface GetTeamOKResponse {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface GetTeamErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetTeamErrorModel {
  error: GetTeamErrorModelError;
}

export interface DeleteErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteErrorModel {
  error: DeleteErrorModelError;
}

export interface TeamModel {
  /**
   * The new display name of the team
  */
  displayName: string;
}

export interface UpdateOKResponseModel {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface ListAllOKResponseItem {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface ListAllErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListAllErrorModel {
  error: ListAllErrorModelError;
}

export interface TeamModelModel {
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The name of the team
  */
  name?: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface CreateTeamCreatedResponseItem {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
}

export interface CreateTeamErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateTeamErrorModel {
  error: CreateTeamErrorModelError;
}

export interface UnnamedMethodErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UnnamedMethodErrorModel {
  error: UnnamedMethodErrorModelError;
}

export interface Role {
  /**
   * The role of the user to be added. Possible values include: 'admin', 'collaborator', 'member'
  */
  role?: string;
}

export interface SendNewInvitationErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SendNewInvitationErrorModel {
  error: SendNewInvitationErrorModelError;
}

export interface UserRole {
  /**
   * The user's role in the organizatiion. Possible values include: 'admin', 'collaborator',
   * 'member'
  */
  role?: string;
}

export interface UserEmailModel {
  /**
   * The user's email address
  */
  userEmail: string;
  /**
   * The user's role. Possible values include: 'admin', 'collaborator', 'member'
  */
  role?: string;
}

export interface CreateErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateErrorModel {
  error: CreateErrorModelError;
}

export interface ListPendingOKResponseItem {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The role assigned to the invited user
  */
  role: string;
}

export interface ListPendingErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListPendingErrorModel {
  error: ListPendingErrorModelError;
}

/**
 * The information about the app's owner
*/
export interface DetailsForOrgOKResponseItemAppsItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface DetailsForOrgOKResponseItemAppsItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface DetailsForOrgOKResponseItemAppsItem {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: DetailsForOrgOKResponseItemAppsItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: DetailsForOrgOKResponseItemAppsItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface DetailsForOrgOKResponseItem {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
  /**
   * The count of apps associated with this distribution group
  */
  totalAppsCount: number;
  /**
   * The count of users in the distribution group
  */
  totalUsersCount: number;
  /**
   * The apps associated with the distribution group
  */
  apps: DetailsForOrgOKResponseItemAppsItem[];
}

export interface DetailsForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DetailsForOrgErrorModel {
  error: DetailsForOrgErrorModelError;
}

export interface Members {
  /**
   * The list of emails of the users
  */
  userEmails?: string[];
}

export interface ResendSharedInviteErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ResendSharedInviteErrorModel {
  error: ResendSharedInviteErrorModelError;
}

export interface ListUsersForOrgOKResponseItem {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface ListUsersForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListUsersForOrgErrorModel {
  error: ListUsersForOrgErrorModelError;
}

export interface MemberEmails {
  /**
   * The list of emails of the users
  */
  userEmails?: string[];
}

export interface AddUsersForOrgOKResponseItem {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The message of the result
  */
  message?: string;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface AddUsersForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddUsersForOrgErrorModel {
  error: AddUsersForOrgErrorModelError;
}

export interface AppsAppsItem {
  /**
   * The name of the app to be deleted from the distribution group
  */
  name: string;
}

export interface Apps {
  /**
   * The list of apps to delete from the distribution group
  */
  apps?: AppsAppsItem[];
}

/**
 * The information about the app's owner
*/
export interface GetAppsOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface GetAppsOKResponseItem {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: GetAppsOKResponseItemOwner;
  /**
   * The platform of the app
  */
  platform?: string;
  /**
   * The creation origin of this app
  */
  origin?: string;
}

export interface AppsAppsItemModel {
  /**
   * The name of the app to be added to the distribution group
  */
  name: string;
}

export interface AppsModel {
  /**
   * The list of apps to add to distribution group
  */
  apps?: AppsAppsItemModel[];
}

export interface GetForOrgOKResponseModel {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface DistributionGroupModel {
  /**
   * The name of the distribution group
  */
  name?: string;
  /**
   * Whether the distribution group is public
  */
  isPublic?: boolean;
}

export interface PatchForOrgOKResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface PatchForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface PatchForOrgErrorModel {
  error: PatchForOrgErrorModelError;
}

export interface DeleteForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteForOrgErrorModel {
  error: DeleteForOrgErrorModelError;
}

export interface DistributionGroupModelModel {
  /**
   * The name of the distribution group
  */
  name: string;
  /**
   * The display name of the distribution group. If not specified, the name will be used.
  */
  displayName?: string;
}

export interface CreateForOrgCreatedResponse {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface CreateForOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateForOrgErrorModel {
  error: CreateForOrgErrorModelError;
}

export interface ListForOrgCreatedResponseItem {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface ListForOrgOKResponseItemModel {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface UpdateAvatarOKResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface UpdateAvatarErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdateAvatarErrorModel {
  error: UpdateAvatarErrorModelError;
}

export interface DeleteAvatarOKResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface DeleteAvatarErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteAvatarErrorModel {
  error: DeleteAvatarErrorModelError;
}

export interface AppModel {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The descriptive name of the app. This can contain any characters
  */
  displayName: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Xamarin', 'Unity', 'Electron', 'WPF', 'WinForms', 'Custom'
  */
  platform: string;
}

/**
 * The information about the app's owner
*/
export interface CreateForOrgOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface CreateForOrgOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface CreateForOrgOKResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: CreateForOrgOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: CreateForOrgOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface CreateForOrgCreatedResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface CreateForOrgCreatedResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface CreateForOrgCreatedResponseModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: CreateForOrgCreatedResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: CreateForOrgCreatedResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface ListForOrgOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface ListForOrgOKResponseItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListForOrgOKResponseItemModelModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: ListForOrgOKResponseItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: ListForOrgOKResponseItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface GetOKResponseModel {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface Org {
  /**
   * The full (friendly) name of the organization.
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface UpdateOKResponseModelModel {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

/**
 * Billing Plan
*/
export interface GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetForOrgOKResponseBillingPlansBuildService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: GetForOrgOKResponseBillingPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetForOrgOKResponseBillingPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: GetForOrgOKResponseBillingPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface GetForOrgOKResponseBillingPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: GetForOrgOKResponseBillingPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: GetForOrgOKResponseBillingPlansTestService;
}

/**
 * Usage for a single period
*/
export interface GetForOrgOKResponseUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetForOrgOKResponseUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetForOrgOKResponseUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface GetForOrgOKResponseUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetForOrgOKResponseUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetForOrgOKResponseUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface GetForOrgOKResponseUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: GetForOrgOKResponseUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: GetForOrgOKResponseUsageTestService;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface GetForOrgOKResponseModelModel {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  /**
   * Billing Plans section in the Billing Information
  */
  billingPlans?: GetForOrgOKResponseBillingPlans;
  /**
   * Usage section in the Billing Information
  */
  usage?: GetForOrgOKResponseUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

export interface GetForOrgErrorModelErrorModel {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface GetForOrgErrorModel1 {
  error?: GetForOrgErrorModelErrorModel;
}

export interface Organization {
  /**
   * The display name of the organization
  */
  displayName?: string;
  /**
   * The name of the organization used in URLs
  */
  name?: string;
}

export interface CreateOrUpdateCreatedResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface CreateOrUpdateErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateOrUpdateErrorModel {
  error: CreateOrUpdateErrorModelError;
}

export interface ListOKResponseItem {
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
}

export interface ListErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListErrorModel {
  error: ListErrorModelError;
}

export interface UpdateCheckOKResponseUpdateInfo {
  appVersion?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  downloadURL?: string;
  isAvailable: boolean;
  packageSize?: number;
  shouldRunBinaryVersion?: boolean;
  updateAppVersion?: boolean;
  packageHash?: string;
  label?: string;
}

export interface UpdateCheckOKResponse {
  updateInfo: UpdateCheckOKResponseUpdateInfo;
}

export interface UpdateCheckErrorModel {
  message: string;
}

export interface ReleaseMetadataModel {
  deploymentKey?: string;
  label?: string;
  appVersion?: string;
  previousDeploymentKey?: string;
  previousLabelOrAppVersion?: string;
  status?: string;
  clientUniqueId?: string;
}

export interface UpdateDownloadStatusErrorModel {
  message: string;
}

export interface UpdateInstallsStatusErrorModel {
  message: string;
}

export interface SentOKResponseItemOrganization {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

/**
 * The information about the app's owner
*/
export interface SentOKResponseItemAppOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface SentOKResponseItemAppAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface SentOKResponseItemApp {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: SentOKResponseItemAppOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: SentOKResponseItemAppAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface SentOKResponseItem {
  /**
   * The id of the invitation
  */
  invitationId: string;
  organization?: SentOKResponseItemOrganization;
  app?: SentOKResponseItemApp;
}

export interface SentErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SentErrorModel {
  error: SentErrorModelError;
}

/**
 * Billing Plan
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?:
  GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?:
  GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansBuildService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?:
  GetAllOKResponseAggregatedBillingsBillingPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?:
  GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?:
  GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?:
  GetAllOKResponseAggregatedBillingsBillingPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface GetAllOKResponseAggregatedBillingsBillingPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: GetAllOKResponseAggregatedBillingsBillingPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: GetAllOKResponseAggregatedBillingsBillingPlansTestService;
}

/**
 * Usage for a single period
*/
export interface GetAllOKResponseAggregatedBillingsUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetAllOKResponseAggregatedBillingsUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetAllOKResponseAggregatedBillingsUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface GetAllOKResponseAggregatedBillingsUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetAllOKResponseAggregatedBillingsUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetAllOKResponseAggregatedBillingsUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface GetAllOKResponseAggregatedBillingsUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: GetAllOKResponseAggregatedBillingsUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: GetAllOKResponseAggregatedBillingsUsageTestService;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface GetAllOKResponseAggregatedBillings {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  /**
   * Billing Plans section in the Billing Information
  */
  billingPlans?: GetAllOKResponseAggregatedBillingsBillingPlans;
  /**
   * Usage section in the Billing Information
  */
  usage?: GetAllOKResponseAggregatedBillingsUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

/**
 * Aggregated Billing Information for a user an the organizations in which the user is an admin.
*/
export interface GetAllOKResponse {
  /**
   * Aggregated Billing Information for a user or an organization
  */
  aggregatedBillings?: GetAllOKResponseAggregatedBillings;
}

export interface GetAllErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface GetAllErrorModel {
  error?: GetAllErrorModelError;
}

export interface ListForUserOKResponseItem {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListForUserErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListForUserErrorModel {
  error: ListForUserErrorModelError;
}

/**
 * The Xcode version
*/
export interface ListXcodeVersionsOKResponseItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

export interface ListXcodeVersionsErrorModel {
  id: string;
  code: string;
  message: string;
}

/**
 * The Xamarin SDK bundle
*/
export interface ListXamarinSDKBundlesOKResponseItem {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

export interface ListXamarinSDKBundlesErrorModel {
  id: string;
  code: string;
  message: string;
}

/**
 * Alerting webhook
*/
export interface ListOKResponseValuesItem {
  /**
   * The unique id (UUID) of the webhook
  */
  id?: string;
  /**
   * display name of the webhook
  */
  name: string;
  /**
   * target url of the webhook
  */
  url: string;
  /**
   * Allows eanble/disable webhook
  */
  enabled?: boolean;
  /**
   * Event types enabled for webhook
  */
  eventTypes: string[];
}

/**
 * List of alerting webhooks wrapped as operation result
*/
export interface ListOKResponse {
  values: ListOKResponseValuesItem[];
}

/**
 * Alerting service error
*/
export interface ListErrorModel1 {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

export interface GetAppVersionsOKResponseItem {
  appVersionId: string;
  appId: string;
  displayName: string;
  appVersion: string;
  buildNumber?: string;
}

export interface GetAppVersionsErrorModel {
  message: string;
}

export interface UserAppPermissionsData {
  /**
   * The permissions the user has for the app
  */
  permissions: string[];
}

export interface UpdateUserPermissionsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdateUserPermissionsErrorModel {
  error: UpdateUserPermissionsErrorModelError;
}

export interface ListOKResponseItemModel {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface GetDeviceSetOfUserOKResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface GetDeviceSetOfUserOKResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface GetDeviceSetOfUserOKResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface GetDeviceSetOfUserOKResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: GetDeviceSetOfUserOKResponseDeviceConfigurationsItemImage;
  model?: GetDeviceSetOfUserOKResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface GetDeviceSetOfUserOKResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: GetDeviceSetOfUserOKResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: GetDeviceSetOfUserOKResponseDeviceConfigurationsItem[];
}

/**
 * @summary Device Set update information
 * @description The name of the device set and the list of device IDs
*/
export interface DeviceSetModelModel {
  /**
   * List of device IDs
  */
  devices: string[];
  /**
   * The name of the device set
  */
  name: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface UpdateDeviceSetOfUserOKResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItemImage;
  model?: UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface UpdateDeviceSetOfUserOKResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: UpdateDeviceSetOfUserOKResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: UpdateDeviceSetOfUserOKResponseDeviceConfigurationsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface UpdateDeviceSetOfUserBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface ListDeviceSetsOfUserOKResponseItemOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItemImage;
  model?: ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface ListDeviceSetsOfUserOKResponseItem {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: ListDeviceSetsOfUserOKResponseItemOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: ListDeviceSetsOfUserOKResponseItemDeviceConfigurationsItem[];
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface CreateDeviceSetOfUserCreatedResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItemImage;
  model?: CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface CreateDeviceSetOfUserCreatedResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: CreateDeviceSetOfUserCreatedResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: CreateDeviceSetOfUserCreatedResponseDeviceConfigurationsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface CreateDeviceSetOfUserBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

export interface TransferToOrgOKResponse {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface TransferToOrgErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface TransferToOrgErrorModel {
  error: TransferToOrgErrorModelError;
}

/**
 * The information about the app's owner
*/
export interface TransferOwnershipOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface TransferOwnershipOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface TransferOwnershipOKResponse {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: TransferOwnershipOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: TransferOwnershipOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface TransferOwnershipErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface TransferOwnershipErrorModel {
  error: TransferOwnershipErrorModelError;
}

/**
 * The Xamarin SDK bundle
*/
export interface ListToolsetsOKResponseXamarinItem {
  /**
   * The Mono version
  */
  monoVersion?: string;
  /**
   * The Xamarin SDK version
  */
  sdkBundle?: string;
  /**
   * If the SDK is latest stable
  */
  current?: boolean;
  /**
   * If the SDK is stable
  */
  stable?: boolean;
  /**
   * Specific for iOS SDK. A list of Xcode versions supported by current SDK version
  */
  xcodeVersions?: string[];
}

/**
 * The Xcode version
*/
export interface ListToolsetsOKResponseXcodeItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Xcode is latest stable
  */
  current?: boolean;
}

/**
 * The Node version
*/
export interface ListToolsetsOKResponseNodeItem {
  /**
   * The version name
  */
  name?: string;
  /**
   * If the Node version is default for AppCenter
  */
  current?: boolean;
}

/**
 * Set of toolsets available for app
*/
export interface ListToolsetsOKResponse {
  /**
   * A list of Xamarin SDK bundles
  */
  xamarin?: ListToolsetsOKResponseXamarinItem[];
  /**
   * A list of Xcode versions
  */
  xcode?: ListToolsetsOKResponseXcodeItem[];
  /**
   * A list of Node versions
  */
  node?: ListToolsetsOKResponseNodeItem[];
}

export interface ListToolsetsErrorModel {
  id: string;
  code: string;
  message: string;
}

export interface DeleteTesterFromDestinationsNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListTestersOKResponseItem {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

export interface ListTestersErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListTestersErrorModel {
  error: ListTestersErrorModelError;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetAllTestRunsForSeriesOKResponseItemStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetAllTestRunsForSeriesOKResponseItem {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: GetAllTestRunsForSeriesOKResponseItemStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Name of the test series
*/
export interface Name {
  /**
   * Name of the new test series
  */
  name: string;
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface PatchTestSeriesOKResponseTestRunsItem {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Test Series
 * @description Summary of a single test series
*/
export interface PatchTestSeriesOKResponse {
  /**
   * Unique, human-readable identifier of the test series
  */
  slug: string;
  /**
   * Name of the test series
  */
  name: string;
  /**
   * Date of the latest test run that used this test series
  */
  mostRecentActivity?: string;
  /**
   * Most recent test runs
  */
  testRuns?: PatchTestSeriesOKResponseTestRunsItem[];
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface GetAllTestSeriesOKResponseItemTestRunsItem {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Test Series
 * @description Summary of a single test series
*/
export interface GetAllTestSeriesOKResponseItem {
  /**
   * Unique, human-readable identifier of the test series
  */
  slug: string;
  /**
   * Name of the test series
  */
  name: string;
  /**
   * Date of the latest test run that used this test series
  */
  mostRecentActivity?: string;
  /**
   * Most recent test runs
  */
  testRuns?: GetAllTestSeriesOKResponseItemTestRunsItem[];
}

/**
 * @summary Name of the test series
*/
export interface TestSeriesNameModel {
  /**
   * Name of the new test series
  */
  name: string;
}

/**
 * @summary Test Run Summary
 * @description Most important information about a test run.
*/
export interface CreateTestSeriesOKResponseTestRunsItem {
  /**
   * Date of the test run.
  */
  date?: string;
  /**
   * Human-readable status of the test run.
  */
  statusDescription?: string;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Tells whether the test run has completed
  */
  completed?: boolean;
}

/**
 * @summary Test Series
 * @description Summary of a single test series
*/
export interface CreateTestSeriesOKResponse {
  /**
   * Unique, human-readable identifier of the test series
  */
  slug: string;
  /**
   * Name of the test series
  */
  name: string;
  /**
   * Date of the latest test run that used this test series
  */
  mostRecentActivity?: string;
  /**
   * Most recent test runs
  */
  testRuns?: CreateTestSeriesOKResponseTestRunsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface CreateTestSeriesBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface StopTestRunOKResponseStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface StopTestRunOKResponse {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: StopTestRunOKResponseStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Test Run State
 * @description Current status of a test run
*/
export interface GetTestRunStateOKResponse {
  /**
   * Multi-line message that describes the status
  */
  message?: string[];
  /**
   * Time (in seconds) that the client should wait for before checking the status again
  */
  waitTime?: number;
  /**
   * The exit code that the client should use when exiting. Used for indicating status to the
   * caller of the client.
   * 0: test run completes with no failing tests
   * 1: test run completes with at least one failing test
   * 2: test run failed to complete. Status for test run is unknown

  */
  exitCode?: number;
}

/**
 * @summary Test Cloud Start Test Run Options
 * @description Options required to start the test run
*/
export interface StartOptions {
  /**
   * Test framework used by tests.
  */
  testFramework: string;
  /**
   * Device selection string.
  */
  deviceSelection: string;
  /**
   * Language that should be used to run tests.
  */
  language?: string;
  /**
   * Locale that should be used to run tests.
  */
  locale?: string;
  /**
   * Name of the test series.
  */
  testSeries?: string;
  /**
   * A JSON dictionary with additional test parameters
  */
  testParameters?: any;
}

/**
 * @summary Test Cloud Test Run Start Result
 * @description Result of starting a test run
*/
export interface StartTestRunOKResponse {
  /**
   * List with names of accepted devices
  */
  acceptedDevices?: string[];
  /**
   * List with names and descriptions of rejected devices
  */
  rejectedDevices?: string[];
}

export interface GetTestReportOKResponseStats {
  os: number;
  devices: number;
  filesize: number;
  totalDeviceMinutes: number;
  devicesNotRunned: number;
  failed: number;
  skipped: number;
  passed: number;
  total: number;
  devicesFinished: number;
  devicesFailed: number;
  devicesSkipped: number;
  stepCount: number;
  artifacts?: { [propertyName: string]: string };
}

export interface GetTestReportOKResponseFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem {
  deviceSnapshotId?: string;
  status?: string;
  timestamp?: number;
}

export interface GetTestReportOKResponseFeaturesItemTestsItemRunsItemStepsItem {
  stepName?: string;
  id?: string;
  stepExecutions?:
  GetTestReportOKResponseFeaturesItemTestsItemRunsItemStepsItemStepExecutionsItem[];
  failed?: number;
  skipped?: number;
  stepReportUrl?: string;
}

export interface GetTestReportOKResponseFeaturesItemTestsItemRunsItem {
  number?: number;
  steps?: GetTestReportOKResponseFeaturesItemTestsItemRunsItemStepsItem[];
  failed?: number;
  skipped?: number;
  reportUrl?: string;
  id?: string;
}

export interface GetTestReportOKResponseFeaturesItemTestsItem {
  testName?: string;
  runs?: GetTestReportOKResponseFeaturesItemTestsItemRunsItem[];
  peakMemory?: number;
  peakDuration?: number;
}

export interface GetTestReportOKResponseFeaturesItem {
  name?: string;
  tests?: GetTestReportOKResponseFeaturesItemTestsItem[];
  failed?: number;
  skipped?: number;
  peakMemory?: number;
  peakDuration?: number;
}

export interface GetTestReportOKResponseDeviceLogsItem {
  deviceSnapshotId?: string;
  deviceLog?: string;
  testLog?: string;
  appiumLog?: string;
}

export interface GetTestReportOKResponseSnapshotFatalErrorsItem {
  deviceSnapshotId?: string;
  errorMessage?: string;
  errorTitle?: string;
}

export interface GetTestReportOKResponse {
  appUploadId: string;
  date: string;
  testType: string;
  platform: string;
  stats: GetTestReportOKResponseStats;
  id: string;
  schemaVersion: number;
  revision: number;
  features: GetTestReportOKResponseFeaturesItem[];
  finishedDeviceSnapshots: string[];
  deviceLogs: GetTestReportOKResponseDeviceLogsItem[];
  dateFinished: string;
  errorMessage?: string;
  snapshotFatalErrors?: GetTestReportOKResponseSnapshotFatalErrorsItem[];
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface FileInfoItem {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
}

/**
 * @summary Test Cloud Hash Upload Status
 * @description Status of the upload
*/
export interface UploadHashesBatchOKResponseItemUploadStatus {
  /**
   * HTTP status code that represent result of upload
  */
  statusCode: number;
  /**
   * URI that should be used to make POST request if file with given hash doesn't exist. This is
   * set when status_code is equal to 412
  */
  location?: string;
}

/**
 * @summary Test Cloud File Hash Response
 * @description Response message for single uploaded file hash
*/
export interface UploadHashesBatchOKResponseItem {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath?: string;
  /**
   * @summary Test Cloud Hash Upload Status
   * @description Status of the upload
  */
  uploadStatus: UploadHashesBatchOKResponseItemUploadStatus;
}

/**
 * @summary Test Cloud File Hash
 * @description Hash, type, path and byte range of a file that is required in test run
*/
export interface FileInfo {
  /**
   * Type of the file. Possible values include: 'dsym-file', 'app-file', 'test-file'
  */
  fileType: string;
  /**
   * SHA256 hash of the file
  */
  checksum: string;
  /**
   * Relative path of the file
  */
  relativePath: string;
  /**
   * Range of bytes required to verify ownership of the file
  */
  byteRange?: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetTestRunOKResponseStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetTestRunOKResponse {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: GetTestRunOKResponseStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface ArchiveTestRunOKResponseStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface ArchiveTestRunOKResponse {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: ArchiveTestRunOKResponseStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

/**
 * @summary Test Run Statistics
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetTestRunsOKResponseItemStats {
  /**
   * Number of devices running the test
  */
  devices?: number;
  /**
   * Number of finished devices
  */
  devicesFinished?: number;
  /**
   * Number of failed devices
  */
  devicesFailed?: number;
  /**
   * Number of tests in total
  */
  total?: number;
  /**
   * Number of passed tests
  */
  passed?: number;
  /**
   * Number of failed tests
  */
  failed?: number;
  /**
   * Number of skipped tests
  */
  skipped?: number;
  /**
   * The max amount of MB used during the test run
  */
  peakMemory?: number;
  /**
   * The number of minutes of device time the test has been runnign
  */
  totalDeviceMinutes?: number;
}

/**
 * @summary Test Run
 * @description Summary single test run on Xamarin Test Cloud
*/
export interface GetTestRunsOKResponseItem {
  /**
   * The unique id of the test upload
  */
  id?: string;
  /**
   * The date and time the test was uploaded
  */
  date?: string;
  /**
   * The compiled version of the app binary
  */
  appVersion?: string;
  /**
   * The name of the test series with which this test upload is associated
  */
  testSeries?: string;
  /**
   * The device platform targeted by the test. Possible values are 'ios' or 'android'
  */
  platform?: string;
  /**
   * The current status of the test run, in relation to the various phases
  */
  runStatus?: string;
  /**
   * The passed/failed state
  */
  resultStatus?: string;
  /**
   * Deprecated. Use runStatus instead.
  */
  state?: string;
  /**
   * Deprecated. Use resultStatus instead.
  */
  status?: string;
  /**
   * Human readable explanation of the current test status
  */
  description?: string;
  /**
   * @summary Test Run Statistics
   * @description Summary single test run on Xamarin Test Cloud
  */
  stats?: GetTestRunsOKResponseItemStats;
  /**
   * The name of the test framework used to run this test
  */
  testType?: string;
}

export interface GdprExportTestRunOKResponse {
  id?: string;
  appHashFileId?: string;
  locale?: string;
  dsymHashFileId?: string;
  appHashFileUrl?: string;
  dsymHashFileUrl?: string;
  appIconUrl?: string;
}

export interface GdprExportPipelineTestOKResponse {
  appUploadId?: string;
  testParameters?: any;
}

export interface GdprExportHashFileOKResponse {
  id?: string;
  filename?: string;
}

export interface GdprExportFileSetFileOKResponse {
  path?: string;
  hashFileId?: string;
  appUploadId?: string;
  hashFileUrl?: string;
}

export interface GdprExportAppOKResponse {
  hashFilesUrl?: string;
}

export interface GdprExportAppsOKResponseResourcesItem {
  rel?: string;
  path?: string;
}

export interface GdprExportAppsOKResponse {
  resources?: GdprExportAppsOKResponseResourcesItem[];
}

export interface GetTeamsOKResponseItem {
  /**
   * The internal unique id (UUID) of the team.
  */
  id: string;
  /**
   * The name of the team
  */
  name: string;
  /**
   * The display name of the team
  */
  displayName: string;
  /**
   * The description of the team
  */
  description?: string;
  /**
   * The permissions the team has for the app
  */
  permissions?: string[];
}

export interface GetTeamsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetTeamsErrorModel {
  error: GetTeamsErrorModelError;
}

/**
 * A response containing information pertaining to a symbol status
*/
export interface GetStatusOKResponse {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored', 'missing'
  */
  status: string;
}

export interface GetStatusForbiddenResponse {
  message: string;
}

export interface GetStatusNotFoundResponse {
  message: string;
}

export interface GetStatusInternalServerErrorResponse {
  message: string;
}

/**
 * Location for downloading symbol
*/
export interface GetLocationOKResponse {
  uri: string;
}

export interface GetLocationForbiddenResponse {
  message: string;
}

export interface GetLocationNotFoundResponse {
  message: string;
}

export interface GetLocationInternalServerErrorResponse {
  message: string;
}

export interface IgnoreOKResponse {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

export interface IgnoreForbiddenResponse {
  message: string;
}

export interface IgnoreNotFoundResponse {
  message: string;
}

export interface IgnoreInternalServerErrorResponse {
  message: string;
}

export interface GetOKResponseModelModel {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

export interface GetForbiddenResponse {
  message: string;
}

export interface GetNotFoundResponse {
  message: string;
}

export interface GetInternalServerErrorResponse {
  message: string;
}

export interface ListOKResponseItemModelModel {
  /**
   * The unique id for this symbol (uuid)
  */
  symbolId: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  type: string;
  /**
   * The application that this symbol belongs to
  */
  appId: string;
  /**
   * The platform that this symbol is associated with
  */
  platform: string;
  /**
   * The path name of the symbol file in blob storage
  */
  url: string;
  /**
   * The origin of the symbol file. Possible values include: 'System', 'User'
  */
  origin: string;
  /**
   * The other symbols in the same file
  */
  alternateSymbolIds: string[];
  /**
   * Whether the symbol is ignored. Possible values include: 'available', 'ignored'
  */
  status: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The id of the symbol upload this symbol belongs to.
  */
  symbolUploadId: string;
}

export interface ListForbiddenResponse {
  message: string;
}

export interface ListInternalServerErrorResponse {
  message: string;
}

/**
 * Location for downloading symbol upload
*/
export interface GetLocationOKResponseModel {
  uri: string;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface GetOKResponseUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface GetOKResponseSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface GetOKResponseModelModelModel {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: GetOKResponseUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: GetOKResponseSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

/**
 * A request containing information pertaining to completing a symbol upload process
*/
export interface BodyModel {
  /**
   * The desired operation for the symbol upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface CompleteOKResponseUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface CompleteOKResponseSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface CompleteOKResponse {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: CompleteOKResponseUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: CompleteOKResponseSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

export interface CompleteBadRequestResponse {
  message: string;
}

export interface CompleteForbiddenResponse {
  message: string;
}

export interface CompleteInternalServerErrorResponse {
  message: string;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface DeleteOKResponseUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface DeleteOKResponseSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface DeleteOKResponse {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: DeleteOKResponseUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: DeleteOKResponseSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

export interface DeleteForbiddenResponse {
  message: string;
}

export interface DeleteNotFoundResponse {
  message: string;
}

export interface DeleteInternalServerErrorResponse {
  message: string;
}

/**
 * User information of the one who intitiated the symbol upload
*/
export interface ListOKResponseItemUser {
  /**
   * The email of the user
  */
  email?: string;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
}

export interface ListOKResponseItemSymbolsUploadedItem {
  /**
   * The symbol id of the symbol binary
  */
  symbolId: string;
  /**
   * The platform the symbol is associated with
  */
  platform: string;
}

/**
 * A single symbol upload entity
*/
export interface ListOKResponseItemModelModelModel {
  /**
   * The id for the current symbol upload
  */
  symbolUploadId: string;
  /**
   * The application that this symbol upload belongs to
  */
  appId: string;
  /**
   * User information of the one who intitiated the symbol upload
  */
  user?: ListOKResponseItemUser;
  /**
   * The current status for the symbol upload. Possible values include: 'created', 'committed',
   * 'aborted', 'processing', 'indexed', 'failed'
  */
  status: string;
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The symbols found in the upload. This may be empty until the status is indexed
  */
  symbolsUploaded?: ListOKResponseItemSymbolsUploadedItem[];
  /**
   * The origin of the symbol upload. Possible values include: 'User', 'System'
  */
  origin?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The size of the file in Mebibytes. This may be 0 until the status is indexed
  */
  fileSize?: number;
  /**
   * When the symbol upload was committed, or last transaction time if not committed
  */
  timestamp?: Date;
}

/**
 * A request containing information pertaining to starting a symbol upload process
*/
export interface BodyModelModel {
  /**
   * The type of the symbol for the current symbol upload. Possible values include: 'Apple',
   * 'JavaScript', 'Breakpad', 'AndroidProguard', 'UWP'
  */
  symbolType: string;
  /**
   * The callback URL that the client can optionally provide to get status updates for the current
   * symbol upload
  */
  clientCallback?: string;
  /**
   * The file name for the symbol upload
  */
  fileName?: string;
  /**
   * The build number. Optional for Apple. Required for Android.
  */
  build?: string;
  /**
   * The version number. Optional for Apple. Required for Android.
  */
  version?: string;
}

/**
 * A response containing information pertaining to starting a symbol upload process
*/
export interface CreateOKResponse {
  /**
   * The id for the current upload
  */
  symbolUploadId: string;
  /**
   * The URL where the client needs to upload the symbol blob to
  */
  uploadUrl: string;
  /**
   * Describes how long the upload_url is valid
  */
  expirationDate: Date;
}

export interface CreateBadRequestResponse {
  message: string;
}

export interface CreateForbiddenResponse {
  message: string;
}

export interface CreateInternalServerErrorResponse {
  message: string;
}

/**
 * @summary Subscription Tier
*/
export interface GetSubscriptionsOKResponseTier {
  /**
   * The name of the tier
  */
  name?: string;
}

/**
 * @summary Subscription
 * @description Subscription information
*/
export interface GetSubscriptionsOKResponse {
  /**
   * The date the subscription began
  */
  startsAt?: string;
  /**
   * The date the subscription will end or ended
  */
  endsAt?: string;
  /**
   * The number of days left in the subscription
  */
  daysLeft?: number;
  /**
   * @summary Subscription Tier
  */
  tier?: GetSubscriptionsOKResponseTier;
  /**
   * Is the subscription currently active?
  */
  active?: boolean;
  /**
   * Id of the subscription
  */
  id?: string;
}

/**
 * @summary Subscription Tier
*/
export interface CreateSubscriptionCreatedResponseTier {
  /**
   * The name of the tier
  */
  name?: string;
}

/**
 * @summary Subscription
 * @description Subscription information
*/
export interface CreateSubscriptionCreatedResponse {
  /**
   * The date the subscription began
  */
  startsAt?: string;
  /**
   * The date the subscription will end or ended
  */
  endsAt?: string;
  /**
   * The number of days left in the subscription
  */
  daysLeft?: number;
  /**
   * @summary Subscription Tier
  */
  tier?: CreateSubscriptionCreatedResponseTier;
  /**
   * Is the subscription currently active?
  */
  active?: boolean;
  /**
   * Id of the subscription
  */
  id?: string;
}

export interface GetNotificationByAppIdOKResponse {
  service?: string;
  status?: string;
  validUntil?: number;
}

export interface GetNotificationByAppIdErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * The source repository
*/
export interface ListOKResponseItemModelModelModelModel {
  /**
   * The repository name
  */
  name?: string;
  /**
   * URL used to clone the repository
  */
  cloneUrl?: string;
}

export interface ListErrorModel2 {
  id: string;
  code: string;
  message: string;
}

export interface ListOKResponseItemModelModelModelModelModel {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
  /**
   * The GitHub App Installation id. Required for repositories connected from GitHub App
  */
  installationId?: string;
  /**
   * Repository configuration identifier
  */
  id: string;
  /**
   * Type of repository
  */
  type: string;
  /**
   * State of the configuration. Possible values include: 'unauthorized', 'inactive', 'active'
  */
  state: string;
  /**
   * Email of the user who linked the repository
  */
  userEmail?: string;
}

export interface ListErrorModel3 {
  id: string;
  code: string;
  message: string;
}

export interface Repo {
  /**
   * The repository's git url, must be a HTTPS URL
  */
  repoUrl: string;
  /**
   * The repository id from the repository provider. Required for repositories connected from
   * GitHub App and GitLab.com
  */
  repoId?: string;
  /**
   * The external user id from the repository provider. Required for GitLab.com repositories
  */
  externalUserId?: string;
  /**
   * The id of the service connection (private). Required for GitLab self-hosted repositories
  */
  serviceConnectionId?: string;
  /**
   * The GitHub App Installation id. Required for repositories connected from GitHub App
  */
  installationId?: string;
}

export interface CreateOrUpdateOKResponse {
  message: string;
}

export interface CreateOrUpdateErrorModel1 {
  id: string;
  code: string;
  message: string;
}

export interface DeleteOKResponseModel {
  message: string;
}

export interface DeleteErrorModel1 {
  id: string;
  code: string;
  message: string;
}

/**
 * The status of the resign operation.
*/
export interface GetReleaseUpdateDevicesStatusOKResponse {
  /**
   * The status of the resign
  */
  status: string;
  /**
   * Error code for any error that occured during the resigning operation.
  */
  errorCode?: string;
  /**
   * Error message for any error that occured during the resigning operation.
  */
  errorMessage?: string;
}

export interface GetReleaseUpdateDevicesStatusBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetReleaseUpdateDevicesStatusNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DestinationTesterUpdateDetails {
  /**
   * Whether a release is mandatory for the given destination
  */
  mandatoryUpdate: boolean;
}

export interface PutDistributionTesterNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteDistributionTesterNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface BodyModelModelModel {
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Tester's email address
  */
  email: string;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface AddTestersCreatedResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate: boolean;
  /**
   * The url to check provisioning status.
  */
  provisioningStatusUrl?: string;
}

export interface AddTestersBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddTestersNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteDistributionStoreNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface BodyModelModelModelModel {
  /**
   * Unique id of the release destination
  */
  id: string;
}

export interface AddStoreCreatedResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
}

export interface AddStoreBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddStoreNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ProfileBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DestinationGroupUpdateDetails {
  /**
   * Whether a release is mandatory for the given destination
  */
  mandatoryUpdate: boolean;
}

export interface PutDistributionGroupNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteDistributionGroupNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface BodyModelModelModelModelModel {
  /**
   * Unique id of the release destination
  */
  id: string;
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate?: boolean;
  /**
   * Flag to enable or disable notifications to testers
  */
  notifyTesters?: boolean;
}

export interface AddDistributionGroupCreatedResponse {
  /**
   * Unique id for the release destination
  */
  id: string;
  /**
   * Flag to mark the release for the provided destinations as mandatory
  */
  mandatoryUpdate: boolean;
  /**
   * The url to check provisioning status.
  */
  provisioningStatusUrl?: string;
}

export interface AddDistributionGroupBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AddDistributionGroupNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetLatestByUserOKResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface GetLatestByUserOKResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface GetLatestByUserOKResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface GetLatestByUserOKResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetLatestByUserOKResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName: string;
  /**
   * The app's display name.
  */
  appDisplayName: string;
  /**
   * The app's OS.
  */
  appOs?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * Hashes for the packages.
  */
  packageHashes?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: GetLatestByUserOKResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: GetLatestByUserOKResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: GetLatestByUserOKResponseDestinationsItem[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: GetLatestByUserOKResponseBuild;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * Status of the release.
  */
  status?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface GetLatestByUserBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetLatestByUserNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface BodyBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * A request containing information for updating details of a release
*/
export interface BodyModelModelModelModelModelModel {
  /**
   * Toggle this release to be enable distribute/download or not.
  */
  enabled?: boolean;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: BodyBuild;
}

export interface UpdateDetailsOKResponseDestinationsItem {
  id?: string;
  name?: string;
}

/**
 * Response for updating a release
*/
export interface UpdateDetailsOKResponse {
  enabled?: boolean;
  mandatoryUpdate?: boolean;
  releaseNotes?: string;
  provisioningStatusUrl?: string;
  destinations?: UpdateDetailsOKResponseDestinationsItem[];
}

export interface UpdateDetailsBadRequestResponseDestinationsItem {
  /**
   * Error Codes:<br>
   * <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not
   * valid.<br>
   * <b>store_release_bad_request</b>: Proper package release details for the store is not
   * provided.<br>
   * <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid
   * developer credentials.<br>
   * <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the
   * release version and already existing version in the store.<br>
   * <b>store_release_promotion</b>: Release already distributed, promoting a release is not
   * supported.<br>
   * <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release.
   * This is not supported yet.<br>
   * <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
   * <b>store_release_not_available</b>: The release is not available.<br>
   * <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server
   * error.

  */
  code?: string;
  message?: string;
  id?: string;
  name?: string;
}

export interface UpdateDetailsBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  destinations?: UpdateDetailsBadRequestResponseDestinationsItem[];
}

export interface UpdateDetailsNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * A unique identifier for a destination. A destination can be identified by an ID (guid) or by a
 * name. DestinationId encapsulates both options. A destination can be either a distribution group
 * or a store.
*/
export interface BodyDestinationsItem {
  /**
   * Name of a distribution group / distribution store. The release will be associated with this
   * distribution group or store. If the distribution group / store doesn't exist a 400 is
   * returned. If both distribution group / store name and id are passed, the id is taking
   * precedence.
  */
  name?: string;
  /**
   * Id of a distribution group / store. The release will be associated with this distribution
   * group / store. If the distribution group / store doesn't exist a 400 is returned. If both
   * distribution group / store name and id are passed, the id is taking precedence.
  */
  id?: string;
}

/**
 * An object containing all the release metadata.
*/
export interface BodyMetadata {
  /**
   * dsa signature of the release for the sparkle feed.
  */
  dsaSignature?: string;
  /**
   * edDSA signature of the release for the sparkle feed.
  */
  edSignature?: string;
}

/**
 * A request containing information for updating a release.
*/
export interface BodyModelModelModelModelModelModelModel {
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * distribution group. The release will be associated with this distribution group. If the
   * distribution group doesn't exist a 400 is returned. If both distribution group name and id are
   * passed, the id is taking precedence.

  */
  distributionGroupName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a distribution
   * group. The release will be associated with this distribution group. If the distribution group
   * doesn't exist a 400 is returned. If both distribution group name and id are passed, the id is
   * taking precedence.

  */
  distributionGroupId?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Name of a
   * destination. The release will be associated with this destination. If the destination doesn't
   * exist a 400 is returned. If both distribution group name and id are passed, the id is taking
   * precedence.

  */
  destinationName?: string;
  /**
   * OBSOLETE. Will be removed in future releases - use destinations instead. Id of a destination.
   * The release will be associated with this destination. If the destination doesn't exist a 400
   * is returned. If both destination name and id are passed, the id is taking precedence.

  */
  destinationId?: string;
  /**
   * Not used anymore.
  */
  destinationType?: string;
  /**
   * Release notes for this release.
  */
  releaseNotes?: string;
  /**
   * A boolean which determines whether this version should be a mandatory update or not.
  */
  mandatoryUpdate?: boolean;
  /**
   * Distribute this release under the following list of destinations (store groups or distribution
   * groups).
  */
  destinations?: BodyDestinationsItem[];
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: BodyBuild;
  /**
   * A boolean which determines whether to notify testers of a new release, default to true.
  */
  notifyTesters?: boolean;
  /**
   * An object containing all the release metadata.
  */
  metadata?: BodyMetadata;
}

/**
 * Response for updating release details
*/
export interface UpdateOKResponseModelModelModel {
  releaseNotes?: string;
}

export interface UpdateBadRequestResponseDestinationsItem {
  /**
   * Error Codes:<br>
   * <b>invalid_store_secrets</b>: While distributing to store, secrets provided for store are not
   * valid.<br>
   * <b>store_release_bad_request</b>: Proper package release details for the store is not
   * provided.<br>
   * <b>store_release_unauthorized</b>: User is not authorized to publish to store due to invalid
   * developer credentials.<br>
   * <b>store_release_forbidden</b>: Publish to store is forbidden due to conflicts/errors in the
   * release version and already existing version in the store.<br>
   * <b>store_release_promotion</b>: Release already distributed, promoting a release is not
   * supported.<br>
   * <b>store_track_deactivated</b>: One or more tracks would be deactivated with this release.
   * This is not supported yet.<br>
   * <b>store_release_not_found</b>: App with the given package name is not found in the store.<br>
   * <b>store_release_not_available</b>: The release is not available.<br>
   * <b>internal_server_error</b>: Failed to distribute to a destination due to an internal server
   * error.

  */
  code?: string;
  message?: string;
  id?: string;
  name?: string;
}

export interface UpdateBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  destinations?: UpdateBadRequestResponseDestinationsItem[];
}

export interface UpdateNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteNotFoundResponseModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteInternalServerErrorResponseModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AvailableToTesterOKResponseItemDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface AvailableToTesterOKResponseItemDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface AvailableToTesterOKResponseItemDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Build information for the release

*/
export interface AvailableToTesterOKResponseItemBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Basic information on a release
*/
export interface AvailableToTesterOKResponseItem {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: AvailableToTesterOKResponseItemDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: AvailableToTesterOKResponseItemDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: AvailableToTesterOKResponseItemDestinationsItem[];
  /**
   * Build information for the release

  */
  build?: AvailableToTesterOKResponseItemBuild;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface ListOKResponseItemDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface ListOKResponseItemDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface ListOKResponseItemDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Build information for the release

*/
export interface ListOKResponseItemBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Basic information on a release
*/
export interface ListOKResponseItemModelModelModelModelModelModel {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: ListOKResponseItemDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: ListOKResponseItemDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: ListOKResponseItemDestinationsItem[];
  /**
   * Build information for the release

  */
  build?: ListOKResponseItemBuild;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

/**
 * A request containing information pertaining to complete a release upload process
*/
export interface BodyModelModelModelModelModelModelModelModel {
  /**
   * The desired operation for the upload. Possible values include: 'committed', 'aborted'
  */
  status: string;
}

/**
 * A response containing information about the uploaded release.
*/
export interface CompleteOKResponseModel {
  /**
   * The ID of the release.
  */
  releaseId?: number;
  /**
   * A URL to the new release. If upload was aborted will be null.
  */
  releaseUrl?: string;
}

/**
 * A request containing information pertaining to begin a release upload process
*/
export interface BodyModelModelModelModelModelModelModelModelModel {
  /**
   * Optional value for explicitly specifying the ID of existing release.
  */
  releaseId?: number;
  /**
   * The build version of the uploaded binary, used for macOS, Windows and Custom app support.
  */
  buildVersion?: string;
  /**
   * The build number of the uploaded binary, used with build_version for macOS app support.
  */
  buildNumber?: string;
}

/**
 * A response containing information pertaining to starting a release upload process
*/
export interface CreateCreatedResponse {
  /**
   * The ID for the current upload
  */
  uploadId: string;
  /**
   * The URL where the client needs to upload the release to
  */
  uploadUrl: string;
  /**
   * The ID for the current upload, reserved for future use
  */
  assetId?: string;
  /**
   * The URL for the current upload, reserved for future use
  */
  assetDomain?: string;
  /**
   * The token for the current upload, reserved for future use
  */
  assetToken?: string;
}

export interface ListLatestOKResponseItemDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
}

export interface ListLatestOKResponseItemDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

export interface ListLatestOKResponseItemDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Build information for the release

*/
export interface ListLatestOKResponseItemBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Basic information on a release
*/
export interface ListLatestOKResponseItem {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned. <br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: ListLatestOKResponseItemDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: ListLatestOKResponseItemDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: ListLatestOKResponseItemDestinationsItem[];
  /**
   * Build information for the release

  */
  build?: ListLatestOKResponseItemBuild;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface ConfigExistsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ConfigExistsErrorModel {
  error: ConfigExistsErrorModelError;
}

/**
 * Generic notification configuration result.
*/
export interface GetConfigOKResponse {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface GetConfigErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetConfigErrorModel {
  error: GetConfigErrorModelError;
}

/**
 * Type of notification config (NotificationConfigAppleToken, NotificationConfigGoogle,
 * NotificationConfigWindows). The 'type' property must be set to a valid value and the object must
 * include the correct properties for the specified type.
*/
export interface Properties {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Generic notification configuration result.
*/
export interface SetConfigOKResponse {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface SetConfigErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SetConfigErrorModel {
  error: SetConfigErrorModelError;
}

export interface DeleteConfigErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteConfigErrorModel {
  error: DeleteConfigErrorModelError;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface GetOKResponseNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification definition object
*/
export interface GetOKResponseNotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body?: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification failure outcome count
*/
export interface GetOKResponseFailureOutcomesItem {
  /**
   * The reason of the notification failure
  */
  failureReason?: string;
  /**
   * count of this type of failure
  */
  count?: number;
}

/**
 * Notification statistics
*/
export interface GetOKResponseModelModelModelModel {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: GetOKResponseNotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
  /**
   * Notification definition object
  */
  notificationContent: GetOKResponseNotificationContent;
  /**
   * Failture outcome counts
  */
  failureOutcomes?: GetOKResponseFailureOutcomesItem[];
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface ListOKResponseValuesItemNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification statistics
*/
export interface ListOKResponseValuesItemModel {
  /**
   * Notification id.
  */
  notificationId: string;
  /**
   * Notification name
  */
  name?: string;
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: ListOKResponseValuesItemNotificationTarget;
  /**
   * Notification send time
  */
  sendTime?: Date;
  /**
   * Number of the notifications failed to send to the push provider.
  */
  pnsSendFailure?: number;
  /**
   * Number of the notifications successfully sent to push the provider.
  */
  pnsSendSuccess?: number;
  /**
   * State of the notification. Possible values include: 'Queued', 'Sending', 'Completed',
   * 'Failed', 'NoTargetFound'
  */
  state: string;
}

/**
 * List of notifications
*/
export interface ListOKResponseModel {
  values: ListOKResponseValuesItemModel[];
  /**
   * the total count of notifications
  */
  total?: number;
  nextLink?: string;
}

/**
 * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The object
 * must include the correct properties for the specified target type except for broadcast.
*/
export interface PropertiesNotificationTarget {
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Notification definition object
*/
export interface PropertiesNotificationContent {
  /**
   * Notification name
  */
  name: string;
  /**
   * Notification title
  */
  title?: string;
  /**
   * Notification body
  */
  body?: string;
  /**
   * Notification custom data (such as badge, color, sound, etc.)
  */
  customData?: { [propertyName: string]: string };
}

/**
 * Notification definition object
*/
export interface PropertiesModel {
  /**
   * Type of Notification target (audiences, devices, user ids, account ids or broadcast). The
   * object must include the correct properties for the specified target type except for broadcast.
  */
  notificationTarget?: PropertiesNotificationTarget;
  /**
   * Notification definition object
  */
  notificationContent: PropertiesNotificationContent;
}

/**
 * Notification send succeeded.
*/
export interface SendAcceptedResponse {
  /**
   * The unique notification identifier.
  */
  notificationId: string;
}

export interface SendErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SendErrorModel {
  error: SendErrorModelError;
}

/**
 * List of notification Ids
*/
export interface NotificationIds {
  /**
   * List of notification Ids.
  */
  values: string[];
}

export interface DeleteInstallIdErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteInstallIdErrorModel {
  error: DeleteInstallIdErrorModelError;
}

/**
 * Export status
*/
export interface ExportDevicesStatusOKResponse {
  /**
   * The unique export identifier.
  */
  exportId: string;
  /**
   * Status of the export. Possible values include: 'InProgress', 'Completed', 'Failed'
  */
  status: string;
}

export interface ExportDevicesStatusErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ExportDevicesStatusErrorModel {
  error: ExportDevicesStatusErrorModelError;
}

/**
 * Generic export configuration.
*/
export interface PropertiesModelModel {
  /**
   * A shared access signature (SAS) URI with Read, Write and Delete permissions on a container.
  */
  blobContainerSasUri: string;
}

/**
 * Export started.
*/
export interface ExportDevicesAcceptedResponse {
  /**
   * The unique export identifier.
  */
  exportId: string;
}

export interface ExportDevicesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ExportDevicesErrorModel {
  error: ExportDevicesErrorModelError;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface GetDeviceSetOfOwnerOKResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItemImage;
  model?: GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface GetDeviceSetOfOwnerOKResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: GetDeviceSetOfOwnerOKResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: GetDeviceSetOfOwnerOKResponseDeviceConfigurationsItem[];
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface UpdateDeviceSetOfOwnerOKResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItemImage;
  model?: UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface UpdateDeviceSetOfOwnerOKResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: UpdateDeviceSetOfOwnerOKResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: UpdateDeviceSetOfOwnerOKResponseDeviceConfigurationsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface UpdateDeviceSetOfOwnerBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface ListDeviceSetsOfOwnerOKResponseItemOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItemImage;
  model?: ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface ListDeviceSetsOfOwnerOKResponseItem {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: ListDeviceSetsOfOwnerOKResponseItemOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: ListDeviceSetsOfOwnerOKResponseItemDeviceConfigurationsItem[];
}

/**
 * @summary Device Set Owner
 * @description The owner of a device set
*/
export interface CreateDeviceSetOfOwnerCreatedResponseOwner {
  /**
   * Type of account
  */
  type: string;
  /**
   * Account ID
  */
  id: string;
  /**
   * Display name of the account
  */
  displayName?: string;
  /**
   * Name of the account
  */
  name: string;
}

export interface CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItemImage {
  thumb?: string;
}

export interface CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItemModel {
  name?: string;
  manufacturer?: string;
  releaseDate?: string;
  formFactor?: string;
}

export interface CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItem {
  /**
   * The unique id of the device configuration
  */
  id?: string;
  image?: CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItemImage;
  model?: CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItemModel;
  os?: string;
  osName?: string;
}

/**
 * @summary Device Set
 * @description The name and devices of the device set
*/
export interface CreateDeviceSetOfOwnerCreatedResponse {
  /**
   * Identifier of the device set
  */
  id: string;
  /**
   * The number of manufacturers in the device set's device selection
  */
  manufacturerCount?: number;
  /**
   * Name of the device set
  */
  name: string;
  /**
   * Slug of the device set
  */
  slug?: string;
  /**
   * @summary Device Set Owner
   * @description The owner of a device set
  */
  owner: CreateDeviceSetOfOwnerCreatedResponseOwner;
  /**
   * The number of os versions in the device set's device selection
  */
  osVersionCount?: number;
  deviceConfigurations: CreateDeviceSetOfOwnerCreatedResponseDeviceConfigurationsItem[];
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface CreateDeviceSetOfOwnerBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

/**
 * Event Setting
*/
export interface GetAppEmailSettingsOKResponseSettingsItem {
  /**
   * Frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual', 'Default'
  */
  value: string;
  /**
   * Default frequency of event. Possible values include: 'Disabled', 'Individual', 'Daily',
   * 'DailyAndIndividual'
  */
  defaultValue?: string;
}

/**
 * Alerting Email Settings of the user for a particular app
*/
export interface GetAppEmailSettingsOKResponse {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The ETag of the entity
  */
  eTag?: string;
  /**
   * Allows to forcefully disable emails on app or user level
  */
  enabled: boolean;
  /**
   * The unique id (UUID) of the user
  */
  userId?: string;
  /**
   * The settings the user has for the app
  */
  settings: GetAppEmailSettingsOKResponseSettingsItem[];
  /**
   * Application ID
  */
  appId?: string;
  /**
   * A flag indicating if settings are enabled at user/global level
  */
  userEnabled: boolean;
}

/**
 * Alerting service error
*/
export interface GetAppEmailSettingsErrorModel {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

export interface CreateByEmailErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateByEmailErrorModel {
  error: CreateByEmailErrorModelError;
}

export interface UserInvitationPermissionsData {
  /**
   * The permissions the user has for the app in the invitation
  */
  permissions: string[];
}

/**
 * The information about the app's owner
*/
export interface ListOKResponseAppOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface ListOKResponseAppAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListOKResponseApp {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: ListOKResponseAppOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: ListOKResponseAppAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface ListOKResponseInvitedBy {
  /**
   * The unique id (UUID) of the user
  */
  id: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * The unique name that is used to identify the user.
  */
  name: string;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The creation origin of this user. Possible values include: 'appcenter', 'hockeyapp',
   * 'codepush'
  */
  origin: string;
}

/**
 * The information about the app's owner
*/
export interface ListOKResponseDistributionGroupOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

/**
 * The organization that owns the distribution group, if it exists
*/
export interface ListOKResponseDistributionGroup {
  /**
   * The information about the app's owner
  */
  owner?: ListOKResponseDistributionGroupOwner;
}

export interface ListOKResponseModelModel {
  /**
   * The unique ID (UUID) of the invitation
  */
  id: string;
  app: ListOKResponseApp;
  /**
   * The email address of the invited user
  */
  email: string;
  /**
   * The invitation type. Possible values include: 'developer', 'tester'
  */
  inviteType: string;
  invitedBy: ListOKResponseInvitedBy;
  /**
   * Indicates whether the invited user already exists
  */
  isExistingUser: boolean;
  /**
   * The permissions the user has for the app
  */
  permissions?: string[];
  /**
   * The number of apps in the group
  */
  appCount?: number;
  /**
   * The organization that owns the distribution group, if it exists
  */
  distributionGroup?: ListOKResponseDistributionGroup;
}

export interface CreateOKResponseModel {
  id?: string;
  location?: string;
  token?: string;
  uploadDomain?: string;
  uploadWindowLocation?: string;
  urlEncodedToken?: string;
}

export interface CreateErrorModel1 {
  id: string;
  code: string;
  message: string;
}

export interface EnableErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface EnableErrorModel {
  error: EnableErrorModelError;
}

export interface DisableErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DisableErrorModel {
  error: DisableErrorModelError;
}

/**
 * Export configuration
*/
export interface GetOKResponseExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface GetOKResponseModelModelModelModelModel {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: GetOKResponseExportConfiguration;
}

/**
 * Export configuration
*/
export interface PropertiesModelModelModel {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration
*/
export interface PartialUpdateOKResponseExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface PartialUpdateOKResponse {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: PartialUpdateOKResponseExportConfiguration;
}

export interface PartialUpdateErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface PartialUpdateErrorModel {
  error: PartialUpdateErrorModelError;
}

/**
 * Export configuration
*/
export interface ListOKResponseValuesItemExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface ListOKResponseValuesItemModelModel {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: ListOKResponseValuesItemExportConfiguration;
}

/**
 * List of export configurations
*/
export interface ListOKResponseModelModelModel {
  values: ListOKResponseValuesItemModelModel[];
  /**
   * the total count of exports
  */
  total?: number;
  nextLink?: string;
}

/**
 * Export configuration
*/
export interface CreateAcceptedResponseExportConfiguration {
  exportEntities?: string[];
  /**
   * The resource name on azure
  */
  resourceName?: string;
  /**
   * The resource group name on azure
  */
  resourceGroup?: string;
  /**
   * Field to determine if backfilling should occur. The default value is true. If set to false
   * export starts from date and time of config creation.
  */
  backfill?: boolean;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Export configuration result
*/
export interface CreateAcceptedResponse {
  /**
   * Export configuration id
  */
  id: string;
  /**
   * Target resource type of export configuration. Possible values include: 'BlobStorage',
   * 'AppInsights'
  */
  exportType: string;
  /**
   * Creation time in ISO 8601 format
  */
  creationTime: string;
  /**
   * Latest time in ISO 8601 format when export completed successfully
  */
  lastRunTime?: string;
  exportEntities?: string[];
  /**
   * State of the export job. Possible values include: 'Enabled', 'Disabled', 'Pending', 'Deleted',
   * 'Invalid'
  */
  state: string;
  /**
   * Additional information about export configuration state
  */
  stateInfo?: string;
  /**
   * resource group for the storage account/App Insights resource
  */
  resourceGroup?: string;
  /**
   * Storage accout or Appinsights resource name
  */
  resourceName?: string;
  /**
   * Export configuration
  */
  exportConfiguration?: CreateAcceptedResponseExportConfiguration;
}

/**
 * Device characteristics.
*/
export interface ListSessionLogsOKResponseLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface ListSessionLogsOKResponseLogsItem {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: ListSessionLogsOKResponseLogsItemDevice;
}

export interface ListSessionLogsOKResponse {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: ListSessionLogsOKResponseLogsItem[];
}

export interface ListSessionLogsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListSessionLogsErrorModel {
  error: ListSessionLogsErrorModelError;
}

export interface ErrorAttachmentTextOKResponse {
  content?: string;
}

export interface ErrorAttachmentTextErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorAttachmentTextErrorModel {
  error: ErrorAttachmentTextErrorModelError;
}

export interface ErrorAttachmentLocationOKResponse {
  uri?: string;
}

export interface ErrorAttachmentLocationErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorAttachmentLocationErrorModel {
  error: ErrorAttachmentLocationErrorModelError;
}

export interface ErrorAttachmentsOKResponseItem {
  appId?: string;
  attachmentId?: string;
  crashId?: string;
  blobLocation?: string;
  contentType?: string;
  fileName?: string;
  createdTime?: Date;
  size?: number;
}

export interface ErrorAttachmentsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorAttachmentsErrorModel {
  error: ErrorAttachmentsErrorModelError;
}

export interface ErrorSearchOKResponseErrorsItem {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
}

export interface ErrorSearchOKResponse {
  hasMoreResults?: boolean;
  errors?: ErrorSearchOKResponseErrorsItem[];
}

export interface ErrorSearchErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorSearchErrorModel {
  error: ErrorSearchErrorModelError;
}

export interface ErrorRetentionInDays {
  retentionInDays: number;
}

export interface PutRetentionSettingsOKResponse {
  retentionInDays: number;
}

export interface PutRetentionSettingsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface PutRetentionSettingsErrorModel {
  error: PutRetentionSettingsErrorModelError;
}

export interface GetRetentionSettingsOKResponse {
  retentionInDays: number;
}

export interface GetRetentionSettingsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetRetentionSettingsErrorModel {
  error: GetRetentionSettingsErrorModelError;
}

export interface ErrorFreeDevicePercentagesOKResponseDailyPercentagesItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface ErrorFreeDevicePercentagesOKResponse {
  /**
   * Average percentage
  */
  averagePercentage?: number;
  /**
   * The error-free percentage per day.
  */
  dailyPercentages?: ErrorFreeDevicePercentagesOKResponseDailyPercentagesItem[];
}

export interface ErrorFreeDevicePercentagesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorFreeDevicePercentagesErrorModel {
  error: ErrorFreeDevicePercentagesErrorModelError;
}

export interface GroupErrorStackTraceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupErrorStackTraceErrorModel {
  error: GroupErrorStackTraceErrorModelError;
}

export interface GroupOperatingSystemCountsOKResponseOperatingSystemsItem {
  /**
   * OS name
  */
  operatingSystemName?: string;
  /**
   * count of OS
  */
  errorCount?: number;
}

export interface GroupOperatingSystemCountsOKResponse {
  errorCount?: number;
  operatingSystems?: GroupOperatingSystemCountsOKResponseOperatingSystemsItem[];
}

export interface GroupOperatingSystemCountsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupOperatingSystemCountsErrorModel {
  error: GroupOperatingSystemCountsErrorModelError;
}

export interface GroupModelCountsOKResponseModelsItem {
  /**
   * model name
  */
  modelName?: string;
  /**
   * model code
  */
  modelCode?: string;
  /**
   * count of errors in a model
  */
  errorCount?: number;
}

export interface GroupModelCountsOKResponse {
  errorCount?: number;
  modelsProperty?: GroupModelCountsOKResponseModelsItem[];
}

export interface GroupModelCountsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupModelCountsErrorModel {
  error: GroupModelCountsErrorModelError;
}

export interface ErrorStackTraceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorStackTraceErrorModel {
  error: ErrorStackTraceErrorModelError;
}

export interface ErrorLocationOKResponse {
  uri?: string;
}

export interface ErrorLocationErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorLocationErrorModel {
  error: ErrorLocationErrorModelError;
}

export interface ErrorDownloadErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorDownloadErrorModel {
  error: ErrorDownloadErrorModelError;
}

export interface GetErrorDetailsOKResponseReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface GetErrorDetailsOKResponse {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
  name?: string;
  reasonFrames?: GetErrorDetailsOKResponseReasonFramesItem[];
  /**
   * Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.

  */
  appLaunchTimestamp?: Date;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Flag indicating if device is jailbroken

  */
  jailbreak?: boolean;
  properties?: { [propertyName: string]: string };
}

export interface GetErrorDetailsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetErrorDetailsErrorModel {
  error: GetErrorDetailsErrorModelError;
}

export interface DeleteErrorOKResponse {
  appId?: string;
  errorGroupId?: string;
  errorId?: string;
  errorsDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

export interface DeleteErrorErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteErrorErrorModel {
  error: DeleteErrorErrorModelError;
}

export interface LatestErrorDetailsOKResponseReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface LatestErrorDetailsOKResponse {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
  name?: string;
  reasonFrames?: LatestErrorDetailsOKResponseReasonFramesItem[];
  /**
   * Timestamp when the app was launched, example: '2017-03-13T18:05:42Z'.

  */
  appLaunchTimestamp?: Date;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Flag indicating if device is jailbroken

  */
  jailbreak?: boolean;
  properties?: { [propertyName: string]: string };
}

export interface LatestErrorDetailsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface LatestErrorDetailsErrorModel {
  error: LatestErrorDetailsErrorModelError;
}

export interface ListForGroupOKResponseErrorsItem {
  errorId?: string;
  timestamp?: Date;
  deviceName?: string;
  osVersion?: string;
  osType?: string;
  country?: string;
  language?: string;
  userId?: string;
  hasBreadcrumbs?: boolean;
  hasAttachments?: boolean;
}

export interface ListForGroupOKResponse {
  nextLink?: string;
  /**
   * Errors list.
  */
  errors?: ListForGroupOKResponseErrorsItem[];
}

export interface ListForGroupErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListForGroupErrorModel {
  error: ListForGroupErrorModelError;
}

export interface GroupErrorFreeDevicePercentagesOKResponseDailyPercentagesItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * percentage of the object
  */
  percentage?: number;
}

export interface GroupErrorFreeDevicePercentagesOKResponse {
  /**
   * Average percentage
  */
  averagePercentage?: number;
  /**
   * The error-free percentage per day.
  */
  dailyPercentages?: GroupErrorFreeDevicePercentagesOKResponseDailyPercentagesItem[];
}

export interface GroupErrorFreeDevicePercentagesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupErrorFreeDevicePercentagesErrorModel {
  error: GroupErrorFreeDevicePercentagesErrorModelError;
}

export interface GroupCountsPerDayOKResponseErrorsItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface GroupCountsPerDayOKResponse {
  /**
   * total error count
  */
  count?: number;
  /**
   * the total error count for day
  */
  errors?: GroupCountsPerDayOKResponseErrorsItem[];
}

export interface GroupCountsPerDayErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupCountsPerDayErrorModel {
  error: GroupCountsPerDayErrorModelError;
}

export interface GroupDetailsOKResponseReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface GroupDetailsOKResponse {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: GroupDetailsOKResponseReasonFramesItem[];
  hidden?: boolean;
}

export interface GroupDetailsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupDetailsErrorModel {
  error: GroupDetailsErrorModelError;
}

export interface ErrorGroupStateModel {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
}

export interface UpdateStateOKResponseReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface UpdateStateOKResponse {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: UpdateStateOKResponseReasonFramesItem[];
  hidden?: boolean;
}

export interface UpdateStateErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface UpdateStateErrorModel {
  error: UpdateStateErrorModelError;
}

export interface ErrorGroupsSearchOKResponseErrorGroupsItemReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ErrorGroupsSearchOKResponseErrorGroupsItem {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: ErrorGroupsSearchOKResponseErrorGroupsItemReasonFramesItem[];
  hidden?: boolean;
}

export interface ErrorGroupsSearchOKResponse {
  hasMoreResults?: boolean;
  errorGroups?: ErrorGroupsSearchOKResponseErrorGroupsItem[];
}

export interface ErrorGroupsSearchErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ErrorGroupsSearchErrorModel {
  error: ErrorGroupsSearchErrorModelError;
}

export interface GroupListOKResponseErrorGroupsItemReasonFramesItem {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface GroupListOKResponseErrorGroupsItem {
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  state: string;
  annotation?: string;
  errorGroupId: string;
  appVersion: string;
  appBuild?: string;
  count: number;
  deviceCount: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exceptionType?: string;
  exceptionMessage?: string;
  exceptionClassName?: string;
  exceptionClassMethod?: boolean;
  exceptionMethod?: string;
  exceptionAppCode?: boolean;
  exceptionFile?: string;
  exceptionLine?: string;
  codeRaw?: string;
  reasonFrames?: GroupListOKResponseErrorGroupsItemReasonFramesItem[];
  hidden?: boolean;
}

export interface GroupListOKResponse {
  nextLink?: string;
  errorGroups?: GroupListOKResponseErrorGroupsItem[];
}

export interface GroupListErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GroupListErrorModel {
  error: GroupListErrorModelError;
}

export interface CountsPerDayOKResponseErrorsItem {
  /**
   * the ISO 8601 datetime
  */
  datetime?: string;
  /**
   * count of the object
  */
  count?: number;
}

export interface CountsPerDayOKResponse {
  /**
   * total error count
  */
  count?: number;
  /**
   * the total error count for day
  */
  errors?: CountsPerDayOKResponseErrorsItem[];
}

export interface CountsPerDayErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CountsPerDayErrorModel {
  error: CountsPerDayErrorModelError;
}

export interface AvailableVersionsOKResponse {
  /**
   * List of available versions.
  */
  versions?: string[];
  /**
   * The full number of versions across all pages.
  */
  totalCount?: number;
}

export interface AvailableVersionsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AvailableVersionsErrorModel {
  error: AvailableVersionsErrorModelError;
}

export interface AppBuildsListOKResponse {
  appBuilds?: string[];
}

export interface AppBuildsListErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AppBuildsListErrorModel {
  error: AppBuildsListErrorModelError;
}

/**
 * Status Data from store
*/
export interface GetRealTimeStatusByReleaseIdOKResponseStatus {
  /**
   * status from store
  */
  status?: string;
  /**
   * store type
  */
  storetype?: string;
  /**
   * track information from store
  */
  track?: string;
  /**
   * version of the app from store
  */
  version?: string;
}

/**
 * status of the app from store
*/
export interface GetRealTimeStatusByReleaseIdOKResponse {
  /**
   * release id
  */
  releaseId?: string;
  /**
   * app id
  */
  appId?: string;
  /**
   * Status Data from store
  */
  status?: GetRealTimeStatusByReleaseIdOKResponseStatus;
}

export interface GetRealTimeStatusByReleaseIdErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetErrorModel1 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * ReleasePublishErrorResponse
*/
export interface GetPublishErrorOKResponse {
  /**
   * error Details
  */
  message?: string;
  /**
   * boolean property to tell if logs are available for download
  */
  isLogAvailable?: boolean;
}

export interface GetPublishErrorErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetOKResponseItemDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune or googleplay. Possible
   * values include: 'intune', 'googleplay'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetOKResponseItem {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`. Possible values include: 'group',
   * 'store'
  */
  installUrl?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: GetOKResponseItemDistributionStoresItem[];
}

export interface GetErrorModel2 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteErrorModel2 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListOKResponseItemDistributionStoresItemModel {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * A type identifying the type of distribution store. Possible values include: 'googleplay',
   * 'intune', 'apple'
  */
  type?: string;
  /**
   * A status identifying the status of release in the distribution store.
  */
  publishingStatus?: string;
  /**
   * Is the containing release the latest one in this distribution store.
  */
  isLatest?: boolean;
}

/**
 * Basic information on a release
*/
export interface ListOKResponseItemModelModelModelModelModelModelModel {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * The release's version.
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * Destination for this release. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: ListOKResponseItemDistributionStoresItemModel[];
}

export interface ListErrorModel4 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetLatestOKResponseItemDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id?: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune or googleplay. Possible
   * values include: 'intune', 'googleplay'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetLatestOKResponseItem {
  /**
   * ID identifying this unique release.
  */
  id?: number;
  /**
   * OBSOLETE. Will be removed in next version. The availability concept is now replaced with
   * distributed. Any 'available' release will be associated with the default distribution group of
   * an app.</br>
   * The release state.<br>
   * <b>available</b>: The uploaded release has been distributed.<br>
   * <b>unavailable</b>: The uploaded release is not visible to the user. <br>
   * . Possible values include: 'available', 'unavailable'
  */
  status?: string;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName?: string;
  /**
   * The app's display name.
  */
  appDisplayName?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion?: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt?: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`. Possible values include: 'group',
   * 'store'
  */
  installUrl?: string;
  /**
   * a list of distribution stores that are associated with this release.
  */
  distributionStores?: GetLatestOKResponseItemDistributionStoresItem[];
}

export interface GetLatestErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetOKResponseIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface GetOKResponseIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

/**
 * Store details for intune
*/
export interface GetOKResponseIntuneDetails {
  targetAudience?: GetOKResponseIntuneDetailsTargetAudience;
  appCategory?: GetOKResponseIntuneDetailsAppCategory;
}

/**
 * ExternalStoreResponse
*/
export interface GetOKResponseModelModelModelModelModelModel {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Store track. Possible values include: 'production', 'alpha', 'beta', 'testflight-internal',
   * 'testflight-external'
  */
  track?: string;
  /**
   * Store details for intune
  */
  intuneDetails?: GetOKResponseIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple / GooglePlay stores, this connection
   * will be used to connect to the Apple / Google stores in App Center.
  */
  serviceConnectionId?: string;
  /**
   * The ID of the principal that created the store.
  */
  createdBy?: string;
  /**
   * The type of the principal that created the store.
  */
  createdByPrincipalType?: string;
}

export interface GetErrorModel3 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface BodyModelModelModelModelModelModelModelModelModelModel {
  /**
   * Service connection id to updated.
  */
  serviceConnectionId: string;
}

export interface PatchErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteErrorModel3 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface BodyIntuneDetailsSecretJson {
  /**
   * the id token of user
  */
  idToken?: string;
  /**
   * the refresh token for user
  */
  refreshToken?: string;
  /**
   * the expiry of refresh token
  */
  refreshTokenExpiry?: string;
}

export interface BodyIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
}

export interface BodyIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
}

export interface BodyIntuneDetails {
  secretJson?: BodyIntuneDetailsSecretJson;
  targetAudience?: BodyIntuneDetailsTargetAudience;
  appCategory?: BodyIntuneDetailsAppCategory;
  /**
   * tenant id of the intune store
  */
  tenantId?: string;
}

/**
 * ExternalStoreRequest
*/
export interface BodyModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * store Type. Possible values include: 'googleplay', 'intune', 'apple'
  */
  type?: string;
  /**
   * name of the store. In case of googleplay, and Apple store this is fixed to Production.
  */
  name?: string;
  /**
   * track of the store. Can be production, alpha & beta for googleplay. Can be production,
   * testflight-internal & testflight-external for Apple Store. Possible values include:
   * 'production', 'alpha', 'beta', 'testflight-internal', 'testflight-external'
  */
  track?: string;
  intuneDetails?: BodyIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
}

export interface CreateCreatedResponseIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface CreateCreatedResponseIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

/**
 * Store details for intune
*/
export interface CreateCreatedResponseIntuneDetails {
  targetAudience?: CreateCreatedResponseIntuneDetailsTargetAudience;
  appCategory?: CreateCreatedResponseIntuneDetailsAppCategory;
}

/**
 * ExternalStoreResponse
*/
export interface CreateCreatedResponseModel {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Store track. Possible values include: 'production', 'alpha', 'beta', 'testflight-internal',
   * 'testflight-external'
  */
  track?: string;
  /**
   * Store details for intune
  */
  intuneDetails?: CreateCreatedResponseIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple / GooglePlay stores, this connection
   * will be used to connect to the Apple / Google stores in App Center.
  */
  serviceConnectionId?: string;
  /**
   * The ID of the principal that created the store.
  */
  createdBy?: string;
  /**
   * The type of the principal that created the store.
  */
  createdByPrincipalType?: string;
}

export interface CreateErrorModel2 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListOKResponseItemIntuneDetailsTargetAudience {
  /**
   * display name for the target audience/group
  */
  name?: string;
  /**
   * ID for the target audience/group.
  */
  id?: string;
}

export interface ListOKResponseItemIntuneDetailsAppCategory {
  /**
   * display name for the app category
  */
  name?: string;
  /**
   * ID for the category.
  */
  id?: string;
}

/**
 * Store details for intune
*/
export interface ListOKResponseItemIntuneDetails {
  targetAudience?: ListOKResponseItemIntuneDetailsTargetAudience;
  appCategory?: ListOKResponseItemIntuneDetailsAppCategory;
}

/**
 * ExternalStoreResponse
*/
export interface ListOKResponseItemModelModelModelModelModelModelModelModel {
  /**
   * Store id
  */
  id?: string;
  /**
   * Store Name
  */
  name?: string;
  /**
   * Store Type
  */
  type?: string;
  /**
   * Store track. Possible values include: 'production', 'alpha', 'beta', 'testflight-internal',
   * 'testflight-external'
  */
  track?: string;
  /**
   * Store details for intune
  */
  intuneDetails?: ListOKResponseItemIntuneDetails;
  /**
   * Id for the shared service connection. In case of Apple / GooglePlay stores, this connection
   * will be used to connect to the Apple / Google stores in App Center.
  */
  serviceConnectionId?: string;
  /**
   * The ID of the principal that created the store.
  */
  createdBy?: string;
  /**
   * The type of the principal that created the store.
  */
  createdByPrincipalType?: string;
}

export interface ResendInviteErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ResendInviteErrorModel {
  error: ResendInviteErrorModelError;
}

export interface GetLatestByDistributionGroupOKResponseDistributionGroupsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
}

export interface GetLatestByDistributionGroupOKResponseDistributionStoresItem {
  /**
   * ID identifying a unique distribution store.
  */
  id: string;
  /**
   * A name identifying a unique distribution store.
  */
  name?: string;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
}

export interface GetLatestByDistributionGroupOKResponseDestinationsItem {
  /**
   * ID identifying a unique distribution group.
  */
  id: string;
  /**
   * A name identifying a unique distribution group.
  */
  name?: string;
  /**
   * Is the containing release the latest one in this distribution group.
  */
  isLatest?: boolean;
  /**
   * type of the distribution store currently stores type can be intune, googleplay or windows.
   * Possible values include: 'intune', 'googleplay', 'apple', 'none'
  */
  type?: string;
  /**
   * publishing status of the release in the store.
  */
  publishingStatus?: string;
  /**
   * Destination can be either store or group. Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * Display name for the group or tester
  */
  displayName?: string;
}

/**
 * Contains metadata about the build that produced the release being uploaded
*/
export interface GetLatestByDistributionGroupOKResponseBuild {
  /**
   * The branch name of the build producing the release
  */
  branchName?: string;
  /**
   * The commit hash of the build producing the release
  */
  commitHash?: string;
  /**
   * The commit message of the build producing the release
  */
  commitMessage?: string;
}

/**
 * Details of an uploaded release
*/
export interface GetLatestByDistributionGroupOKResponse {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The app's name (extracted from the uploaded release).
  */
  appName: string;
  /**
   * The app's display name.
  */
  appDisplayName: string;
  /**
   * The app's OS.
  */
  appOs?: string;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * The release's release notes.
  */
  releaseNotes?: string;
  /**
   * The release's provisioning profile name.
  */
  provisioningProfileName?: string;
  /**
   * The type of the provisioning profile for the requested app version. Possible values include:
   * 'adhoc', 'enterprise', 'other'
  */
  provisioningProfileType?: string;
  /**
   * expiration date of provisioning profile in UTC format.
  */
  provisioningProfileExpiryDate?: string;
  /**
   * A flag that determines whether the release's provisioning profile is still extracted or not.
  */
  isProvisioningProfileSyncing?: boolean;
  /**
   * The release's size in bytes.
  */
  size?: number;
  /**
   * The release's minimum required operating system.
  */
  minOs?: string;
  /**
   * The release's device family.
  */
  deviceFamily?: string;
  /**
   * The release's minimum required Android API level.
  */
  androidMinApiLevel?: string;
  /**
   * The identifier of the apps bundle.
  */
  bundleIdentifier?: string;
  /**
   * Hashes for the packages.
  */
  packageHashes?: string[];
  /**
   * MD5 checksum of the release binary.
  */
  fingerprint?: string;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * The URL that hosts the binary for this release.
  */
  downloadUrl?: string;
  /**
   * A URL to the app's icon.
  */
  appIconUrl: string;
  /**
   * The href required to install a release on a mobile device. On iOS devices will be prefixed
   * with `itms-services://?action=download-manifest&url=`
  */
  installUrl?: string;
  /**
   * OBSOLETE. Will be removed in next version. The destination type.<br>
   * <b>group</b>: The release distributed to internal groups and distribution_groups details will
   * be returned.<br>
   * <b>store</b>: The release distributed to external stores and distribution_stores details will
   * be returned.<br>
   * <b>tester</b>: The release distributed testers details will be returned.<br>
   * . Possible values include: 'group', 'store', 'tester'
  */
  destinationType?: string;
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution groups that are associated
   * with this release.
  */
  distributionGroups?: GetLatestByDistributionGroupOKResponseDistributionGroupsItem[];
  /**
   * OBSOLETE. Will be removed in next version. A list of distribution stores that are associated
   * with this release.
  */
  distributionStores?: GetLatestByDistributionGroupOKResponseDistributionStoresItem[];
  /**
   * A list of distribution groups or stores.
  */
  destinations?: GetLatestByDistributionGroupOKResponseDestinationsItem[];
  /**
   * In calls that allow passing `udid` in the query string, this value will hold the provisioning
   * status of that UDID in this release. Will be ignored for non-iOS platforms.
  */
  isUdidProvisioned?: boolean;
  /**
   * In calls that allow passing `udid` in the query string, this value determines if a release can
   * be re-signed. When true, after a re-sign, the tester will be able to install the release from
   * his registered devices. Will not be returned for non-iOS platforms.
  */
  canResign?: boolean;
  /**
   * Contains metadata about the build that produced the release being uploaded
  */
  build?: GetLatestByDistributionGroupOKResponseBuild;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * Status of the release.
  */
  status?: string;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface GetLatestByDistributionGroupNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetLatestByDistributionGroupNotImplementedResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * Response for getting a list of releases in a distribution group
*/
export interface ListByDistributionGroupOKResponseItem {
  /**
   * ID identifying this unique release.
  */
  id: number;
  /**
   * The release's version.<br>
   * For iOS: CFBundleVersion from info.plist.<br>
   * For Android: android:versionCode from AppManifest.xml.

  */
  version: string;
  /**
   * The release's origin. Possible values include: 'hockeyapp', 'appcenter'
  */
  origin?: string;
  /**
   * The release's short version.<br>
   * For iOS: CFBundleShortVersionString from info.plist.<br>
   * For Android: android:versionName from AppManifest.xml.

  */
  shortVersion: string;
  /**
   * A boolean which determines whether the release is a mandatory update or not.
  */
  mandatoryUpdate: boolean;
  /**
   * UTC time in ISO 8601 format of the uploaded time.
  */
  uploadedAt: string;
  /**
   * This value determines the whether a release currently is enabled or disabled.
  */
  enabled: boolean;
  /**
   * This value determines if a release is external or not.
  */
  isExternalBuild?: boolean;
}

export interface ListByDistributionGroupNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface RemoveUserOKResponseItem {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * The message of the result
  */
  message?: number;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface ListUsersOKResponseItem {
  /**
   * The unique id (UUID) of the user
  */
  id?: string;
  /**
   * The avatar URL of the user
  */
  avatarUrl?: string;
  /**
   * User is required to send an old password in order to change the password.
  */
  canChangePassword?: boolean;
  /**
   * The full name of the user. Might for example be first and last name
  */
  displayName?: string;
  /**
   * The email address of the user
  */
  email: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The unique name that is used to identify the user.
  */
  name?: string;
}

export interface ListUsersErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListUsersErrorModel {
  error: ListUsersErrorModelError;
}

export interface AddUserOKResponseItem {
  /**
   * The code of the result
  */
  code?: string;
  /**
   * Whether the has accepted the invite. Available when an invite is pending, and the value will
   * be "true".
  */
  invitePending?: boolean;
  /**
   * The message of the result
  */
  message?: string;
  /**
   * The status code of the result
  */
  status: number;
  /**
   * The email of the user
  */
  userEmail?: string;
}

export interface ListCsvFormatBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListCsvFormatNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListCsvFormatInternalServerErrorResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * The information for a single iOS device
*/
export interface ListOKResponseItemModelModelModelModelModelModelModelModelModel {
  /**
   * The Unique Device IDentifier of the device
  */
  udid: string;
  /**
   * The model identifier of the device, in the format iDeviceM,N
  */
  model: string;
  /**
   * The device description, in the format "iPhone 7 Plus (A1784)"
  */
  deviceName: string;
  /**
   * A combination of the device model name and the owner name.
  */
  fullDeviceName?: string;
  /**
   * The last known OS version running on the device
  */
  osBuild: string;
  /**
   * The last known OS version running on the device
  */
  osVersion: string;
  /**
   * The device's serial number. Always empty or undefined at present.
  */
  serial?: string;
  /**
   * The device's International Mobile Equipment Identity number. Always empty or undefined at
   * present.
  */
  imei?: string;
  /**
   * The user ID of the device owner.
  */
  ownerId?: string;
  /**
   * The provisioning status of the device.
  */
  status: string;
  /**
   * Timestamp of when the device was registered in ISO format.
  */
  registeredAt?: string;
}

export interface ListBadRequestResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListNotFoundResponse {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetOKResponseModelModelModelModelModelModelModel {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface UpdateOKResponseModelModelModelModel {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface ListOKResponseItemModelModelModelModelModelModelModelModelModelModel {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

export interface CreateCreatedResponseModelModel {
  /**
   * The unique ID of the distribution group
  */
  id: string;
  /**
   * The name of the distribution group used in URLs
  */
  name: string;
  /**
   * The name of the distribution group
  */
  displayName?: string;
  /**
   * The creation origin of this distribution group. Possible values include: 'appcenter',
   * 'hockeyapp'
  */
  origin: string;
  /**
   * Whether the distribution group is public
  */
  isPublic: boolean;
}

/**
 * missing symbol groups
*/
export interface InfoOKResponse {
  /**
   * total number of crashes for all missing symbol groups
  */
  totalCrashCount: number;
}

/**
 * failure response object
*/
export interface InfoErrorModel {
  code: string;
  message: string;
}

/**
 * missing symbol
*/
export interface GetOKResponseGroupsItemMissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface GetOKResponseGroupsItem {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * number of errors that belong to this group
  */
  errorCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: GetOKResponseGroupsItemMissingSymbolsItem[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * grouped by missing symbols crashes response object
*/
export interface GetOKResponseModelModelModelModelModelModelModelModel {
  /**
   * total number of crashes for all the groups
  */
  totalCrashCount: number;
  /**
   * list of crash groups formed by missing symbols combination
  */
  groups: GetOKResponseGroupsItem[];
}

/**
 * failure response object
*/
export interface GetErrorModel4 {
  code: string;
  message: string;
}

/**
 * missing symbol
*/
export interface ListOKResponseGroupsItemMissingSymbolsItem {
  /**
   * symbol id
  */
  symbolId: string;
  /**
   * symbol name
  */
  name: string;
  /**
   * symbol plarform
  */
  platform?: string;
  /**
   * symbol status. Possible values include: 'missing', 'ignored', 'available'
  */
  status: string;
}

/**
 * missing symbol crash group object
*/
export interface ListOKResponseGroupsItem {
  /**
   * id of the symbol group
  */
  symbolGroupId: string;
  /**
   * number of crashes that belong to this group
  */
  crashCount?: number;
  /**
   * number of errors that belong to this group
  */
  errorCount?: number;
  /**
   * application id
  */
  appId: string;
  /**
   * application version
  */
  appVer: string;
  /**
   * application build
  */
  appBuild: string;
  /**
   * last update date for the group
  */
  lastModified: Date;
  /**
   * list of missing symbols
  */
  missingSymbols: ListOKResponseGroupsItemMissingSymbolsItem[];
  /**
   * group status. Possible values include: 'active', 'pending', 'closed'
  */
  status: string;
}

/**
 * grouped by missing symbols crashes response object
*/
export interface ListOKResponseModelModelModelModel {
  /**
   * total number of crashes for all the groups
  */
  totalCrashCount: number;
  /**
   * list of crash groups formed by missing symbols combination
  */
  groups: ListOKResponseGroupsItem[];
}

/**
 * failure response object
*/
export interface ListErrorModel5 {
  code: string;
  message: string;
}

/**
 * @summary Device List
 * @description A list of device IDs
*/
export interface DeviceListModel {
  devices: string[];
}

/**
 * @summary Device Selection
 * @description Short ID for a list of device IDs
*/
export interface CreateDeviceSelectionCreatedResponse {
  /**
   * Identifier of the device selection
  */
  shortId: string;
}

/**
 * @summary Test Cloud Error Details
 * @description Details of a failed operation
*/
export interface CreateDeviceSelectionBadRequestResponse {
  /**
   * Status of the operation
  */
  status: string;
  /**
   * Human-readable message that describes the error
  */
  message: string;
}

export interface GetDeviceConfigurationsOKResponseItemImage {
  full?: string;
  thumb?: string;
}

/**
 * Physical device dimensions
*/
export interface GetDeviceConfigurationsOKResponseItemModelDimensions {
  depth?: any;
  height?: any;
  width?: any;
}

/**
 * Device screen resolution
*/
export interface GetDeviceConfigurationsOKResponseItemModelResolution {
  height?: string;
  width?: string;
  ppi?: string;
}

/**
 * Physical device screen dimensions
*/
export interface GetDeviceConfigurationsOKResponseItemModelScreenSize {
  cm?: string;
  inProperty?: string;
}

/**
 * CPU data for device
*/
export interface GetDeviceConfigurationsOKResponseItemModelCpu {
  frequency?: string;
  core?: string;
  text?: string;
}

/**
 * Memory data for device
*/
export interface GetDeviceConfigurationsOKResponseItemModelMemory {
  formattedSize?: string;
}

export interface GetDeviceConfigurationsOKResponseItemModelDeviceFrameGrid {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface GetDeviceConfigurationsOKResponseItemModelDeviceFrameFull {
  width?: number;
  height?: number;
  frameUrl?: string;
  screen?: number[];
}

export interface GetDeviceConfigurationsOKResponseItemModelDeviceFrame {
  grid?: GetDeviceConfigurationsOKResponseItemModelDeviceFrameGrid;
  full?: GetDeviceConfigurationsOKResponseItemModelDeviceFrameFull;
}

export interface GetDeviceConfigurationsOKResponseItemModel {
  name?: string;
  manufacturer?: string;
  model?: string;
  platform?: string;
  /**
   * Physical device dimensions
  */
  dimensions?: GetDeviceConfigurationsOKResponseItemModelDimensions;
  /**
   * Device screen resolution
  */
  resolution?: GetDeviceConfigurationsOKResponseItemModelResolution;
  releaseDate?: string;
  formFactor?: string;
  /**
   * Physical device screen dimensions
  */
  screenSize?: GetDeviceConfigurationsOKResponseItemModelScreenSize;
  /**
   * CPU data for device
  */
  cpu?: GetDeviceConfigurationsOKResponseItemModelCpu;
  /**
   * Memory data for device
  */
  memory?: GetDeviceConfigurationsOKResponseItemModelMemory;
  screenRotation?: number;
  deviceFrame?: GetDeviceConfigurationsOKResponseItemModelDeviceFrame;
  availabilityCount?: number;
}

export interface GetDeviceConfigurationsOKResponseItem {
  /**
   * The name of the device model and OS version
  */
  name?: string;
  /**
   * The unique id of the device configuration
  */
  id?: string;
  /**
   * The tier
  */
  tier?: number;
  image?: GetDeviceConfigurationsOKResponseItemImage;
  model?: GetDeviceConfigurationsOKResponseItemModel;
  os?: string;
  osName?: string;
  marketShare?: number;
}

export interface CreateOKResponseModelModel {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The URL encoded token used for upload permissions.
  */
  token: string;
}

export interface CreateErrorModel3 {
  message: string;
}

export interface ReleaseLabel {
  label?: string;
}

export interface RollbackCreatedResponseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface RollbackCreatedResponse {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: RollbackCreatedResponseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface RollbackErrorModel {
  message: string;
}

export interface ReleaseModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
}

export interface UpdateOKResponseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface UpdateOKResponseModelModelModelModelModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: UpdateOKResponseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface UpdateErrorModel1 {
  message: string;
}

export interface DeleteErrorModel4 {
  message: string;
}

export interface GetOKResponseItemDiffPackageMapValue {
  size: number;
  url: string;
}

export interface GetOKResponseItemModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: GetOKResponseItemDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface GetErrorModel5 {
  message: string;
}

/**
 * The upload metadata from the release initialization step.
*/
export interface UploadedReleaseReleaseUpload {
  /**
   * The ID for the newly created upload. It is going to be required later in the process.
  */
  id: string;
  /**
   * The URL domain used to upload the release.
  */
  uploadDomain: string;
  /**
   * The URL encoded token used for upload permissions.
  */
  token: string;
}

export interface UploadedRelease {
  /**
   * The upload metadata from the release initialization step.
  */
  releaseUpload: UploadedReleaseReleaseUpload;
  /**
   * the binary version of the application
  */
  targetBinaryVersion: string;
  /**
   * This specifies which deployment you want to release the update to. Default is Staging.
  */
  deploymentName?: string;
  /**
   * This provides an optional "change log" for the deployment.
  */
  description?: string;
  /**
   * This specifies whether an update should be downloadable by end users or not.
  */
  disabled?: boolean;
  /**
   * This specifies whether the update should be considered mandatory or not (e.g. it includes a
   * critical security fix).
  */
  mandatory?: boolean;
  /**
   * This specifies that if the update is identical to the latest release on the deployment, the
   * CLI should generate a warning instead of an error.
  */
  noDuplicateReleaseError?: boolean;
  /**
   * This specifies the percentage of users (as an integer between 1 and 100) that should be
   * eligible to receive this update.
  */
  rollout?: number;
}

export interface CreateCreatedResponseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface CreateCreatedResponseModelModelModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: CreateCreatedResponseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface CreateErrorModel4 {
  message: string;
}

export interface ReleaseModelModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
}

export interface PromoteOKResponseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface PromoteOKResponse {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: PromoteOKResponseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface PromoteErrorModel {
  message: string;
}

export interface GetOKResponseItemModelModel {
  label: string;
  active: number;
  downloaded?: number;
  failed?: number;
  installed?: number;
}

export interface GetErrorModel6 {
  message: string;
}

export interface DeleteErrorModel5 {
  message: string;
}

export interface GetOKResponseLatestReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface GetOKResponseLatestRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: GetOKResponseLatestReleaseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface GetOKResponseModelModelModelModelModelModelModelModelModel {
  key?: string;
  name: string;
  latestRelease?: GetOKResponseLatestRelease;
}

export interface GetErrorModel7 {
  message: string;
}

export interface DeploymentModel {
  name: string;
}

export interface UpdateErrorModel2 {
  message: string;
}

export interface ListOKResponseItemLatestReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface ListOKResponseItemLatestRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: ListOKResponseItemLatestReleaseDiffPackageMapValue };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface ListOKResponseItemModelModelModelModelModelModelModelModelModelModelModel {
  key?: string;
  name: string;
  latestRelease?: ListOKResponseItemLatestRelease;
}

export interface ListErrorModel6 {
  message: string;
}

export interface DeploymentLatestReleaseDiffPackageMapValueModel {
  size: number;
  url: string;
}

export interface DeploymentLatestReleaseModel {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: DeploymentLatestReleaseDiffPackageMapValueModel };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface DeploymentModelModel {
  key?: string;
  name: string;
  latestRelease?: DeploymentLatestReleaseModel;
}

export interface CreateCreatedResponseLatestReleaseDiffPackageMapValue {
  size: number;
  url: string;
}

export interface CreateCreatedResponseLatestRelease {
  targetBinaryRange?: string;
  description?: string;
  isDisabled?: boolean;
  isMandatory?: boolean;
  rollout?: number;
  label?: string;
  packageHash?: string;
  blobUrl?: string;
  diffPackageMap?: { [propertyName: string]: CreateCreatedResponseLatestReleaseDiffPackageMapValue
  };
  /**
   * Set on 'Promote'
  */
  originalDeployment?: string;
  /**
   * Set on 'Promote' and 'Rollback'
  */
  originalLabel?: string;
  releasedBy?: string;
  /**
   * The release method is unknown if unspecified. Possible values include: 'Upload', 'Promote',
   * 'Rollback'
  */
  releaseMethod?: string;
  size?: number;
  uploadTime?: number;
}

export interface CreateCreatedResponseModelModelModelModel {
  key?: string;
  name: string;
  latestRelease?: CreateCreatedResponseLatestRelease;
}

export interface CreateErrorModel5 {
  message: string;
}

export interface GetResourceProvisioningNotFoundResponse {
  /**
   * Possible values include: 'Empty', 'Accepted', 'Creating', 'Connected', 'Invalid'
  */
  status: string;
  message?: string;
}

export interface GetResourceProvisioningInternalServerErrorResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetResourceProvisioningInternalServerErrorResponse {
  error: GetResourceProvisioningInternalServerErrorResponseError;
}

export interface ProvisionDatabaseParameters {
  subscriptionId?: string;
  databaseConnectionString?: string;
  /**
   * Possible values include: 'East Asia', 'Southeast Asia', 'Australia Central', 'Australia
   * Central 2', 'Australia East', 'Australia Southeast', 'Brazil South', 'Canada Central', 'Canada
   * East', 'Central India', 'South India', 'West India', 'North Europe', 'West Europe', 'France
   * Central', 'France South', 'Germany Central', 'Germany Northeast', 'Japan East', 'Japan West',
   * 'Korea Central', 'Korea South', 'South Africa North', 'South Africa West', 'UK South', 'UK
   * West', 'Central US', 'East US', 'East US 2', 'US Gov Arizona', 'US Gov Texas', 'North Central
   * US', 'South Central US', 'West US', 'West US 2', 'West Central US'
  */
  resourceRegion?: string;
  database?: string;
  collection?: string;
  requestUnits?: number;
  accountName?: string;
}

export interface PostResourceProvisioningAcceptedResponse {
  /**
   * Possible values include: 'Empty', 'Accepted', 'Creating', 'Connected', 'Invalid'
  */
  status: string;
  message?: string;
}

export interface PostResourceProvisioningBadRequestResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface PostResourceProvisioningBadRequestResponse {
  error: PostResourceProvisioningBadRequestResponseError;
}

export interface PostResourceProvisioningInternalServerErrorResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface PostResourceProvisioningInternalServerErrorResponse {
  error: PostResourceProvisioningInternalServerErrorResponseError;
}

export interface GetOverviewInternalServerErrorResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetOverviewInternalServerErrorResponse {
  error: GetOverviewInternalServerErrorResponseError;
}

export interface GetAppCrashesInfoOKResponseFeatures {
  /**
   * App supports modification of crashgroup status
  */
  crashgroupModifyStatus?: boolean;
  /**
   * App supports modification of crashgroup annotation
  */
  crashgroupModifyAnnotation?: boolean;
  /**
   * App supports search API
  */
  search?: boolean;
  /**
   * App supports the 'crash free user' metric
  */
  crashgroupAnalyticsCrashfreeusers?: boolean;
  /**
   * App supports the 'impacted users' metric
  */
  crashgroupAnalyticsImpactedusers?: boolean;
  /**
   * App supports download of raw crashes
  */
  crashDownloadRaw?: boolean;
}

export interface GetAppCrashesInfoOKResponse {
  hasCrashes: boolean;
  features: GetAppCrashesInfoOKResponseFeatures;
}

export interface GetAppCrashesInfoErrorModel {
  message: string;
}

/**
 * Generic log.
*/
export interface ListSessionLogsOKResponseLogsItemModel {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: ListSessionLogsOKResponseLogsItemDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

export interface ListSessionLogsOKResponseModel {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: ListSessionLogsOKResponseLogsItemModel[];
}

export interface GetCrashTextAttachmentContentErrorModel {
  message: string;
}

/**
 * Location for downloading crash attachment
*/
export interface GetCrashAttachmentLocationOKResponse {
  uri: string;
}

export interface GetCrashAttachmentLocationErrorModel {
  message: string;
}

export interface ListAttachmentsOKResponseItem {
  appId: string;
  attachmentId: string;
  crashId: string;
  blobLocation: string;
  contentType: string;
  fileName: string;
  createdTime: Date;
  size: number;
}

export interface ListAttachmentsErrorModel {
  message: string;
}

export interface GetStacktraceErrorModel {
  message: string;
}

/**
 * Location for downloading crash raw
*/
export interface GetRawCrashLocationOKResponse {
  uri: string;
}

export interface GetRawCrashLocationErrorModel {
  message: string;
}

export interface GetNativeCrashDownloadErrorModel {
  message: string;
}

export interface GetNativeCrashErrorModel {
  message: string;
}

export interface GetErrorModel8 {
  message: string;
}

export interface DeleteOKResponseModelModel {
  appId?: string;
  crashGroupId?: string;
  crashId?: string;
  crashesDeleted?: number;
  attachmentsDeleted?: number;
  blobsSucceeded?: number;
  blobsFailed?: number;
}

export interface DeleteErrorModel6 {
  message: string;
}

export interface ListErrorModel7 {
  message: string;
}

/**
 * frame belonging to the reason of the crash
*/
export interface GetOKResponseReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface GetOKResponseModelModelModelModelModelModelModelModelModelModel {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  /**
   * frame belonging to the reason of the crash
  */
  reasonFrame?: GetOKResponseReasonFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface GetErrorModel9 {
  message: string;
}

export interface Group {
  status?: any;
  annotation?: string;
}

/**
 * frame belonging to the reason of the crash
*/
export interface UpdateOKResponseReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface UpdateOKResponseModelModelModelModelModelModel {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  /**
   * frame belonging to the reason of the crash
  */
  reasonFrame?: UpdateOKResponseReasonFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface UpdateErrorModel3 {
  message: string;
}

/**
 * frame belonging to the reason of the crash
*/
export interface ListOKResponseCrashGroupsItemReasonFrame {
  /**
   * name of the class
  */
  className?: string;
  /**
   * name of the method
  */
  method?: string;
  /**
   * is a class method
  */
  classMethod?: boolean;
  /**
   * name of the file
  */
  file?: string;
  /**
   * line number
  */
  line?: number;
  /**
   * this line isn't from any framework
  */
  appCode?: boolean;
  /**
   * Name of the framework
  */
  frameworkName?: string;
  /**
   * Formatted frame string
  */
  codeFormatted?: string;
  /**
   * Unformatted Frame string
  */
  codeRaw?: string;
  /**
   * programming language of the frame. Possible values include: 'JavaScript', 'CSharp',
   * 'Objective-C', 'Objective-Cpp', 'Cpp', 'C', 'Swift', 'Java', 'Unknown'
  */
  language?: string;
  /**
   * parameters of the frames method
  */
  methodParams?: string;
  /**
   * Exception type.
  */
  exceptionType?: string;
  /**
   * OS exception type. (aka. SIGNAL)
  */
  osExceptionType?: string;
}

export interface ListOKResponseCrashGroupsItem {
  crashGroupId: string;
  newCrashGroupId: string;
  displayId: string;
  appVersion: string;
  build: string;
  /**
   * Possible values include: 'open', 'closed', 'ignored'
  */
  status: string;
  count: number;
  impactedUsers?: number;
  firstOccurrence: Date;
  lastOccurrence: Date;
  exception?: string;
  crashReason: string;
  /**
   * frame belonging to the reason of the crash
  */
  reasonFrame?: ListOKResponseCrashGroupsItemReasonFrame;
  /**
   * Crash or handled exception
  */
  fatal: boolean;
  annotation: string;
}

export interface ListOKResponseModelModelModelModelModel {
  limitedResultSet: boolean;
  /**
   * Cassandra request continuation token. The token is used for pagination.
  */
  continuationToken?: string;
  crashGroups: ListOKResponseCrashGroupsItem[];
}

export interface ListErrorModel8 {
  message: string;
}

export interface ListByShaListOKResponseItemCommitAuthor {
  /**
   * Date and time of the commit
  */
  date?: string;
  /**
   * Author name
  */
  name?: string;
  /**
   * Author's email
  */
  email?: string;
}

export interface ListByShaListOKResponseItemCommit {
  /**
   * Commit message
  */
  message?: string;
  author?: ListByShaListOKResponseItemCommitAuthor;
}

export interface ListByShaListOKResponseItem {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
  commit?: ListByShaListOKResponseItemCommit;
}

export interface GetLogOKResponse {
  value?: string[];
}

/**
 * A download reference
*/
export interface GetDownloadUriOKResponse {
  /**
   * Download URI
  */
  uri: string;
}

/**
 * Destination details for distributing build releases
*/
export interface DistributeInfoDestinationsItem {
  id: string;
  /**
   * Possible values include: 'store', 'group', 'tester'
  */
  type: string;
}

export interface DistributeInfo {
  /**
   * Array of objects {id:string, type:string} with "id" being the distribution group ID, store ID,
   * or tester email, and "type" being "group", "store", or "tester"
  */
  destinations?: DistributeInfoDestinationsItem[];
  /**
   * The release notes
  */
  releaseNotes?: string;
  mandatoryUpdate?: boolean;
  notifyTesters?: boolean;
}

export interface DistributeOKResponse {
  /**
   * Status of the Request
  */
  status?: string;
  /**
   * A unique ID of the upload
  */
  uploadId?: string;
}

export interface GetOKResponseModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface PropertiesModelModelModelModel {
  /**
   * The build status; used to cancel builds. Possible values include: 'cancelling'
  */
  status?: string;
}

export interface UpdateOKResponseModelModelModelModelModelModelModel {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface GetStatusByAppIdOKResponse {
  status?: string;
  service?: string;
  message?: string;
  url?: string;
  validUntil?: number;
  os?: string;
}

/**
 * Object returned in response to getting a bug tracker issue related to a crash group id
*/
export interface GetRepoIssueFromCrashOKResponse {
  id?: string;
  url?: string;
  title?: string;
  /**
   * Possible values include: 'github', 'vsts', 'jira'
  */
  bugTrackerType?: string;
  repoName?: string;
  mobileCenterId?: string;
  eventType?: string;
}

/**
 * Alerting service error
*/
export interface GetRepoIssueFromCrashErrorModel {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Bugtracker specific settings
*/
export interface GetSettingsOKResponseSettings {
  callbackUrl?: string;
  ownerName: string;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

/**
 * Alerting bugtracker resource
*/
export interface GetSettingsOKResponse {
  /**
   * type of bugtracker. Possible values include: 'github', 'vsts', 'jira'
  */
  type?: string;
  /**
   * bugtracker state. Possible values include: 'enabled', 'disabled', 'unauthorized'
  */
  state?: string;
  /**
   * ID of OAuth token
  */
  tokenId?: string;
  /**
   * Event types enabled for bugtracker
  */
  eventTypes?: string[];
  /**
   * Bugtracker specific settings
  */
  settings?: GetSettingsOKResponseSettings;
}

/**
 * Alerting service error
*/
export interface GetSettingsErrorModel {
  /**
   * Unique request identifier for tracking
  */
  requestId: string;
  /**
   * The status code return by the API. It can be 400 or 404 or 409 or 500.
  */
  code: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

export interface ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemSharedSchemesItemArchiveProject {
  /**
   * The Id of the target to archive
  */
  archiveTargetId: string;
  /**
   * The project to archive container name
  */
  projectName: string;
  /**
   * Full path of the target project
  */
  projectPath?: string;
}

export interface ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemSharedSchemesItem {
  /**
   * Scheme name
  */
  name: string;
  /**
   * Does scheme have a test action?
  */
  hasTestAction: boolean;
  /**
   * Build configuration set in Archive action
  */
  archiveConfiguration?: string;
  archiveProject?:
  ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemSharedSchemesItemArchiveProject;
}

/**
 * App extension information
*/
export interface ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemAppExtensionTargetsItem
{
  /**
   * App extension name
  */
  name: string;
  /**
   * App extension bundle identifier
  */
  targetBundleIdentifier: string;
}

export interface ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItem {
  /**
   * Path to project
  */
  path: string;
  /**
   * Project schemes
  */
  sharedSchemes: ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemSharedSchemesItem[];
  /**
   * Path to CocoaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  /**
   * repo object Id of the pbxproject
  */
  xcodeProjectSha?: string;
  /**
   * Related projects paths for xcworkspace
  */
  workspaceProjectPaths?: string;
  /**
   * Information regarding project app extensions, if present
  */
  appExtensionTargets?:
  ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItemAppExtensionTargetsItem[];
}

export interface ListToolsetProjectsOKResponseXcode {
  /**
   * The Xcode scheme containers
  */
  xcodeSchemeContainers: ListToolsetProjectsOKResponseXcodeXcodeSchemeContainersItem[];
}

export interface ListToolsetProjectsOKResponseJavascriptJavascriptSolutionsItem {
  /**
   * The path to the detected package.json
  */
  packageJsonPath: string;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

export interface ListToolsetProjectsOKResponseJavascript {
  /**
   * Paths for detected package.json files
  */
  packageJsonPaths: string[];
  /**
   * The React Native solutions detected
  */
  javascriptSolutions?: ListToolsetProjectsOKResponseJavascriptJavascriptSolutionsItem[];
}

export interface ListToolsetProjectsOKResponseXamarinXamarinSolutionsItem {
  /**
   * Path to solution
  */
  path: string;
  /**
   * Solution configurations
  */
  configurations: string[];
  /**
   * Solution default configuration
  */
  defaultConfiguration?: string;
}

export interface ListToolsetProjectsOKResponseXamarin {
  /**
   * Xamarin solutions for the toolset
  */
  xamarinSolutions: ListToolsetProjectsOKResponseXamarinXamarinSolutionsItem[];
}

/**
 * Android signing config. Null if not specified
*/
export interface ListToolsetProjectsOKResponseAndroidAndroidModulesItemBuildConfigurationsItemSigningConfig {
  /**
   * Indicates if storeFile is specified in the signing configuration
  */
  hasStoreFile?: boolean;
}

export interface ListToolsetProjectsOKResponseAndroidAndroidModulesItemBuildConfigurationsItem {
  /**
   * Name of build configuration (the same as a build type name)
  */
  name: string;
  /**
   * Android signing config. Null if not specified
  */
  signingConfig?:
  ListToolsetProjectsOKResponseAndroidAndroidModulesItemBuildConfigurationsItemSigningConfig;
}

export interface ListToolsetProjectsOKResponseAndroidAndroidModulesItem {
  /**
   * Name of the Android module
  */
  name: string;
  /**
   * Module contains bundle settings
  */
  hasBundle?: boolean;
  /**
   * The product flavors of the Android module
  */
  productFlavors?: string[];
  /**
   * The detected build variants of the Android module (matrix of product flavor + build type
   * (debug|release))
  */
  buildVariants?: string[];
  /**
   * The detected build types of the Android module
  */
  buildTypes?: string[];
  /**
   * The detected build configurations of the Android module
  */
  buildConfigurations?:
  ListToolsetProjectsOKResponseAndroidAndroidModulesItemBuildConfigurationsItem[];
  /**
   * Whether the module is at the root level of the project
  */
  isRoot?: boolean;
}

export interface ListToolsetProjectsOKResponseAndroid {
  /**
   * Android Gradle modules
  */
  androidModules: ListToolsetProjectsOKResponseAndroidAndroidModulesItem[];
  /**
   * The path of the Gradle wrapper
  */
  gradleWrapperPath?: string;
}

/**
 * Abstract platform project
*/
export interface ListToolsetProjectsOKResponseBuildscriptsValue {
  name?: string;
  path?: string;
}

export interface ListToolsetProjectsOKResponseUwpUwpSolutionsItem {
  /**
   * The path to the UWP solution
  */
  path: string;
  /**
   * The possible configurations detected for the UWP solution
  */
  configurations: string[];
}

export interface ListToolsetProjectsOKResponseUwp {
  /**
   * The UWP solutions detected
  */
  uwpSolutions: ListToolsetProjectsOKResponseUwpUwpSolutionsItem[];
}

export interface ListToolsetProjectsOKResponseTestcloudProjectsItemFrameworkProperties {
  configurations?: string[];
}

export interface ListToolsetProjectsOKResponseTestcloudProjectsItem {
  /**
   * The path to the TestCloud project
  */
  path: string;
  /**
   * Possible values include: 'Appium', 'Calabash', 'Espresso', 'UITest', 'Generated'
  */
  frameworkType: string;
  frameworkProperties?: ListToolsetProjectsOKResponseTestcloudProjectsItemFrameworkProperties;
}

export interface ListToolsetProjectsOKResponseTestcloud {
  /**
   * The TestCloud projects detected
  */
  projects: ListToolsetProjectsOKResponseTestcloudProjectsItem[];
}

/**
 * A collection of projects for each type of toolset
*/
export interface ListToolsetProjectsOKResponse {
  /**
   * The commit hash of the analyzed commit
  */
  commit?: string;
  xcode?: ListToolsetProjectsOKResponseXcode;
  javascript?: ListToolsetProjectsOKResponseJavascript;
  xamarin?: ListToolsetProjectsOKResponseXamarin;
  android?: ListToolsetProjectsOKResponseAndroid;
  /**
   * A collection of detected pre/post buildscripts for current platform toolset
  */
  buildscripts?: { [propertyName: string]: ListToolsetProjectsOKResponseBuildscriptsValue };
  uwp?: ListToolsetProjectsOKResponseUwp;
  testcloud?: ListToolsetProjectsOKResponseTestcloud;
}

/**
 * Provisioning profile fetch and store information
*/
export interface GetOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface GetOKResponseToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  GetOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface GetOKResponseToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface GetOKResponseToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface GetOKResponseToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface GetOKResponseToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: GetOKResponseToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: GetOKResponseToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: GetOKResponseToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: GetOKResponseToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface GetOKResponseArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

export interface GetOKResponseModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: GetOKResponseToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: GetOKResponseArtifactVersioning;
  id: number;
}

export interface GetErrorModel10 {
  id: string;
  code: string;
  message: string;
}

export interface ParamsValueBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface ParamsValueBranch {
  /**
   * The branch name
  */
  name: string;
  commit: ParamsValueBranchCommit;
}

/**
 * The branch build core properties
*/
export interface ParamsValue {
  branch?: ParamsValueBranch;
  enabled?: boolean;
}

/**
 * Provisioning profile fetch and store information
*/
export interface ParamsToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface ParamsToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  ParamsToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface ParamsToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface ParamsToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface ParamsToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface ParamsToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: ParamsToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: ParamsToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: ParamsToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: ParamsToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface ParamsArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

/**
 * The branch build configuration
*/
export interface Params {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: ParamsToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: ParamsArtifactVersioning;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type "ParamsValue".
   * Due to valid TS constraints we have modeled this as a union of `ParamsValue | any`.
  */
  [additionalPropertyName: string]: ParamsValue | any;
}

/**
 * Provisioning profile fetch and store information
*/
export interface CreateOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface CreateOKResponseToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  CreateOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface CreateOKResponseToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface CreateOKResponseToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface CreateOKResponseToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface CreateOKResponseToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: CreateOKResponseToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: CreateOKResponseToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: CreateOKResponseToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: CreateOKResponseToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface CreateOKResponseArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

export interface CreateOKResponseModelModelModel {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: CreateOKResponseToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: CreateOKResponseArtifactVersioning;
  id: number;
}

/**
 * Provisioning profile fetch and store information
*/
export interface UpdateOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem {
  /**
   * Name of uploaded provisioning profile
  */
  fileName?: string;
  /**
   * File id from secure file storage
  */
  fileId?: string;
  /**
   * Upload id to App Center File Upload Store
  */
  uploadId?: string;
  /**
   * Target the provisioning profile is used to sign
  */
  targetBundleIdentifier?: string;
}

/**
 * Build configuration when Xcode is part of the build steps
*/
export interface UpdateOKResponseToolsetsXcode {
  /**
   * Xcode project/workspace path
  */
  projectOrWorkspacePath?: string;
  /**
   * Path to CococaPods file, if present
  */
  podfilePath?: string;
  /**
   * Path to Carthage file, if present
  */
  cartfilePath?: string;
  provisioningProfileEncoded?: string;
  certificateEncoded?: string;
  provisioningProfileFileId?: string;
  certificateFileId?: string;
  provisioningProfileUploadId?: string;
  appExtensionProvisioningProfileFiles?:
  UpdateOKResponseToolsetsXcodeAppExtensionProvisioningProfileFilesItem[];
  certificateUploadId?: string;
  certificatePassword?: string;
  scheme?: string;
  /**
   * Xcode version used to build. Available versions can be found in "/xcode_versions" API. Default
   * is latest stable version, at the time when the configuration is set.
  */
  xcodeVersion?: string;
  provisioningProfileFilename?: string;
  certificateFilename?: string;
  teamId?: string;
  automaticSigning?: boolean;
  /**
   * The selected pbxproject hash to the repositroy
  */
  xcodeProjectSha?: string;
  /**
   * The build configuration of the target to archive
  */
  archiveConfiguration?: string;
  /**
   * The target id of the selected scheme to archive
  */
  targetToArchive?: string;
  /**
   * Setting this to true forces the build to use Xcode legacy build system. Otherwise, the setting
   * from workspace settings is used.
   * By default new build system is used if workspace setting is not committed to the repository.
   * Only used for iOS React Native app, with Xcode 10.

  */
  forceLegacyBuildSystem?: boolean;
}

/**
 * Build configuration when React Native, or other JavaScript tech, is part of the build steps
*/
export interface UpdateOKResponseToolsetsJavascript {
  /**
   * Path to package.json file for the main project, e.g. "package.json" or "myapp/package.json"
  */
  packageJsonPath?: string;
  /**
   * Whether to run Jest unit tests, via npm test, during the build
  */
  runTests?: boolean;
  /**
   * Version of React Native from package.json files
  */
  reactNativeVersion?: string;
}

/**
 * Build configuration for Xamarin projects
*/
export interface UpdateOKResponseToolsetsXamarin {
  slnPath?: string;
  isSimBuild?: boolean;
  args?: string;
  configuration?: string;
  p12File?: string;
  p12Pwd?: string;
  provProfile?: string;
  monoVersion?: string;
  sdkBundle?: string;
  /**
   * Symlink of the SDK Bundle and Mono installation.
   * The build will use the associated Mono bundled with related Xamarin SDK. If both symlink and
   * monoVersion or sdkBundle are passed, the symlink is taking precedence. If non-existing symlink
   * is passed, the current stable Mono version will be configured for building.

  */
  symlink?: string;
}

/**
 * Build configuration for Android projects
*/
export interface UpdateOKResponseToolsetsAndroid {
  /**
   * Path to the Gradle wrapper script
  */
  gradleWrapperPath?: string;
  /**
   * The Gradle module to build
  */
  module?: string;
  /**
   * The Android build variant to build
  */
  buildVariant?: string;
  /**
   * Whether to run unit tests during the build (default)
  */
  runTests?: boolean;
  /**
   * Whether to run lint checks during the build (default)
  */
  runLint?: boolean;
  /**
   * Whether it is the root module or not
  */
  isRoot?: boolean;
  /**
   * Whether to apply automatic signing or not
  */
  automaticSigning?: boolean;
  /**
   * The password of the keystore
  */
  keystorePassword?: string;
  /**
   * The key alias
  */
  keyAlias?: string;
  /**
   * The key password
  */
  keyPassword?: string;
  /**
   * The name of the keystore file
  */
  keystoreFilename?: string;
  /**
   * The keystore encoded value
  */
  keystoreEncoded?: string;
}

/**
 * The branch build configuration for each toolset
*/
export interface UpdateOKResponseToolsets {
  /**
   * Build configuration when Xcode is part of the build steps
  */
  xcode?: UpdateOKResponseToolsetsXcode;
  /**
   * Build configuration when React Native, or other JavaScript tech, is part of the build steps
  */
  javascript?: UpdateOKResponseToolsetsJavascript;
  /**
   * Build configuration for Xamarin projects
  */
  xamarin?: UpdateOKResponseToolsetsXamarin;
  /**
   * Build configuration for Android projects
  */
  android?: UpdateOKResponseToolsetsAndroid;
}

/**
 * The versioning configuration for artifacts built for this branch
*/
export interface UpdateOKResponseArtifactVersioning {
  /**
   * Possible values include: 'buildId', 'timestamp'
  */
  buildNumberFormat?: string;
}

export interface UpdateOKResponseModelModelModelModelModelModelModelModel {
  /**
   * Possible values include: 'continous', 'continuous', 'manual'
  */
  trigger?: string;
  testsEnabled?: boolean;
  badgeIsEnabled?: boolean;
  signed?: boolean;
  /**
   * A configured branch name to clone from. If provided, all other parameters will be ignored.
   * Only supported in POST requests.
  */
  cloneFromBranch?: string;
  /**
   * The branch build configuration for each toolset
  */
  toolsets?: UpdateOKResponseToolsets;
  /**
   * The versioning configuration for artifacts built for this branch
  */
  artifactVersioning?: UpdateOKResponseArtifactVersioning;
  id: number;
}

export interface ListByBranchOKResponseItem {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface ParamsModel {
  /**
   * Version to build which represents the full Git commit reference
  */
  sourceVersion?: string;
  /**
   * Run build in debug mode
  */
  debug?: boolean;
}

export interface CreateOKResponseModelModelModelModel {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

export interface ListBranchesOKResponseItemValueBranchCommit {
  /**
   * The commit SHA
  */
  sha?: string;
  /**
   * The URL to the commit
  */
  url?: string;
}

export interface ListBranchesOKResponseItemValueBranch {
  /**
   * The branch name
  */
  name: string;
  commit: ListBranchesOKResponseItemValueBranchCommit;
}

/**
 * The branch build core properties
*/
export interface ListBranchesOKResponseItemValue {
  branch?: ListBranchesOKResponseItemValueBranch;
  enabled?: boolean;
}

export interface ListBranchesOKResponseItemLastBuild {
  /**
   * The build ID
  */
  id: number;
  /**
   * The build number
  */
  buildNumber: string;
  /**
   * The time the build was queued
  */
  queueTime: string;
  /**
   * The time the build was started
  */
  startTime?: string;
  /**
   * The time the build was finished
  */
  finishTime?: string;
  /**
   * The time the build status was last changed
  */
  lastChangedDate?: string;
  /**
   * The build status
  */
  status: string;
  /**
   * The build result
  */
  result: string;
  /**
   * The source branch name
  */
  sourceBranch: string;
  /**
   * The source SHA
  */
  sourceVersion: string;
}

/**
 * The branch build status
*/
export interface ListBranchesOKResponseItem {
  configured: boolean;
  lastBuild?: ListBranchesOKResponseItemLastBuild;
  /**
   * Describes unknown properties. The value of an unknown property MUST be of type
   * "ListBranchesOKResponseItemValue". Due to valid TS constraints we have modeled this as a union
   * of `ListBranchesOKResponseItemValue | any`.
  */
  [additionalPropertyName: string]: ListBranchesOKResponseItemValue | any;
}

export interface ListBranchesErrorModel {
  id: string;
  code: string;
  message: string;
}

/**
 * Billing Plan
*/
export interface GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetByAppOKResponseBillingPlansBuildService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: GetByAppOKResponseBillingPlansBuildServiceCurrentBillingPeriod;
}

/**
 * Billing Plan
*/
export interface GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccountPlan {
  /**
   * The Billing Plan ID
  */
  id?: string;
  /**
   * Version of the Billing Plan schema
  */
  version?: string;
  /**
   * Price of the Billing Plan
  */
  price?: number;
  /**
   * Service that receives payments for this billing plan. Possible values include: 'None',
   * 'AppCenter', 'GitHub', 'Xtc'
  */
  paymentSource?: string;
  /**
   * Name of the service that the plan applies to. Possible values include: 'Build', 'Test'
  */
  service?: string;
  /**
   * A collection of named numeric values
  */
  limits?: { [propertyName: string]: number };
  /**
   * Collection of attribute values.
  */
  attributes?: { [propertyName: string]: any };
  parentId?: string;
}

/**
 * Selection of a billing plan
*/
export interface GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccount {
  /**
   * Number of instances of the billing plan.
  */
  count?: number;
  /**
   * Billing Plan
  */
  plan?: GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccountPlan;
}

/**
 * Billing plans for a given period
*/
export interface GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriod {
  /**
   * Inclusive start of the period
  */
  startTime?: string;
  /**
   * Exclusive end of the period.
  */
  endTime?: string;
  /**
   * Selection of a billing plan
  */
  byAccount?: GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriodByAccount;
}

/**
 * Billing Plans for a single service
*/
export interface GetByAppOKResponseBillingPlansTestService {
  /**
   * Can customer select trial plan for that service (if it exists)?
  */
  canSelectTrialPlan?: boolean;
  /**
   * Expiration time of the last selected trial plan. Will be null if trial plan was not used.
  */
  lastTrialPlanExpirationTime?: string;
  /**
   * Billing plans for a given period
  */
  currentBillingPeriod?: GetByAppOKResponseBillingPlansTestServiceCurrentBillingPeriod;
}

/**
 * Billing Plans section in the Billing Information
*/
export interface GetByAppOKResponseBillingPlans {
  /**
   * Billing Plans for a single service
  */
  buildService?: GetByAppOKResponseBillingPlansBuildService;
  /**
   * Billing Plans for a single service
  */
  testService?: GetByAppOKResponseBillingPlansTestService;
}

/**
 * Usage for a single period
*/
export interface GetByAppOKResponseUsageBuildServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetByAppOKResponseUsageBuildService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetByAppOKResponseUsageBuildServiceCurrentUsagePeriod;
}

/**
 * Usage for a single period
*/
export interface GetByAppOKResponseUsageTestServiceCurrentUsagePeriod {
  /**
   * Inclusive start time of the usage period
  */
  startTime?: string;
  /**
   * Exclusive end time of the usage period.
  */
  endTime?: string;
  /**
   * A collection of named numeric values
  */
  byAccount?: { [propertyName: string]: number };
  /**
   * A collection of  named numeric values grouped by app
  */
  byApp?: { [propertyName: string]: { [propertyName: string]: number } };
}

/**
 * Resource usage for a single Mobile Center service
*/
export interface GetByAppOKResponseUsageTestService {
  /**
   * Usage for a single period
  */
  currentUsagePeriod?: GetByAppOKResponseUsageTestServiceCurrentUsagePeriod;
}

/**
 * Usage section in the Billing Information
*/
export interface GetByAppOKResponseUsage {
  /**
   * Resource usage for a single Mobile Center service
  */
  buildService?: GetByAppOKResponseUsageBuildService;
  /**
   * Resource usage for a single Mobile Center service
  */
  testService?: GetByAppOKResponseUsageTestService;
}

/**
 * Aggregated Billing Information for a user or an organization
*/
export interface GetByAppOKResponse {
  /**
   * Version of the Billing Information schema
  */
  version?: string;
  /**
   * The ISO 8601 datetime of last modification
  */
  timestamp?: string;
  /**
   * ID of the user or organization
  */
  id?: string;
  /**
   * Billing Plans section in the Billing Information
  */
  billingPlans?: GetByAppOKResponseBillingPlans;
  /**
   * Usage section in the Billing Information
  */
  usage?: GetByAppOKResponseUsage;
  /**
   * Unique identifier for the Azure subscription used for billing
  */
  azureSubscriptionId?: string;
  /**
   * State of the Azure subscription used for billing. Possible values include: 'Enabled',
   * 'Disabled', 'NotSet'
  */
  azureSubscriptionState?: string;
}

export interface GetByAppErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed
  */
  message?: string;
}

/**
 * Error
*/
export interface GetByAppErrorModel {
  error?: GetByAppErrorModelError;
}

export interface DeleteForAppErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteForAppErrorModel {
  error: DeleteForAppErrorModelError;
}

export interface ListForAppOKResponseItem {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListForAppErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListForAppErrorModel {
  error: ListForAppErrorModelError;
}

export interface AzureSubscriptionToAppData {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
}

export interface LinkForAppErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface LinkForAppErrorModel {
  error: LinkForAppErrorModelError;
}

/**
 * The information about the app's owner
*/
export interface UpdateAvatarOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface UpdateAvatarOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface UpdateAvatarOKResponseModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: UpdateAvatarOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: UpdateAvatarOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface DeleteAvatarOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface DeleteAvatarOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface DeleteAvatarOKResponseModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: DeleteAvatarOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: DeleteAvatarOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface GetUsersUnauthorizedResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetUsersUnauthorizedResponse {
  error: GetUsersUnauthorizedResponseError;
}

export interface GetUsersInternalServerErrorResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetUsersInternalServerErrorResponse {
  error: GetUsersInternalServerErrorResponseError;
}

/**
 * Apple Test Flight Groups Response Type
*/
export interface TestFlightGroupsOKResponseItem {
  /**
   * id of the group.
  */
  id?: string;
  /**
   * provider id of the group.
  */
  providerId?: number;
  /**
   * apple id of the group.
  */
  appleId?: number;
  /**
   * name of the group.
  */
  name?: string;
}

export interface TestFlightGroupsErrorModel {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * Apple Mapping Request Type
*/
export interface GetOKResponseModelModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * ID of the apple application in Mobile Center
  */
  appId?: string;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
  /**
   * ID of the apple application in apple store
  */
  appleId?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier?: string;
}

export interface GetErrorModel11 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteErrorModel7 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

/**
 * Apple Mapping Request Type
*/
export interface BodyModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId: string;
  /**
   * ID of the apple application in apple store, takes precedence over bundle_identifier when both
   * are provided
  */
  appleId?: string;
  /**
   * Bundle Identifier of the apple package
  */
  bundleIdentifier?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier: string;
}

/**
 * Apple Mapping Request Type
*/
export interface CreateCreatedResponseModelModelModelModelModel {
  /**
   * ID of the apple application in Mobile Center
  */
  appId?: string;
  /**
   * Id for the shared service connection. In case of Apple AppStore, this connection will be used
   * to create and connect to the Apple AppStore in Mobile Center.
  */
  serviceConnectionId?: string;
  /**
   * ID of the apple application in apple store
  */
  appleId?: string;
  /**
   * ID of the Team associated with the app in apple store
  */
  teamIdentifier?: string;
}

export interface CreateErrorModel6 {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteBadRequestResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteBadRequestResponse {
  error: DeleteBadRequestResponseError;
}

export interface DeleteUnauthorizedResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteUnauthorizedResponse {
  error: DeleteUnauthorizedResponseError;
}

export interface DeleteNotFoundResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteNotFoundResponseModelModel {
  error: DeleteNotFoundResponseError;
}

export interface ListOKResponseItemModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface ListBadRequestResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListBadRequestResponseModel {
  error: ListBadRequestResponseError;
}

export interface ListUnauthorizedResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListUnauthorizedResponse {
  error: ListUnauthorizedResponseError;
}

export interface Description {
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
}

export interface NewCreatedResponse {
  /**
   * The unique id (UUID) of the api token
  */
  id: string;
  /**
   * The api token generated will not be accessible again
  */
  apiToken: string;
  /**
   * The description of the token
  */
  description?: string;
  /**
   * The scope for this token.
  */
  scope?: string[];
  /**
   * The creation time
  */
  createdAt: string;
}

export interface NewBadRequestResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface NewBadRequestResponse {
  error: NewBadRequestResponseError;
}

export interface NewUnauthorizedResponseError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface NewUnauthorizedResponse {
  error: NewUnauthorizedResponseError;
}

export interface VersionsOKResponseVersionsItem {
  /**
   * Version.
  */
  version?: string;
  /**
   * Version count.
  */
  count?: number;
  /**
   * The count of previous time range of the version.
  */
  previousCount?: number;
}

export interface VersionsOKResponse {
  /**
   * List of version count.
  */
  versions?: VersionsOKResponseVersionsItem[];
  /**
   * The total count of versions.
  */
  total?: number;
}

export interface VersionsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface VersionsErrorModel {
  error?: VersionsErrorModelError;
}

export interface PerDeviceCountsOKResponseSessionsPerUserItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count.
  */
  count?: number;
}

export interface PerDeviceCountsOKResponse {
  /**
   * Average seesion per user.
  */
  averageSessionsPerUser?: number;
  /**
   * Previous average session per user.
  */
  previousAverageSessionsPerUser?: number;
  /**
   * Total session per device count.
  */
  totalCount?: number;
  /**
   * Previous total count.
  */
  previousTotalCount?: number;
  /**
   * The session count for each interval per device.
  */
  sessionsPerUser?: PerDeviceCountsOKResponseSessionsPerUserItem[];
}

export interface PerDeviceCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface PerDeviceCountsErrorModel {
  error?: PerDeviceCountsErrorModelError;
}

export interface SessionDurationsDistributionOKResponseDistributionItem {
  /**
   * The bucket name.
  */
  bucket?: string;
  /**
   * The count of sessions in current bucket.
  */
  count?: number;
}

export interface SessionDurationsDistributionOKResponse {
  /**
   * The count of sessions in these buckets.
  */
  distribution?: SessionDurationsDistributionOKResponseDistributionItem[];
  /**
   * The previous average session duration for previous time range.
  */
  previousAverageDuration?: string;
  /**
   * The average session duration for current time range.
  */
  averageDuration?: string;
}

export interface SessionDurationsDistributionErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface SessionDurationsDistributionErrorModel {
  error?: SessionDurationsDistributionErrorModelError;
}

export interface SessionCountsOKResponseItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface SessionCountsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface SessionCountsErrorModel {
  error: SessionCountsErrorModelError;
}

/**
 * The place code and the count.
*/
export interface PlaceCountsOKResponsePlacesItem {
  /**
   * The place code.
  */
  code?: string;
  /**
   * The count of the this place.
  */
  count?: number;
  /**
   * The count of previous time range of the place.
  */
  previousCount?: number;
}

/**
 * Places and count during the time range in descending order.
*/
export interface PlaceCountsOKResponse {
  total?: number;
  places?: PlaceCountsOKResponsePlacesItem[];
}

export interface PlaceCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface PlaceCountsErrorModel {
  error?: PlaceCountsErrorModelError;
}

export interface OperatingSystemCountsOKResponseOsesItem {
  /**
   * OS name.
  */
  osName?: string;
  /**
   * Count current of OS.
  */
  count?: number;
  /**
   * Count of previous OS.
  */
  previousCount?: number;
}

export interface OperatingSystemCountsOKResponse {
  total?: number;
  oses?: OperatingSystemCountsOKResponseOsesItem[];
}

export interface OperatingSystemCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface OperatingSystemCountsErrorModel {
  error?: OperatingSystemCountsErrorModelError;
}

export interface ModelCountsOKResponseModelsItem {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count current of model.
  */
  count?: number;
  /**
   * Count of previous model.
  */
  previousCount?: number;
}

export interface ModelCountsOKResponse {
  total?: number;
  modelsProperty?: ModelCountsOKResponseModelsItem[];
}

export interface ModelCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface ModelCountsErrorModel {
  error?: ModelCountsErrorModelError;
}

/**
 * Device characteristics.
*/
export interface LogFlowOKResponseLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

export interface LogFlowOKResponseLogsItem {
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Device characteristics.
  */
  device: LogFlowOKResponseLogsItemDevice;
  /**
   * Polymorphic Discriminator
  */
  type: string;
}

export interface LogFlowOKResponse {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: LogFlowOKResponseLogsItem[];
}

export interface LogFlowErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface LogFlowErrorModel {
  error: LogFlowErrorModelError;
}

export interface LanguageCountsOKResponseLanguagesItem {
  /**
   * Language's name.
  */
  languageName?: string;
  /**
   * Count current of language.
  */
  count?: number;
  /**
   * Count of previous lanugage.
  */
  previousCount?: number;
}

export interface LanguageCountsOKResponse {
  total?: number;
  languages?: LanguageCountsOKResponseLanguagesItem[];
}

export interface LanguageCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface LanguageCountsErrorModel {
  error?: LanguageCountsErrorModelError;
}

/**
 * Device characteristics.
*/
export interface GenericLogFlowOKResponseLogsItemDevice {
  /**
   * Name of the SDK. Consists of the name of the SDK and the platform, e.g. "appcenter.ios",
   * "hockeysdk.android".

  */
  sdkName: string;
  /**
   * Version of the SDK in semver format, e.g. "1.2.0" or "0.12.3-alpha.1".

  */
  sdkVersion: string;
  /**
   * Version of the wrapper SDK in semver format. When the SDK is embedding another base SDK (for
   * example Xamarin.Android wraps Android), the Xamarin specific version is populated into this
   * field while sdkVersion refers to the original Android SDK.

  */
  wrapperSdkVersion?: string;
  /**
   * Name of the wrapper SDK. Consists of the name of the SDK and the wrapper platform, e.g.
   * "appcenter.xamarin", "hockeysdk.cordova".

  */
  wrapperSdkName?: string;
  /**
   * Device model (example: iPad2,3).

  */
  model?: string;
  /**
   * Device manufacturer (example: HTC).

  */
  oemName?: string;
  /**
   * OS name (example: iOS). The following OS names are standardized (non-exclusive): Android, iOS,
   * macOS, tvOS, Windows.

  */
  osName: string;
  /**
   * OS version (example: 9.3.0).

  */
  osVersion: string;
  /**
   * OS build code (example: LMY47X).

  */
  osBuild?: string;
  /**
   * API level when applicable like in Android (example: 15).

  */
  osApiLevel?: number;
  /**
   * Language code (example: en_US).

  */
  locale: string;
  /**
   * The offset in minutes from UTC for the device time zone, including daylight savings time.

  */
  timeZoneOffset: number;
  /**
   * Screen size of the device in pixels (example: 640x480).

  */
  screenSize?: string;
  /**
   * Application version name, e.g. 1.1.0

  */
  appVersion: string;
  /**
   * Carrier name (for mobile devices).

  */
  carrierName?: string;
  /**
   * Carrier country code (for mobile devices).

  */
  carrierCode?: string;
  /**
   * Carrier country.

  */
  carrierCountry?: string;
  /**
   * The app's build number, e.g. 42.

  */
  appBuild: string;
  /**
   * The bundle identifier, package identifier, or namespace, depending on what the individual
   * plattforms use,  .e.g com.microsoft.example.

  */
  appNamespace?: string;
  /**
   * Label that is used to identify application code 'version' released via Live Update beacon
   * running on device

  */
  liveUpdateReleaseLabel?: string;
  /**
   * Identifier of environment that current application release belongs to, deployment key then
   * maps to environment like Production, Staging.

  */
  liveUpdateDeploymentKey?: string;
  /**
   * Hash of all files (ReactNative or Cordova) deployed to device via LiveUpdate beacon. Helps
   * identify the Release version on device or need to download updates in future.

  */
  liveUpdatePackageHash?: string;
  /**
   * Version of the wrapper technology framework (Xamarin runtime version or ReactNative or Cordova
   * etc...). See wrapper_sdk_name to see if this version refers to Xamarin or ReactNative or
   * other.

  */
  wrapperRuntimeVersion?: string;
}

/**
 * Generic log.
*/
export interface GenericLogFlowOKResponseLogsItem {
  /**
   * Log type.
   * . Possible values include: 'event', 'page', 'start_session', 'error', 'push_installation',
   * 'start_service', 'custom_properties'
  */
  type: string;
  /**
   * Log creation timestamp.

  */
  timestamp: Date;
  /**
   * Install ID.

  */
  installId: string;
  /**
   * Session ID.

  */
  sessionId?: string;
  /**
   * Event ID.

  */
  eventId?: string;
  /**
   * Event name.

  */
  eventName?: string;
  /**
   * Message ID.

  */
  messageId?: string;
  /**
   * event specific properties.

  */
  properties?: { [propertyName: string]: string };
  /**
   * Device characteristics.
  */
  device: GenericLogFlowOKResponseLogsItemDevice;
  /**
   * Auth service provider.

  */
  authProvider?: string;
  /**
   * Account ID of the authenticated user.

  */
  accountId?: string;
}

export interface GenericLogFlowOKResponse {
  /**
   * indicates if the number of available logs are more than the max allowed return limit(100).
  */
  exceededMaxLimit?: boolean;
  /**
   * the timestamp of the last log received. This value can be used as the start time parameter in
   * the consecutive API call.
  */
  lastReceivedLogTimestamp?: Date;
  /**
   * the list of logs
  */
  logs: GenericLogFlowOKResponseLogsItem[];
}

export interface GenericLogFlowErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GenericLogFlowErrorModel {
  error: GenericLogFlowErrorModelError;
}

/**
 * An event property value with counts.
*/
export interface EventPropertyCountsOKResponseValuesItem {
  /**
   * The event property value name.
  */
  name?: string;
  /**
   * The count of the the event property value.
  */
  count?: number;
  /**
   * The count of previous time range of the event property value.
  */
  previousCount?: number;
}

/**
 * Event property value counts during the time range in descending order.
*/
export interface EventPropertyCountsOKResponse {
  /**
   * The total property value counts.
  */
  total?: number;
  /**
   * The event property values.
  */
  values?: EventPropertyCountsOKResponseValuesItem[];
}

export interface EventPropertyCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventPropertyCountsErrorModel {
  error?: EventPropertyCountsErrorModelError;
}

/**
 * Event properties during the time range.
*/
export interface EventPropertiesOKResponse {
  eventProperties?: string[];
}

export interface EventPropertiesErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventPropertiesErrorModel {
  error?: EventPropertiesErrorModelError;
}

export interface EventCountOKResponseCountItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface EventCountOKResponse {
  totalCount?: number;
  previousTotalCount?: number;
  count?: EventCountOKResponseCountItem[];
}

export interface EventCountErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventCountErrorModel {
  error?: EventCountErrorModelError;
}

export interface EventDeviceCountOKResponseDevicesCountItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface EventDeviceCountOKResponse {
  totalDevices?: number;
  totalDevicesWithEvent?: number;
  previousTotalDevicesWithEvent?: number;
  devicesCount?: EventDeviceCountOKResponseDevicesCountItem[];
}

export interface EventDeviceCountErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventDeviceCountErrorModel {
  error?: EventDeviceCountErrorModelError;
}

export interface EventPerSessionCountOKResponseCountPerSessionItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Decimal count of the object.
  */
  count?: number;
}

export interface EventPerSessionCountOKResponse {
  avgCountPerSession?: number;
  previousAvgCountPerSession?: number;
  countPerSession?: EventPerSessionCountOKResponseCountPerSessionItem[];
}

export interface EventPerSessionCountErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventPerSessionCountErrorModel {
  error?: EventPerSessionCountErrorModelError;
}

export interface EventPerDeviceCountOKResponseCountPerDeviceItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Decimal count of the object.
  */
  count?: number;
}

export interface EventPerDeviceCountOKResponse {
  avgCountPerDevice?: number;
  previousAvgCountPerDevice?: number;
  countPerDevice?: EventPerDeviceCountOKResponseCountPerDeviceItem[];
}

export interface EventPerDeviceCountErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventPerDeviceCountErrorModel {
  error?: EventPerDeviceCountErrorModelError;
}

export interface EventsDeleteErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventsDeleteErrorModel {
  error?: EventsDeleteErrorModelError;
}

export interface EventsOKResponseEventsItem {
  id?: string;
  name?: string;
  deviceCount?: number;
  /**
   * The device count of previous time range of the event.
  */
  previousDeviceCount?: number;
  count?: number;
  /**
   * The event count of previous time range of the event.
  */
  previousCount?: number;
  countPerDevice?: number;
  countPerSession?: number;
}

export interface EventsOKResponse {
  events?: EventsOKResponseEventsItem[];
  /**
   * The total count of events.
  */
  total?: number;
  /**
   * The active device over this period.
  */
  totalDevices?: number;
}

export interface EventsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventsErrorModel {
  error?: EventsErrorModelError;
}

export interface EventsDeleteLogsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface EventsDeleteLogsErrorModel {
  error?: EventsDeleteLogsErrorModelError;
}

export interface ReleasesReleasesItem {
  /**
   * Release Id.

  */
  release: string;
  /**
   * Distribution group Id.

  */
  distributionGroup?: string;
}

export interface Releases {
  releases: ReleasesReleasesItem[];
}

export interface DistributionReleaseCountsOKResponseCountsItem {
  releaseId: string;
  /**
   * Distribution group queried.

  */
  distributionGroup?: string;
  /**
   * Count of unique downloads against user id.

  */
  uniqueCount: number;
  /**
   * Total count of downloads.

  */
  totalCount: number;
}

export interface DistributionReleaseCountsOKResponse {
  total?: number;
  counts: DistributionReleaseCountsOKResponseCountsItem[];
}

export interface DistributionReleaseCountsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DistributionReleaseCountsErrorModel {
  error: DistributionReleaseCountsErrorModelError;
}

export interface CrashFreeDevicePercentagesOKResponseDailyPercentagesItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Percentage of the object.
  */
  percentage?: number;
}

export interface CrashFreeDevicePercentagesOKResponse {
  /**
   * Average percentage.
  */
  averagePercentage?: number;
  /**
   * The crash-free percentage per day.
  */
  dailyPercentages?: CrashFreeDevicePercentagesOKResponseDailyPercentagesItem[];
}

export interface CrashFreeDevicePercentagesErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashFreeDevicePercentagesErrorModel {
  error?: CrashFreeDevicePercentagesErrorModelError;
}

export interface CrashGroupTotalsOKResponse {
  crashCount?: number;
  deviceCount?: number;
}

export interface CrashGroupTotalsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashGroupTotalsErrorModel {
  error?: CrashGroupTotalsErrorModelError;
}

export interface CrashGroupOperatingSystemCountsOKResponseOperatingSystemsItem {
  /**
   * OS name.
  */
  operatingSystemName?: string;
  /**
   * Count of OS.
  */
  crashCount?: number;
}

export interface CrashGroupOperatingSystemCountsOKResponse {
  crashCount?: number;
  operatingSystems?: CrashGroupOperatingSystemCountsOKResponseOperatingSystemsItem[];
}

export interface CrashGroupOperatingSystemCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashGroupOperatingSystemCountsErrorModel {
  error?: CrashGroupOperatingSystemCountsErrorModelError;
}

export interface CrashGroupModelCountsOKResponseModelsItem {
  /**
   * Model's name.
  */
  modelName?: string;
  /**
   * Count of model.
  */
  crashCount?: number;
}

export interface CrashGroupModelCountsOKResponse {
  crashCount?: number;
  modelsProperty?: CrashGroupModelCountsOKResponseModelsItem[];
}

export interface CrashGroupModelCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashGroupModelCountsErrorModel {
  error?: CrashGroupModelCountsErrorModelError;
}

export interface CrashGroupCountsOKResponseCrashesItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface CrashGroupCountsOKResponse {
  /**
   * Total crash count.
  */
  count?: number;
  /**
   * The total crash count for day.
  */
  crashes?: CrashGroupCountsOKResponseCrashesItem[];
}

export interface CrashGroupCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashGroupCountsErrorModel {
  error?: CrashGroupCountsErrorModelError;
}

export interface CrashGroupsCrashGroupsItem {
  crashGroupId?: string;
  appVersion?: string;
}

export interface CrashGroups {
  crashGroups: CrashGroupsCrashGroupsItem[];
}

export interface CrashGroupsTotalsOKResponseItemOverall {
  crashCount?: number;
  deviceCount?: number;
}

export interface CrashGroupsTotalsOKResponseItem {
  crashGroupId?: string;
  appVersion?: string;
  overall?: CrashGroupsTotalsOKResponseItemOverall;
}

export interface CrashGroupsTotalsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashGroupsTotalsErrorModel {
  error?: CrashGroupsTotalsErrorModelError;
}

export interface CrashCountsOKResponseCrashesItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface CrashCountsOKResponse {
  /**
   * Total crash count.
  */
  count?: number;
  /**
   * The total crash count for day.
  */
  crashes?: CrashCountsOKResponseCrashesItem[];
}

export interface CrashCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface CrashCountsErrorModel {
  error?: CrashCountsErrorModelError;
}

export interface AudienceNameExistsErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface AudienceNameExistsErrorModel {
  error: AudienceNameExistsErrorModelError;
}

export interface DeleteAudienceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface DeleteAudienceErrorModel {
  error: DeleteAudienceErrorModelError;
}

/**
 * Audience with details.
*/
export interface GetAudienceOKResponse {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
  /**
   * Date the audience was last refreshed.
  */
  timestamp?: Date;
}

export interface GetAudienceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface GetAudienceErrorModel {
  error: GetAudienceErrorModelError;
}

/**
 * Audience definition.
*/
export interface AudienceModel {
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Audience definition in OData format.
  */
  definition: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
}

/**
 * Audience with details.
*/
export interface CreateOrUpdateAudienceOKResponse {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
  enabled?: boolean;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
  /**
   * Date the audience was last refreshed.
  */
  timestamp?: Date;
}

export interface CreateOrUpdateAudienceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface CreateOrUpdateAudienceErrorModel {
  error: CreateOrUpdateAudienceErrorModelError;
}

/**
 * List of device property values.
*/
export interface ListDevicePropertyValuesOKResponse {
  /**
   * List of device property values.
  */
  values: string[];
}

export interface ListDevicePropertyValuesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListDevicePropertyValuesErrorModel {
  error: ListDevicePropertyValuesErrorModelError;
}

/**
 * List of device properties.
*/
export interface ListDevicePropertiesOKResponse {
  /**
   * List of device properties.
  */
  values: { [propertyName: string]: string };
}

export interface ListDevicePropertiesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListDevicePropertiesErrorModel {
  error: ListDevicePropertiesErrorModelError;
}

/**
 * List of device properties.
*/
export interface ListCustomPropertiesOKResponse {
  /**
   * List of device properties.
  */
  values: { [propertyName: string]: string };
}

export interface ListCustomPropertiesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListCustomPropertiesErrorModel {
  error: ListCustomPropertiesErrorModelError;
}

/**
 * Audience test result.
*/
export interface TestAudienceOKResponse {
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Custom properties used in the definition.
  */
  customProperties?: { [propertyName: string]: string };
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Estimated total audience size.
  */
  estimatedTotalCount?: number;
}

export interface TestAudienceErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface TestAudienceErrorModel {
  error: TestAudienceErrorModelError;
}

/**
 * Audience definition.
*/
export interface ListAudiencesOKResponseValuesItem {
  /**
   * Audience name.
  */
  name?: string;
  /**
   * Audience description.
  */
  description?: string;
  /**
   * Estimated audience size.
  */
  estimatedCount?: number;
  /**
   * Audience definition in OData format.
  */
  definition?: string;
  /**
   * Audience state. Possible values include: 'Calculating', 'Ready', 'Disabled'
  */
  state?: string;
}

/**
 * List of audiences.
*/
export interface ListAudiencesOKResponse {
  /**
   * List of audiences.
  */
  values: ListAudiencesOKResponseValuesItem[];
  nextLink?: string;
}

export interface ListAudiencesErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListAudiencesErrorModel {
  error: ListAudiencesErrorModelError;
}

export interface DeviceCountsOKResponseDailyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface DeviceCountsOKResponseWeeklyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface DeviceCountsOKResponseMonthlyItem {
  /**
   * The ISO 8601 datetime.
  */
  datetime?: string;
  /**
   * Count of the object.
  */
  count?: number;
}

export interface DeviceCountsOKResponse {
  /**
   * The active device count for each interval.
  */
  daily?: DeviceCountsOKResponseDailyItem[];
  /**
   * The active device count for each interval with a week's retention.
  */
  weekly?: DeviceCountsOKResponseWeeklyItem[];
  /**
   * The active device count for each interval with a month's retention.
  */
  monthly?: DeviceCountsOKResponseMonthlyItem[];
}

export interface DeviceCountsErrorModelError {
  /**
   * The status code return by the API. It can be 400 or 403 or 500.
  */
  code?: number;
  /**
   * The reason for the request failed.
  */
  message?: string;
}

/**
 * Error
*/
export interface DeviceCountsErrorModel {
  error?: DeviceCountsErrorModelError;
}

/**
 * The information about the app's owner
*/
export interface GetOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface GetOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface GetOKResponseModelModelModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: GetOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: GetOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface AppModelModel {
  /**
   * A short text describing the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName?: string;
  /**
   * A one-word descriptive release type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The name of the app used in URLs
  */
  name?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The uuid for the icon's asset id from ACFUS
  */
  iconAssetId?: string;
}

/**
 * The information about the app's owner
*/
export interface UpdateOKResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface UpdateOKResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface UpdateOKResponseModelModelModelModelModelModelModelModelModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: UpdateOKResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: UpdateOKResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface CreateCreatedResponseOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface CreateCreatedResponseAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface CreateCreatedResponseModelModelModelModelModelModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: CreateCreatedResponseOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: CreateCreatedResponseAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

/**
 * The information about the app's owner
*/
export interface ListOKResponseItemOwner {
  /**
   * The unique id (UUID) of the owner
  */
  id: string;
  /**
   * The avatar URL of the owner
  */
  avatarUrl?: string;
  /**
   * The owner's display name
  */
  displayName: string;
  /**
   * The owner's email address
  */
  email?: string;
  /**
   * The unique name that used to identify the owner
  */
  name: string;
  /**
   * The owner type. Can either be 'org' or 'user'. Possible values include: 'org', 'user'
  */
  type: string;
}

export interface ListOKResponseItemAzureSubscription {
  /**
   * The azure subscription id
  */
  subscriptionId: string;
  /**
   * The tenant id of the azure subscription belongs to
  */
  tenantId: string;
  /**
   * The name of the azure subscription
  */
  subscriptionName: string;
  /**
   * If the subscription is used for billing
  */
  isBilling?: boolean;
  /**
   * If the subscription can be used for billing
  */
  isBillable?: boolean;
  /**
   * If the subscription is internal Microsoft subscription
  */
  isMicrosoftInternal?: boolean;
}

export interface ListOKResponseItemModelModelModelModelModelModelModelModelModelModelModelModelModel {
  /**
   * The unique ID (UUID) of the app
  */
  id: string;
  /**
   * The description of the app
  */
  description?: string;
  /**
   * The display name of the app
  */
  displayName: string;
  /**
   * A one-word descriptive release-type value that starts with a capital letter but is otherwise
   * lowercase
  */
  releaseType?: string;
  /**
   * The string representation of the URL pointing to the app's icon
  */
  iconUrl?: string;
  /**
   * The string representation of the source of the app's icon
  */
  iconSource?: string;
  /**
   * The name of the app used in URLs
  */
  name: string;
  /**
   * The OS the app will be running on. Possible values include: 'Android', 'iOS', 'macOS',
   * 'Tizen', 'tvOS', 'Windows', 'Linux', 'Custom'
  */
  os: string;
  /**
   * The information about the app's owner
  */
  owner: ListOKResponseItemOwner;
  /**
   * A unique and secret key used to identify the app in communication with the ingestion endpoint
   * for crash reporting and analytics
  */
  appSecret: string;
  azureSubscription?: ListOKResponseItemAzureSubscription;
  /**
   * The platform of the app. Possible values include: 'Java', 'Objective-C-Swift', 'UWP',
   * 'Cordova', 'React-Native', 'Unity', 'Electron', 'Xamarin', 'WPF', 'WinForms', 'Unknown',
   * 'Custom'
  */
  platform: string;
  /**
   * The creation origin of this app. Possible values include: 'appcenter', 'hockeyapp', 'codepush'
  */
  origin: string;
  /**
   * The created date of this app
  */
  createdAt?: string;
  /**
   * The last updated date of this app
  */
  updatedAt?: string;
  /**
   * The permissions of the calling user
  */
  memberPermissions?: string[];
}

export interface ListAdministeredOKResponseOrganizations {
  /**
   * The internal unique id (UUID) of the organization.
  */
  id: string;
  /**
   * The display name of the organization
  */
  displayName: string;
  /**
   * The slug name of the organization
  */
  name: string;
  /**
   * The URL to a user-uploaded Avatar image
  */
  avatarUrl?: string;
  /**
   * The creation origin of this organization. Possible values include: 'appcenter', 'hockeyapp'
  */
  origin: string;
  /**
   * The creation date of this organization
  */
  createdAt: string;
  /**
   * The date the organization was last updated at
  */
  updatedAt: string;
}

export interface ListAdministeredOKResponse {
  organizations: ListAdministeredOKResponseOrganizations;
}

export interface ListAdministeredErrorModelError {
  /**
   * Possible values include: 'BadRequest', 'Conflict', 'NotAcceptable', 'NotFound',
   * 'InternalServerError', 'Unauthorized', 'TooManyRequests'
  */
  code: string;
  message: string;
}

export interface ListAdministeredErrorModel {
  error: ListAdministeredErrorModelError;
}

export interface GdprExportFeatureFlagOKResponse {
  name?: string;
  targetId?: string;
}

export interface GdprExportAccountOKResponse {
  id?: string;
}

export interface GdprExportAccountsOKResponseResourcesItem {
  rel?: string;
  path?: string;
}

export interface GdprExportAccountsOKResponse {
  resources?: GdprExportAccountsOKResponseResourcesItem[];
}
